<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="个人收藏">
<meta property="og:type" content="website">
<meta property="og:title" content="NNNの博客">
<meta property="og:url" content="https://menggeniu.github.io/page/2/index.html">
<meta property="og:site_name" content="NNNの博客">
<meta property="og:description" content="个人收藏">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NNNの博客">
<meta name="twitter:description" content="个人收藏">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://menggeniu.github.io/page/2/"/>





  <title> NNNの博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">NNNの博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">前端小菜鸟</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/05/12/28/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/28/" itemprop="url">
                  react-native-vector-icons的简单使用,图片,按钮,标签视图,导航条🌀
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-12T21:43:52+08:00">
                2016-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ICONS是可以直接使用图片名, 就能加载图片的三方,使用很方便, 你不需要在工程文件夹里塞各种图片, 节省很多空间,下面就来看看怎么使用吧!<br></p>
<ol>
<li>首先打开terminal进入到我们的工程文件夹下, (不会创建工程的请参考:<a href="http://blog.csdn.net/margaret_mo/article/details/51304062" target="_blank" rel="external">http://blog.csdn.net/margaret_mo/article/details/51304062</a>)<br><br>输入: npm install react-native-vector-icons –save (回车)<br><br>输入: npm install rnpm -g<br><br>输入: rnpm link (回车) <br></li>
<li>在Finder中用Xcode打开工程: …/Demo/ios/Demo.xcodeproj<br><br>(1).右键工程文件Add Files to “(你工程名)”<br><br>(2).选择node_modules/react-native-vector-icons/Fonts文件<br><br>(3).点击”完成”.<br><br><img src="http://images2015.cnblogs.com/blog/909388/201605/909388-20160511152159202-394433862.png" alt=""><br><br><img src="http://images2015.cnblogs.com/blog/909388/201605/909388-20160511152212874-216238892.png" alt=""><br></li>
<li>在xcode的Info.plist文件中,加入: Fonts provided by application数组,并加入以下9项:<br><br><img src="http://images2015.cnblogs.com/blog/909388/201605/909388-20160511152230905-1647193773.png" alt=""><br><br>到此环境就算设置好了, 接下来就是使用ICONS了.<br></li>
<li><p>在Finder中右键用Atom打开工程:<br><br><img src="http://images2015.cnblogs.com/blog/909388/201605/909388-20160511152258874-492588622.png" alt=""><br><br>5.然后就开始编辑我们的程序了:<br></p>
<p> ‘use strict’;</p>
<p> import React, {<br>   AppRegistry,<br>   Component,<br>   View,<br>   StyleSheet,<br>   AlertIOS,<br>   Text,<br>   TabBarIOS,<br>   NavigatorIOS,<br> } from ‘react-native’;</p>
<p> var Icon = require(‘react-native-vector-icons/FontAwesome’);<br> import FindComponent from ‘./FindComponent’;<br> import SearchComponent from ‘./SearchComponent’;</p>
</li>
</ol>
<pre><code>class Demo extends Component {

  state = {
    selectedTab: &apos;find&apos;,
  };

  loginWithFacebook = () =&gt; {   //点击&quot;Login with Facebook&quot;按钮后触发的方法
    AlertIOS.alert(&quot;facebook&quot;);
  }

  render() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Icon
          name=&quot;rocket&quot;   //图片名连接,可以到这个网址搜索:http://ionicons.com/, 使用时:去掉前面的 &quot;icon-&quot; !!!!
          size={30}   //图片大小
          color=&quot;red&quot;  //图片颜色
          /&gt;

    &lt;Icon.Button    //在图片后加文字
      name=&quot;facebook&quot;
      backgroundColor=&quot;#3b5998&quot;
      onPress={this.loginWithFacebook} //点击该按钮后触发的方法
      &gt;
      Login with Facebook
    &lt;/Icon.Button&gt;

    &lt;Icon.Button  //在图片后加, 自定义样式的文字
      name=&quot;facebook&quot;
      backgroundColor=&quot;#3b5998&quot;&gt;
      &lt;Text style={{fontFamily: 'Arial', fontSize: 15}}&gt;Login with Facebook&lt;/Text&gt;
    &lt;/Icon.Button&gt;


    &lt;TabBarIOS    //和标签视图一起使用
     tintColor=&quot;#4977f0&quot;
     barTintColor=&quot;#E6E6E6&quot;&gt;

     &lt;Icon.TabBarItem  //用 Icon.TabBarItem 代替 TabBarIOS.Item
       title=&quot;发现&quot;
       iconName=&quot;home&quot;
       selectedIconName=&quot;home&quot;
       selected = {this.state.selectedTab === &apos;find&apos;}
       onPress={() =&gt; {
         this.setState({
           selectedTab: &apos;find&apos;,
         });
       }}&gt;
       &lt;NavigatorIOS    //导航栏
         style={styles.container}
         tintColor=&apos;#FFFFFF&apos;
         barTintColor=&apos;#4977f0&apos;
         initialRoute={{
               title: "发现",
               titleTextColor: 'white',
               component: FindComponent
             }}/&gt;
     &lt;/Icon.TabBarItem&gt;

     &lt;Icon.TabBarItem  //用 Icon.TabBarItem 代替 TabBarIOS.Item
       title=&quot;搜索&quot;
       iconName=&quot;search&quot;
       selectedIconName=&quot;search&quot;
       selected = {this.state.selectedTab === &apos;search&apos;}
       onPress={() =&gt; {
         this.setState({
           selectedTab: &apos;search&apos;,
         });
       }}&gt;
       &lt;NavigatorIOS
         style={styles.container}
         tintColor=&apos;#FFFFFF&apos;
         barTintColor=&apos;#4977f0&apos;
         initialRoute={{
               title: "搜索",
               titleTextColor: 'white',
               component: SearchComponent
             }}/&gt;
     &lt;/Icon.TabBarItem&gt;
   &lt;/TabBarIOS&gt;

  &lt;/View&gt;
);
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: &apos;center&apos;,
  },
});

AppRegistry.registerComponent(&apos;Demo&apos;, () =&gt; Demo);
</code></pre><p>在terminal中的工程文件夹下,输入react-native run-ios(回车)等待程序运行起来就能看到效果啦.<br><br>主要代码下载地址: <a href="http://download.csdn.net/detail/margaret_mo/9512769" target="_blank" rel="external">http://download.csdn.net/detail/margaret_mo/9512769</a><br><br>参考网站: <a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="external">https://github.com/oblador/react-native-vector-icons</a><br><br>转自：<a href="http://www.cnblogs.com/moxiaoyan33/p/5482024.html" target="_blank" rel="external">http://www.cnblogs.com/moxiaoyan33/p/5482024.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/05/04/27/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/04/27/" itemprop="url">
                  React Native 之 ScrollView 的详解🐯
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-04T21:33:40+08:00">
                2016-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文&lt; <a href="http://godcoder.me/2016/10/05/reactnative-scrollview/&gt;" target="_blank" rel="external">http://godcoder.me/2016/10/05/reactnative-scrollview/&gt;</a><br></p>
<p> 大家好，我是ScrollView，相信做过移动或者前端开发的人肯定都很熟悉我，对，我就是那个可以滚动的容器，滚有点难听，我是可以滑动的容器，我滑动起来，摩擦摩擦，似魔鬼的步伐。我不仅可以上下滚动，就是垂直，还可以左右滚动，这叫有水平。我厉不厉害？我这个人，为人心胸宽广，可以包容很多东西，我这叫宰相肚子里能撑船，什么组件，什么视图都可以放进来，主要是本人太饿了，啥都喜欢吃。这就是我的自我介绍。<br><br> 关于我，我还想说，我这个人身上笑点比较低，随便一触摸就想笑，当然，你们摸我，让我干什么事，我还是很听话的，唯独有一点就是你们别想让我滚，让我滚是有条件的，条件就是必须让我吃饱，吃撑了才可以，这样我才有力气滚动（视图高度一定才可以滚动）。要么设置我的身高是固定的，当然我想长高，所以不建议这么做，要么就是设置我上级的高度，当然要这样做，不要忘了设置flex:1,要不然一样没用。<br></p>
<h3 id="我的性格"><a href="#我的性格" class="headerlink" title="我的性格"></a>我的性格</h3><p>来看看我有哪些性格特点，只有知道了我的性格特点，才更能容易了解我，针对我，容易控制我啊，如果你不了解我，就想让我帮你干活？做梦去吧。<br></p>
<ul>
<li>contentContainerStyle 这个样式会应用到一个内层的内容容器上，所有的子视图都会包裹在内容容器内。</li>
<li>horizontal 如果设为true，意思是我吃的东西都是左右，在水平方向上排列的，貌似不太容易消化（玩笑），默认false，当然是垂直方向了。</li>
<li>keyboardDismissMode enum(‘none’, ‘interactive’, ‘on-drag’) 当我滚动的时候，是否隐藏键盘 <ul>
<li>none（默认值），拖拽时不隐藏软键盘。</li>
<li>on-drag 当拖拽开始的时候隐藏软键盘。</li>
<li>interactive 软键盘伴随拖拽操作同步地消失，并且如果往上滑动会恢复键盘。安卓设备上不支持这个选项，会表现的和none一样。</li>
</ul>
</li>
<li>keyboardShouldPersistTaps 当此属性为false的时候，在软键盘激活之后，点击焦点文本输入框以外的地方，键盘就会隐藏。如果为true，滚动视图不会响应点击操作，并且键盘不会自动消失。默认值为false。</li>
<li>onContentSizeChange function 该函数方法会在ScrollView内部可滚动内容的视图发生变化时调用。</li>
<li>onScroll function 在滚动的过程中，每帧最多调用一次此回调函数。调用的频率可以用scrollEventThrottle属性来控制。</li>
<li>pagingEnabled 如果为true，滚动视图的滚动视图大小的倍数滚动时停止。这可用于水平分页。默认值false。</li>
<li>refreshControl 告诉RefreshControl组件，为我供下拉刷新功能。</li>
<li>removeClippedSubviews （实验属性） 当为true的时候。在ScrollView视图之外的视图(该视图的overflow属性值必须要为hidden)会从被暂时移除，该设置可以提高滚动的性能。</li>
<li>scrollEnabled 为false时，内容视图不可以滚动，默认值true。</li>
<li>showsHorizontalScrollIndicator 当为true时，显示水平滚动条</li>
<li><p>showsVerticalScrollIndicator 与上面正好相反。</p>
<h3 id="我的穿衣打扮"><a href="#我的穿衣打扮" class="headerlink" title="我的穿衣打扮"></a>我的穿衣打扮</h3><p>来，一起来看看，我有哪些外在的服饰和化妆品，可以使用更佳美观和漂亮，修饰我的内在和外在。<br></p>
</li>
<li><p>backfaceVisibility ([‘visible’, ‘hidden’]) 显示还是隐藏</p>
</li>
<li>backgroundColor color 背景色</li>
<li>borderBottomColor color 底部边框颜色</li>
<li>borderBottomLeftRadius number 左下角圆角大小</li>
<li>borderBottomRightRadius 自己翻译（与上同理）</li>
<li>borderBottomWidth 底部边框宽度</li>
<li>borderColor color 边框颜色</li>
<li>borderLeftColor color</li>
<li>borderLeftWidth number 同理</li>
<li>borderRadius number 四周圆角大小</li>
<li>borderRightColor color</li>
<li>borderRightWidth number</li>
<li>borderStyle （[’solid’, ‘dotted’, ‘dashed’]) 边框的样式，是实现，还是点，还是虚线</li>
<li>borderTopColor color</li>
<li>borderTopLeftRadius number</li>
<li>borderTopRightRadius number</li>
<li>borderTopWidth number</li>
<li>borderWidth number 边框宽度</li>
<li>opacity number 设置透明度</li>
<li>overflow ([‘visible’, ‘hidden’])</li>
<li>androidelevation number android5.0以上有的，立体阴影效果</li>
<li>我只介绍了以上常用的的风格，还有几个和android相关，还有很多与ios相关的属性，我就不再介绍了，自己去官方文档查查吧。地址：<a href="https://facebook.github.io/react-native/docs/scrollview.html" target="_blank" rel="external">https://facebook.github.io/react-native/docs/scrollview.html</a><h3 id="我的秀丽身材"><a href="#我的秀丽身材" class="headerlink" title="我的秀丽身材"></a>我的秀丽身材</h3>闻其声不见其人，光知道我，没见过我岂不是很out？像我这么美的人，你们不用我，是不是有点那个啥？哈哈……<br><h4 id="魔鬼样子"><a href="#魔鬼样子" class="headerlink" title="魔鬼样子"></a>魔鬼样子</h4><img src="https://raw.githubusercontent.com/loonggg/BlogImages/master/ReactNative/7.gif" alt=""><br><h4 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  Image,</div><div class="line">  ScrollView,</div><div class="line">  TouchableOpacity,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">class ImageDemo extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">         &lt;View style=&#123;styles.title_view&#125;&gt;</div><div class="line">         &lt;Text style=&#123;styles.title_text&#125;&gt;</div><div class="line">               空间动态</div><div class="line">         &lt;/Text&gt;</div><div class="line">        &lt;/View&gt;</div><div class="line">        &lt;ScrollView  ref=&#123;(scrollView) =&gt; &#123; _scrollView = scrollView; &#125;&#125;&gt;</div><div class="line">        &lt;View style=&#123;styles.three_image_view&#125;&gt;</div><div class="line">         &lt;View style=&#123;styles.vertical_view&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/igs.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:45,height:45&#125;&#125; /&gt;</div><div class="line">              &lt;Text style=&#123;styles.top_text&#125;&gt;</div><div class="line">                好友动态</div><div class="line">              &lt;/Text&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">          &lt;View style=&#123;styles.vertical_view&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/eqc.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:45,height:45&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.top_text&#125;&gt;</div><div class="line">                附近</div><div class="line">              &lt;/Text&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">          &lt;View style=&#123;styles.vertical_view&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/iei.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:45,height:45&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.top_text&#125; &gt;</div><div class="line">                兴趣部落</div><div class="line">              &lt;/Text&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">        &lt;/View&gt;</div><div class="line">        &lt;View style=&#123;&#123;height:30,backgroundColor:&apos;#f9f9fb&apos;&#125;&#125;/&gt;</div><div class="line">        &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                羽毛球</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                火车票</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                视频</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                羽毛球</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                火车票</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                视频</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                羽毛球</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                火车票</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                视频</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                羽毛球</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                火车票</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                视频</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                羽毛球</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                火车票</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                视频</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                羽毛球</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                火车票</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;View style=&#123;styles.rectangle_view&#125;&gt;</div><div class="line">          &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt;</div><div class="line">              &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt;</div><div class="line">              &lt;Text style=&#123;styles.rectangle_text&#125; &gt;</div><div class="line">                视频</div><div class="line">              &lt;/Text&gt;</div><div class="line">          &lt;/View&gt;</div><div class="line">          &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt;</div><div class="line">         &lt;/View&gt;</div><div class="line">         &lt;/ScrollView&gt;</div><div class="line">         &lt;TouchableOpacity</div><div class="line">          style=&#123;styles.button&#125;</div><div class="line">          onPress=&#123;() =&gt; &#123; _scrollView.scrollTo(&#123;y: 0&#125;); &#125;&#125;&gt;</div><div class="line">          &lt;Text&gt;让我滚回去&lt;/Text&gt;</div><div class="line">        &lt;/TouchableOpacity&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line"> container: &#123;</div><div class="line">    flex: 1,</div><div class="line">    backgroundColor: &apos;white&apos;,</div><div class="line">  &#125;,</div><div class="line">   title_view:&#123;</div><div class="line">    flexDirection:&apos;row&apos;,</div><div class="line">    height:50,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor:&apos;#27b5ee&apos;,</div><div class="line">  &#125;,</div><div class="line">   title_text:&#123;</div><div class="line">    color:&apos;white&apos;,</div><div class="line">    fontSize:20,</div><div class="line">    textAlign:&apos;center&apos;</div><div class="line">  &#125;,</div><div class="line">  three_image_view:&#123;</div><div class="line">    paddingTop: 15,</div><div class="line">    flexDirection:&apos;row&apos;,</div><div class="line">    justifyContent: &apos;space-around&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor:&apos;white&apos;,</div><div class="line">  &#125;,</div><div class="line">  vertical_view:&#123;</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor:&apos;white&apos;,</div><div class="line">    paddingBottom:15,</div><div class="line">  &#125;,</div><div class="line">   top_text:&#123;</div><div class="line">    marginTop:5,</div><div class="line">    color:&apos;black&apos;,</div><div class="line">    fontSize:16,</div><div class="line">    textAlign:&apos;center&apos;</div><div class="line">  &#125;,</div><div class="line">  rectangle_view:&#123;</div><div class="line">    paddingTop:8,</div><div class="line">    paddingBottom:8,</div><div class="line">    paddingLeft:15,</div><div class="line">    paddingRight:15,</div><div class="line">    flexDirection:&apos;row&apos;,</div><div class="line">    justifyContent: &apos;space-between&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor:&apos;white&apos;,  </div><div class="line">    borderBottomColor:&apos;#dedfe0&apos;,</div><div class="line">    borderBottomWidth:1,</div><div class="line">  &#125;,</div><div class="line">  rectangle_text:&#123;</div><div class="line">    color:&apos;black&apos;,</div><div class="line">    fontSize:16,</div><div class="line">    textAlign:&apos;center&apos;,</div><div class="line">    paddingLeft:8,</div><div class="line">  &#125;,</div><div class="line">  button: &#123;</div><div class="line">    margin: 7,</div><div class="line">    padding: 5,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#eaeaea&apos;,</div><div class="line">    borderRadius: 3,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line">AppRegistry.registerComponent(&apos;ImageDemo&apos;, () =&gt; ImageDemo);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>ok,到这里ScrollView就讲完了，由于非常简单，大家赶紧去练练手吧！不懂的可以在下面留言，由于我也是第一次学，欢迎大家提出不足，一起交流学习。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/05/02/26/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/02/26/" itemprop="url">
                  ReactNative探索（二）：布局篇🍟
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-02T14:12:17+08:00">
                2016-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="宽度单位和像素密度"><a href="#宽度单位和像素密度" class="headerlink" title="宽度单位和像素密度"></a>宽度单位和像素密度</h3><p>react的宽度不支持百分比，设置宽度时不需要带单位 {width: 10}， 那么10代表的具体宽度是多少呢？<br><br>不知道是官网文档不全还是我眼瞎，反正是没找到，那做一个实验自己找吧：<br></p>
<pre><code>var Dimensions = require(&apos;Dimensions&apos;);
&lt;Text style={styles.welcome}&gt;
      window.width={Dimensions.get(&apos;window&apos;).width + &apos;\n&apos;} 
      window.height={Dimensions.get(&apos;window&apos;).height + &apos;\n&apos;} 
      pxielRatio={PixelRatio.get()}
&lt;/Text&gt; 
</code></pre><p>默认用的是iphone6的模拟器结果是：<br></p>
<pre><code>window.width=375
window.height=667
pxielRatio=2
</code></pre><p>我们知道iphone系列的尺寸如下图：<br><br><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510010.jpg" alt=""><br><br>可以看到iphone 6的宽度为 375pt，对应了上边的375，由此可见react的单位为pt。 那如何获取实际的像素尺寸呢？ 这对图片的高清化很重要，如果我的图片大小为100<em>100 px. 设置宽度为100 </em> 100. 那在iphone上的尺寸就是模糊的。 这个时候需要的图像大小应该是 100 * pixelRatio的大小 。<br><br>react 提供了PixelRatio 的获取方式<a href="https://facebook.github.io/react-native/docs/pixelratio.html" target="_blank" rel="external">https://facebook.github.io/react-native/docs/pixelratio.html</a><br></p>
<pre><code>var image = getImage({
   width: 200 * PixelRatio.get(),
   height: 100 * PixelRatio.get()
 });
 &lt;Image source={image} style={{width: 200, height: 100}} /&gt;
</code></pre><h3 id="flex的布局"><a href="#flex的布局" class="headerlink" title="flex的布局"></a>flex的布局</h3><h4 id="默认宽度"><a href="#默认宽度" class="headerlink" title="默认宽度"></a>默认宽度</h4><p>我们知道一个div如果不设置宽度，默认的会占用100%的宽度， 为了验证100%这个问题， 做三个实验<br></p>
<p>1.根节点上方一个View， 不设置宽度<br><br>2.固定宽度的元素上设置一个View， 不设置宽度<br><br>3.flex的元素上放一个View宽度， 不设置宽度<br></p>
<pre><code>&lt;Text style={[styles.text, styles.header]}&gt;
 根节点上放一个元素，不设置宽度
 &lt;/Text&gt;        

 &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;

 &lt;Text style={[styles.text, styles.header]}&gt;
     固定宽度的元素上放一个View，不设置宽度
 &lt;/Text&gt; 

 &lt;View style={{width: 100}}&gt;
   &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;
 &lt;/View&gt;

 &lt;Text style={[styles.text, styles.header]}&gt;
     flex的元素上放一个View，不设置宽度
 &lt;/Text&gt; 

 &lt;View style={{flexDirection: 'row'}}&gt;
   &lt;View style={{flex: 1}}&gt;
     &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;
   &lt;/View&gt;
   &lt;View style={{flex: 1}}/&gt;
 &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510011.png" alt=""><br><br>结果可以看到flex的元素如果不设置宽度， 都会百分之百的占满父容器。<br></p>
<h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>css 里边经常会做的事情是去讲一个文本或者图片水平垂直居中，如果使用过css 的flexbox当然知道使用alignItems 和 justifyContent . 那用react-native也来做一下实验<br></p>
<pre><code>&lt;Text style={[styles.text, styles.header]}&gt;
    水平居中
&lt;/Text&gt;

&lt;View style={{height: 100, backgroundColor: '#333333', alignItems: 'center'}}&gt;
  &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, borderRadius: 15}}/&gt;
&lt;/View&gt;

 &lt;Text style={[styles.text, styles.header]}&gt;
    垂直居中
&lt;/Text&gt;
&lt;View style={{height: 100, backgroundColor: '#333333', justifyContent: 'center'}}&gt;
  &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, borderRadius: 15}}/&gt;
&lt;/View&gt;

&lt;Text style={[styles.text, styles.header]}&gt;
    水平垂直居中
&lt;/Text&gt;
&lt;View style={{height: 100, backgroundColor: '#333333', alignItems: 'center', justifyContent: 'center'}}&gt;
  &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, borderRadius: 15}}/&gt;
&lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510012.png" alt=""><br></p>
<h4 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h4><p>网格布局实验， 网格布局能够满足绝大多数的日常开发需求，所以只要满足网格布局的spec，那么就可以证明react的flex布局能够满足正常开发需求<br></p>
<h4 id="等分的网格"><a href="#等分的网格" class="headerlink" title="等分的网格"></a>等分的网格</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510013.png" alt=""><br></p>
<pre><code> &lt;View style={styles.flexContainer}&gt;
  &lt;View style={styles.cell}&gt;
    &lt;Text style={styles.welcome}&gt;
      cell1
    &lt;/Text&gt;
  &lt;/View&gt;
  &lt;View style={styles.cell}&gt;
    &lt;Text style={styles.welcome}&gt;
      cell2
    &lt;/Text&gt;
  &lt;/View&gt;
  &lt;View style={styles.cell}&gt;
    &lt;Text style={styles.welcome}&gt;
      cell3
    &lt;/Text&gt;
  &lt;/View&gt;
&lt;/View&gt;

styles = {
    flexContainer: {
        // 容器需要添加direction才能变成让子元素flex
        flexDirection: &apos;row&apos;
    },
    cell: {
        flex: 1,
        height: 50,
        backgroundColor: &apos;#aaaaaa&apos;
    },
    welcome: {
        fontSize: 20,
        textAlign: &apos;center&apos;,
        margin: 10
    },
}
</code></pre><h4 id="左边固定，-右边固定，中间flex的布局"><a href="#左边固定，-右边固定，中间flex的布局" class="headerlink" title="左边固定， 右边固定，中间flex的布局"></a>左边固定， 右边固定，中间flex的布局</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510014.png" alt=""><br></p>
<pre><code>&lt;View style={styles.flexContainer}&gt;
  &lt;View style={styles.cellfixed}&gt;
    &lt;Text style={styles.welcome}&gt;
      fixed
    &lt;/Text&gt;
  &lt;/View&gt;
  &lt;View style={styles.cell}&gt;
    &lt;Text style={styles.welcome}&gt;
      flex
    &lt;/Text&gt;
  &lt;/View&gt;
  &lt;View style={styles.cellfixed}&gt;
    &lt;Text style={styles.welcome}&gt;
      fixed
    &lt;/Text&gt;
  &lt;/View&gt;
&lt;/View&gt;

styles = {
    flexContainer: {
        // 容器需要添加direction才能变成让子元素flex
        flexDirection: &apos;row&apos;
    },
    cell: {
        flex: 1,
        height: 50,
        backgroundColor: &apos;#aaaaaa&apos;
    },
    welcome: {
        fontSize: 20,
        textAlign: &apos;center&apos;,
        margin: 10
    },
    cellfixed: {
        height: 50,
        width: 80,
        backgroundColor: &apos;#fefefe&apos;
    } 
}
</code></pre><h4 id="嵌套的网格"><a href="#嵌套的网格" class="headerlink" title="嵌套的网格"></a>嵌套的网格</h4><p>通常网格不是一层的，布局容器都是一层套一层的， 所以必须验证在real world下面的网格布局<br></p>
<pre><code>&lt;Text style={[styles.text, styles.header]}&gt;
嵌套的网格
  &lt;/Text&gt;
  &lt;View style={{flexDirection: 'row', height: 200, backgroundColor:"#fefefe", padding: 20}}&gt;
    &lt;View style={{flex: 1, flexDirection:'column', padding: 15, backgroundColor:"#eeeeee"}}&gt;  
        &lt;View style={{flex: 1, backgroundColor:"#bbaaaa"}}&gt;  
        &lt;/View&gt;
        &lt;View style={{flex: 1, backgroundColor:"#aabbaa"}}&gt;
        &lt;/View&gt;
    &lt;/View&gt;
    &lt;View style={{flex: 1, padding: 15, flexDirection:'row', backgroundColor:"#eeeeee"}}&gt;
        &lt;View style={{flex: 1, backgroundColor:"#aaaabb"}}&gt;  
            &lt;View style={{flex: 1, flexDirection:'row', backgroundColor:"#eeaaaa"}}&gt; 
               &lt;View style={{flex: 1, backgroundColor:"#eebbaa"}}&gt;  
              &lt;/View&gt;
              &lt;View style={{flex: 1, backgroundColor:"#bbccee"}}&gt;
              &lt;/View&gt; 
            &lt;/View&gt;
            &lt;View style={{flex: 1, backgroundColor:"#eebbdd"}}&gt;
            &lt;/View&gt;
        &lt;/View&gt;
        &lt;View style={{flex: 1, backgroundColor:"#aaccaa"}}&gt;
          &lt;ScrollView style={{flex: 1, backgroundColor:"#bbccdd", padding: 5}}&gt;
                &lt;View style={{flexDirection: 'row', height: 50, backgroundColor:"#fefefe"}}&gt;
                  &lt;View style={{flex: 1, flexDirection:'column', backgroundColor:"#eeeeee"}}&gt;  
                      &lt;View style={{flex: 1, backgroundColor:"#bbaaaa"}}&gt;  
                      &lt;/View&gt;
                      &lt;View style={{flex: 1, backgroundColor:"#aabbaa"}}&gt;
                      &lt;/View&gt;
                  &lt;/View&gt;
                  &lt;View style={{flex: 1, flexDirection:'row', backgroundColor:"#eeeeee"}}&gt;
                      &lt;View style={{flex: 1, backgroundColor:"#aaaabb"}}&gt;  
                          &lt;View style={{flex: 1, flexDirection:'row', backgroundColor:"#eeaaaa"}}&gt; 
                             &lt;View style={{flex: 1, backgroundColor:"#eebbaa"}}&gt;  
                            &lt;/View&gt;
                            &lt;View style={{flex: 1, backgroundColor:"#bbccee"}}&gt;
                            &lt;/View&gt; 
                          &lt;/View&gt;
                          &lt;View style={{flex: 1, backgroundColor:"#eebbdd"}}&gt;
                          &lt;/View&gt;
                      &lt;/View&gt;
                      &lt;View style={{flex: 1, backgroundColor:"#aaccaa"}}&gt;
                      &lt;/View&gt;
                  &lt;/View&gt;
                &lt;/View&gt;
                &lt;Text style={[styles.text, styles.header, {color: &apos;#ffffff&apos;, fontSize: 12}]}&gt;
                  {(function(){
                    var str = &apos;&apos;;
                    var n = 100;
                    while(n--) {
                      str += &apos;嵌套的网格&apos; + &apos;\n&apos;;
                    }
                    return str;
                  })()}
                &lt;/Text&gt;
          &lt;/ScrollView&gt; 
        &lt;/View&gt;
    &lt;/View&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510015.png" alt=""><br><br>好在没被我玩儿坏，可以看到上图的嵌套关系也是足够的复杂的，（我还加了一个ScrollView，然后再嵌套整个结构）嵌套多层的布局是没有问题的。<br></p>
<h4 id="图片布局"><a href="#图片布局" class="headerlink" title="图片布局"></a>图片布局</h4><p>首先我们得知道图片有一个stretchMode. 通过Image.resizeMode访问<br><br><strong>找出有哪些mode</strong><br></p>
<pre><code>var keys = Object.keys(Image.resizeMode).join(&apos;  &apos;);
</code></pre><p>打印出来的是 contain, cover, stretch 这几种模式， （官方文档不知道为什么不直接给出）<br><br><strong>尝试使用这些mode</strong></p>
<pre><code>&lt;Text style={styles.welcome}&gt; 100px height &lt;/Text&gt;
&lt;Image style={{height: 100}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/    TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510016.png" alt=""><br><br>100px 高度， 可以看到图片适应100高度和全屏宽度，背景居中适应未拉伸但是被截断也就是cover。<br></p>
<pre><code>&lt;Text style={styles.welcome}&gt; 100px height with resizeMode contain &lt;/Text&gt;
  &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;}]}&gt;
      &lt;Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.contain}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510017.png" alt=""><br><br>contain 模式容器完全容纳图片，图片自适应宽高<br></p>
<pre><code>&lt;Text style={styles.welcome}&gt; 100px height with resizeMode cover &lt;/Text&gt;
  &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;}]}&gt;
      &lt;Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.cover}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510018.png" alt=""><br><br>cover模式同100px高度模式<br></p>
<pre><code>&lt;Text style={styles.welcome}&gt; 100px height with resizeMode stretch &lt;/Text&gt;
  &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;}]}&gt;
      &lt;Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.stretch}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510019.png" alt=""><br><br>stretch模式图片被拉伸适应屏幕<br></p>
<pre><code>&lt;Text style={styles.welcome}&gt; set height to image container &lt;/Text&gt;
  &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;, height: 100}]}&gt;
      &lt;Image style={{flex: 1}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510020.png" alt=""><br><br>随便试验了一下， 发现高度设置到父容器，图片flex的时候也会等同于cover模式<br></p>
<h4 id="绝对定位和相对定位"><a href="#绝对定位和相对定位" class="headerlink" title="绝对定位和相对定位"></a>绝对定位和相对定位</h4><pre><code>&lt;View style={{flex: 1, height: 100, backgroundColor: '#333333'}}&gt;
&lt;View style={[styles.circle, {position: &apos;absolute&apos;, top: 50, left: 180}]}&gt;
&lt;/View&gt;
  &lt;/View&gt;
  styles = {
    circle: {
    backgroundColor: &apos;#fe0000&apos;,
    borderRadius: 10,
    width: 20,
    height: 20
    }
  }
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510021.png" alt=""><br><br>和css的标准不同的是， 元素容器不用设置position：’absolute|relative’ .<br></p>
<pre><code>&lt;View style={{flex: 1, height: 100, backgroundColor: '#333333'}}&gt;
&lt;View style={[styles.circle, {position: &apos;relative&apos;, top: 50, left: 50, marginLeft: 50}]}&gt;
&lt;/View&gt;
&lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510022.png" alt=""><br><br>相对定位的可以看到很容易的配合margin做到了。 （我还担心不能配合margin，所以测试了一下：-：）<br></p>
<h4 id="padding和margin"><a href="#padding和margin" class="headerlink" title="padding和margin"></a>padding和margin</h4><p>我们知道在css中区分inline元素和block元素，既然react-native实现了一个超级小的css subset。那我们就来实验一下padding和margin在inline和非inline元素上的padding和margin的使用情况。<br><br><strong>padding</strong></p>
<pre><code>&lt;Text style={[styles.text, styles.header]}&gt;
在正常的View上设置padding 
  &lt;/Text&gt;

  &lt;View style={{padding: 30, backgroundColor: '#333333'}}&gt;
    &lt;Text style={[styles.text, {color: &apos;#fefefe&apos;}]}&gt; Text Element&lt;/Text&gt;
  &lt;/View&gt;

  &lt;Text style={[styles.text, styles.header]}&gt;
    在文本元素上设置padding
  &lt;/Text&gt;
  &lt;View style={{padding: 0, backgroundColor: '#333333'}}&gt;
    &lt;Text style={[styles.text, {backgroundColor: &apos;#fe0000&apos;, padding: 30}]}&gt;
      text 元素上设置paddinga
    &lt;/Text&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510023.png" alt=""><br><br>在View上设置padding很顺利，没有任何问题， 但是如果在inline元素上设置padding， 发现会出现上面的错误， paddingTop和paddingBottom都被挤成marginBottom了。 按理说，不应该对Text做padding处理， 但是确实有这样的问题存在，所以可以将这个问题mark一下。<br><br><strong>margin</strong></p>
<pre><code>&lt;Text style={[styles.text, styles.header]}&gt;
在正常的View上设置margin 
  &lt;/Text&gt;

  &lt;View style={{backgroundColor: '#333333'}}&gt;
    &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, margin: 30}}/&gt;
  &lt;/View&gt;

  &lt;Text style={[styles.text, styles.header]}&gt;
    在文本元素上设置margin
  &lt;/Text&gt;
  &lt;View style={{backgroundColor: '#333333'}}&gt;
    &lt;Text style={[styles.text, {backgroundColor: &apos;#fe0000&apos;, margin: 30}]}&gt;
      text 元素上设置margin
    &lt;/Text&gt;
    &lt;Text style={[styles.text, {backgroundColor: &apos;#fe0000&apos;, margin: 30}]}&gt;
      text 元素上设置margin
    &lt;/Text&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510024.png" alt=""><br><br>我们知道，对于inline元素，设置margin-left和margin-right有效，top和bottom按理是不会生效的， 但是上图的结果可以看到，实际是生效了的。所以现在给我的感觉是Text元素更应该理解为一个不能设置padding的block。<br><br>算了不要猜了， 我们看看官方文档怎么说Text，<a href="https://facebook.github.io/react-native/docs/text.html" target="_blank" rel="external">https://facebook.github.io/react-native/docs/text.html</a><br></p>
<pre><code> &lt;Text&gt;
&lt;Text&gt;First part and &lt;/Text&gt;
&lt;Text&gt;second part&lt;/Text&gt;
  &lt;/Text&gt;
  // Text container: all the text flows as if it was one
  // |First part |
  // |and second |
  // |part       |

  &lt;View&gt;
    &lt;Text&gt;First part and &lt;/Text&gt;
    &lt;Text&gt;second part&lt;/Text&gt;
  &lt;/View&gt;
  // View container: each text is its own block
  // |First part |
  // |and        |
  // |second part|
</code></pre><p>也就是如果Text元素在Text里边，可以考虑为inline， 如果单独在View里边，那就是Block。<br><br>下面会专门研究一下文本相关的布局<br></p>
<h4 id="文本元素"><a href="#文本元素" class="headerlink" title="文本元素"></a>文本元素</h4><p>首先我们得考虑对于Text元素我们希望有哪些功能或者想验证哪些功能：<br></p>
<p>1.文字是否能自动换行？<br><br>2.overflow ellipse？<br><br>3.是否能对部分文字设置样式 ，类似span等标签<br></p>
<h4 id="先看看文字有哪些支持的style属性"><a href="#先看看文字有哪些支持的style属性" class="headerlink" title="先看看文字有哪些支持的style属性"></a>先看看文字有哪些支持的style属性</h4><pre><code>/*==========TEXT================*/
  Attributes.style = {
    color string
    containerBackgroundColor string
    fontFamily string
    fontSize number
    fontStyle enum(&apos;normal&apos;, &apos;italic&apos;)
    fontWeight enum(&quot;normal&quot;, &apos;bold&apos;, &apos;100&apos;, &apos;200&apos;, &apos;300&apos;, &apos;400&apos;, &apos;500&apos;, &apos;600&apos;, &apos;700&apos;, &apos;800&apos;, &apos;900&apos;)
    lineHeight number
    textAlign enum(&quot;auto&quot;, &apos;left&apos;, &apos;right&apos;, &apos;center&apos;)
    writingDirection enum(&quot;auto&quot;, &apos;ltr&apos;, &apos;rtl&apos;)
  }
</code></pre><h4 id="实验1，-2，-3"><a href="#实验1，-2，-3" class="headerlink" title="实验1， 2， 3"></a>实验1， 2， 3</h4><pre><code>&lt;Text style={[styles.text, styles.header]}&gt;
      文本元素
  &lt;/Text&gt;

  &lt;View style={{backgroundColor: '#333333', padding: 10}}&gt;
    &lt;Text style={styles.baseText} numberOfLines={5}&gt;
      &lt;Text style={styles.titleText} onPress={this.onPressTitle}&gt;
        文本元素{&apos;\n&apos;}
      &lt;/Text&gt;
      &lt;Text&gt;
        {&apos;\n&apos;}In this example, the nested title and body text will inherit the fontFamily from styles.baseText, but the title provides its own additional styles. The title and body will stack on top of each other on account of the literal newlines, numberOfLines is Used to truncate the text with an elipsis after computing the text layout, including line wrapping, such that the total number of lines does not exceed this number.
      &lt;/Text&gt;
    &lt;/Text&gt;
  &lt;/View&gt;
  styles = {
    baseText: {
      fontFamily: &apos;Cochin&apos;,
      color: &apos;white&apos;
    },
    titleText: {
      fontSize: 20,
      fontWeight: &apos;bold&apos;,
    }
  }
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510025.png" alt=""><br><br>从结果来看1，2，3得到验证。 但是不知道各位有没有发现问题， 为什么底部空出了这么多空间， 没有设置高度啊。 我去除numberOfLines={5} 这行代码，效果如下：<br><br><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510026.png" alt=""><br><br>所以实际上， 那段空间是文本撑开的， 但是文本被numberOfLines={5} 截取了，但是剩余的空间还在。 我猜这应该是个bug。<br><br>其实官方文档里边把numberOfLines={5}这句放到的是长文本的Text元素上的，也就是子Text上的。 实际结果是不生效。 这应该又是一个bug。<br><br>Text元素的子Text元素的具体实现是怎样的， 感觉这货会有很多bug， 看官文<br></p>
<pre><code>&lt;Text style={{fontWeight: 'bold'}}&gt;
  I am bold
  &lt;Text style={{color: 'red'}}&gt;
    and red
  &lt;/Text&gt;
 &lt;/Text&gt;

Behind the scenes, this is going to be converted to a flat
NSAttributedString that contains the following information

&quot;I am bold and red&quot;
 0-9: bold
 9-17: bold, red
</code></pre><p>好吧， 那对于numberOfLines={5} 放在子Text元素上的那种bug倒是可以解释了。<br></p>
<h4 id="Text的样式继承"><a href="#Text的样式继承" class="headerlink" title="Text的样式继承"></a>Text的样式继承</h4><p>实际上React-native里边是没有样式继承这种说法的， 但是对于Text元素里边的Text元素，上面的例子可以看出存在继承。 那既然有继承，问题就来了！<br><br>到底是继承的最外层的Text的值呢，还是继承父亲Text的值呢？<br></p>
<pre><code>&lt;Text style={[styles.text, styles.header]}&gt;
  文本样式继承
  &lt;/Text&gt;

  &lt;View style={{backgroundColor: '#333333', padding: 10}}&gt;
    &lt;Text style={{color: 'white'}}&gt;
      &lt;Text style={{color: 'red'}} onPress={this.onPressTitle}&gt;
         文本元素{&apos;\n&apos;}
        &lt;Text&gt;我是white还是red呢？{&apos;\n&apos;} &lt;/Text&gt;
      &lt;/Text&gt;
      &lt;Text&gt;我应该是white的&lt;/Text&gt;
    &lt;/Text&gt;
  &lt;/View&gt;
</code></pre><p><img src="http://cdn3.infoqstatic.com/statics_s2_20161115-0328/resource/articles/react-native-layout/zh/resources/0510027.png" alt=""><br><br>结果可见是直接继承父亲Text的。<br></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>react 宽度基于pt为单位， 可以通过Dimensions 来获取宽高，PixelRatio 获取密度，如果想使用百分比，可以通过获取屏幕宽度手动计算。</li>
<li>基于flex的布局 <ul>
<li>view默认宽度为100%</li>
<li>水平居中用alignItems, 垂直居中用justifyContent</li>
<li>基于flex能够实现现有的网格系统需求，且网格能够各种嵌套无bug</li>
</ul>
</li>
<li>图片布局 <ul>
<li>通过Image.resizeMode来适配图片布局，包括contain, cover, stretch</li>
<li>默认不设置模式等于cover模式</li>
<li>contain模式自适应宽高，给出高度值即可</li>
<li>cover铺满容器，但是会做截取</li>
<li>stretch铺满容器，拉伸</li>
</ul>
</li>
<li><p>定位 </p>
<ul>
<li>定位相对于父元素，父元素不用设置position也行</li>
<li>padding 设置在Text元素上的时候会存在bug。所有padding变成了marginBottom</li>
</ul>
</li>
<li><p>文本元素 </p>
<ul>
<li>文字必须放在Text元素里边</li>
<li>Text元素可以相互嵌套，且存在样式继承关系</li>
<li>numberOfLines 需要放在最外层的Text元素上，且虽然截取了文字但是还是会占用空间<br>转自：<a href="http://www.infoq.com/cn/articles/react-native-layout/" target="_blank" rel="external">http://www.infoq.com/cn/articles/react-native-layout/</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/28/25/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/28/25/" itemprop="url">
                  React Native之设置IOS的图标，名称和启动图🍖
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-28T21:02:43+08:00">
                2016-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-首先，app的名称："><a href="#1-首先，app的名称：" class="headerlink" title="1.首先，app的名称："></a>1.首先，app的名称：</h3><p><img src="http://images2015.cnblogs.com/blog/877983/201608/877983-20160824110318980-1050611130.png" alt=""><br><br>如图所示：我的工程名叫BOOk 在BOOk下面的info.plist的文件里设置app的相关信息：比如Bundle name就是设置APP的名称<br></p>
<h3 id="2-App的图标：（这里注意的是：1-app的图标有尺寸之分，所以如果图片的尺寸不对，编译也就会失败！2-图标的圆角是系统自己设定的，也就是说，我们上传的图片是正正方方的！）"><a href="#2-App的图标：（这里注意的是：1-app的图标有尺寸之分，所以如果图片的尺寸不对，编译也就会失败！2-图标的圆角是系统自己设定的，也就是说，我们上传的图片是正正方方的！）" class="headerlink" title="2.App的图标：（这里注意的是：1.app的图标有尺寸之分，所以如果图片的尺寸不对，编译也就会失败！2.图标的圆角是系统自己设定的，也就是说，我们上传的图片是正正方方的！）"></a>2.App的图标：（这里注意的是：1.app的图标有尺寸之分，所以如果图片的尺寸不对，编译也就会失败！2.图标的圆角是系统自己设定的，也就是说，我们上传的图片是正正方方的！）</h3><p><img src="http://images2015.cnblogs.com/blog/877983/201608/877983-20160824110731401-812968533.png" alt=""><br><br>如图：在工程文件下面的 images.xcassests的文件下是存储图片文件的地方，在IOS开发中一般是将图片放在这个位置，但是在React native的开发中，我们也可以从这里面拿图片使用，也可以自己定义图片存储文件夹，当然为了方便起见，一般我们将自定义图片文件夹放在RN工程中，android、IOS的工程外，当然，启动图啥的就还是乖乖的放在android，IOS工程里面吧！<br><br><img src="http://images2015.cnblogs.com/blog/877983/201608/877983-20160824111222776-1639235598.png" alt=""><br></p>
<h3 id="3-启动图："><a href="#3-启动图：" class="headerlink" title="3.启动图："></a>3.启动图：</h3><p>同样！启动图也是放在images.xcasssets文件里 ，但是，我们要新建<br></p>
<p><img src="http://images2015.cnblogs.com/blog/877983/201608/877983-20160824111448761-942336200.png" alt=""><br><br>失误~吧QQ给截图出来了~~~呵呵，点击左侧的空白处` 然后new icon那个 —-new ios launch<br><br>然后我们将启动图拖拽到里面~（注意尺寸，要不然编译会出错！！！）<br><br><img src="http://images2015.cnblogs.com/blog/877983/201608/877983-20160824111754730-88380989.png" alt=""><br><br>这个添加好了以后就需要去设置啦~点击项目名称（我这里是BOOK）然后会弹出这样的界面<br><br><img src="http://images2015.cnblogs.com/blog/877983/201608/877983-20160824112015198-543098236.png" alt=""><br><br>这里的App icons source 就是我们设置图标的路径（可以去查看下）<br><br>然后我们要设置的是下面的这个lanch images source 改成我们刚新建的那个启动图就好了~这里注意的是：下面的launch Screen file要设置成空<br><br>ok！完成结束！<br></p>
<p>转自：<a href="http://www.cnblogs.com/allenxieyusheng/p/5802179.html" target="_blank" rel="external">http://www.cnblogs.com/allenxieyusheng/p/5802179.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/25/24/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/25/24/" itemprop="url">
                  React Native简单教程🌼
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-25T22:11:01+08:00">
                2016-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="最近开始研究react-native，准备写几篇关于react-native的文章。"><a href="#最近开始研究react-native，准备写几篇关于react-native的文章。" class="headerlink" title="最近开始研究react native，准备写几篇关于react native的文章。"></a>最近开始研究react native，准备写几篇关于react native的文章。</h6><p>作为一个 JavaScript 开发者，我之前从来没想过用 JavaScript 很容易地写原生移动应用。当然，我们已经有了如 PhoneGap 等工具，但在原生应用中封装一个基于浏览器的应用还有许多需要改进的地方。 <br><br>现在这一切都改变了—— Facebook 的 React 团队发布了 React Native。它不仅可以让我们使用 React 框架来使用原生移动组件创建应用程序，但它使一切成为了现实——这意味着我们在开发应用时不需要重新编译——这使得它非常容易地创建移动应用！我有幸预览了 React Native 的 beta 版本，从那开始它大规模成长了起来。<br><br>请注意，目前已经支持 iOS。因此你需要运行 OS X 上的 Xcode 来跟随本教程。<br><br>如果你还没有过机会学习 React, 看看我的教程 来开始用用它吧.<br><br>要重点注意学习这个并不意味着我们可以写一次代码就能将这段代码用到每一个地方。尝试那样做会因为疯狂的抽象级别而陷入一场灾难。React Native 则让我们可以学习一次，到处编写。<br></p>
<h3 id="回到-2004"><a href="#回到-2004" class="headerlink" title="回到 2004"></a>回到 2004</h3><hr>
<p>如果你关注社交网络领域的话你会记得 FaceMash，正式这个应用开创了 Facebook。对于不关注这个领域的人，其实是11年前(哇塞) Mark Zuckerberg 创建了 FaceMash，它是一个你可以用来查看两个人之中谁更加热门的应用程序。每一个人都有一个能反映他们有多“热门”的分数值 (尽管不知道原来使用的是什么算法，不过那部电影（社交网络）显示 Elo 排名算法 曾被使用过) .<br><br>它全部的荣耀都在于此 -<br><br><img src="http://static.oschina.net/uploads/img/201505/19120256_33H2.jpg" alt=""><br><br>让我们整个来过一遍吧 - 我们准备用 React Native 来重新创建 FaceMash。如果你觉得凭外貌来评价姑娘们不道德，你可以把图片变成你觉得能吸引人的其它事务(狗狗，代码块，等等，我不做评价)，随便。<br></p>
<h3 id="创建你的应用"><a href="#创建你的应用" class="headerlink" title="创建你的应用"></a>创建你的应用</h3><hr>
<p>如你所愿，你可以从<a href="https://github.com/rynclark/facemash" target="_blank" rel="external">这儿</a> clone 到初始的代码库。这不是必须的，不过为了不让你错过不同阶段代码的不同分支，你可以 clone 一份下来!<br></p>
<h3 id="休斯顿，我们已经升空"><a href="#休斯顿，我们已经升空" class="headerlink" title="休斯顿，我们已经升空"></a>休斯顿，我们已经升空</h3><hr>
<p> 如果你没有 clone 代码库，就需要设置基础项目.  React Native 可以让我们使用 react-native-cli npm 包 CLI 快速开始一个项目。如果你还没有安装这个，可以快速运行命令：<br></p>
<pre><code>npm install -g react-native-cli
</code></pre><p> 然后我们就可以开始了.<br><br>在终端里导航到一个文件夹并运行命令：<br></p>
<pre><code>react-native init FaceMash
</code></pre><p>这样做能为我们准备好基础到应用程序，供我们挖掘和加入更多东西.<br></p>
<h3 id="打开它"><a href="#打开它" class="headerlink" title="打开它"></a>打开它</h3><hr>
<p> 打开 XCode 并浏览到你创建了应用程序的目录里面. 你需要从这里打开 facemash.xcodeproj。<br><br>React Native 支持我们在 iOS 模拟器和实际的 iOS 设备上工作.<br><br>我将会在 iOS 模拟器上面进行开发，因为它运行更多快速的应用程序开发 - 当我们修改了JavaScript 时，可以按下 Command + R 组合建来刷新应用，或者我们也可以通过 developer 菜单(通过 Command + Control + Z 就能访问到)启用动态重新载入来变成超级懒人。我们设置可以在Chrome的开发者工具中调试我们的代码。<br><br>如果你希望使用你的 iOS 设备来开发你的应用程序，就需要让设备痛你的计算机处于同一个网络中。React 默认会在 localhost 找到 JavaScript，所以就需要你将它指向你的计算机.<br><br>我们可以通过编辑 AppDelegate.m 文件，将 localhost 改成我们的本地 IP 来达成这个目的. 你可以通过按下 Alt 的同时点击 wireless 菜单 在 OS X 来找到这个东西.<br><br><img src="http://static.oschina.net/uploads/img/201505/19120257_Ju7r.png" alt=""><br><br>现在就可以运行我们的应用程序了。应用程序会在你在 XCode 中选择的目标中打开. 当我们点击运行，同时会产生一个在我们应用程序目录中运行着 npm start 的终端线程. 如果你不希望通过 XCode 运行应用，确保你运行了 npm start。这将会创建一个在端口8081上的本地 web 服务器，它指向我们编译好的 JavaScript 代码，并且也会监视到我们保存代码的动作以进行重新编译。<br><br><img src="http://static.oschina.net/uploads/img/201505/19120258_yw4N.png" alt=""><br><br>我把应用程序运行在一个模拟的 iPhone6 之上, 屏幕是真实设备的50%那么大.<br><br>这就是了，我们有了一个空的 canvas，有好多空间活动啊!<br></p>
<h3 id="悄悄来看一看"><a href="#悄悄来看一看" class="headerlink" title="悄悄来看一看"></a>悄悄来看一看</h3><hr>
<p>让我来看看拿来渲染我们可以在上面的截屏中所看到的东西的代码. 打开 index.ios.js.<br></p>
<pre><code>/**
 * Sample React Native App
 * https://github.com/facebook/react-native
 */
&apos;use strict&apos;;
var React = require(&apos;react-native&apos;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} = React;
var facemash = React.createClass({
  render: function() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.welcome}&gt;
          Welcome to React Native!
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          To get started, edit index.ios.js
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          Press Cmd+R to reload,{&apos;\n&apos;}
          Cmd+Control+Z for dev menu
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});
var styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    backgroundColor: &apos;#F5FCFF&apos;,
  },
  welcome: {
    fontSize: 20,
    textAlign: &apos;center&apos;,
    margin: 10,
  },
  instructions: {
    textAlign: &apos;center&apos;,
    color: &apos;#333333&apos;,
    marginBottom: 5,
  },
});
AppRegistry.registerComponent(&apos;facemash&apos;, () =&gt; facemash);
</code></pre><p>你可以合上你惊讶的嘴了 - 是的，这就是我们拿来渲染我们的应用程序的全部东西。看起来熟悉，对不对?<br></p>
<h3 id="React-Native-vs-浏览器"><a href="#React-Native-vs-浏览器" class="headerlink" title="React Native vs 浏览器"></a>React Native vs 浏览器</h3><hr>
<p>不是 React Native 的所有东西都能满足你在浏览器中使用React的用途. 不过，两者之间的区别是如此的微不足道，所以完全没有必要担心它们.<br><br>1.不使用诸如 div 活着 section 之类的块元素, 我们在React中使用的是View组件. 它会映射到原生的 iOS 组件 UIView.<br><br>2.所有的文本都必须被封装到 Text 组件里面。<br><br>3.没有样式表 - 你的所有的样式都是被写成 JavaScript 对象的。<br><br>4.我们没有必要担心浏览器的兼容性问题 - ES6 harmony 是在盒子之外受到支持的，flexbox也是如此。<br></p>
<h3 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h3><hr>
<p>我们准备从清理 React 组件的样式表盒渲染函数开始。为了对 React Native 有一个理想的基本了解，我们将尝试使用尽可能多的不同组件。<br><br>让我们先从 TabBarIOS 组件开始. 你也许能认出 TabBar 组件来，它被用在诸如时钟和照片这样一些核心的iOS应用中。<br></p>
<pre><code>var React = require(&apos;react-native&apos;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  TabBarIOS
} = React;
var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        &lt;TabBarIOS.Item
          title=&quot;FaceMash&quot;
          icon={ require(&apos;image!facemash&apos;) }
          selected={ this.state.selectedTab === &apos;faceMash&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Face Mash&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Messages&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Settings&quot;
          icon={ require(&apos;image!settings&apos;) }
          selected={ this.state.selectedTab === &apos;settings&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Settings&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
      &lt;/TabBarIOS&gt;
    );
  }
});
var styles = StyleSheet.create({
  pageView: {
    backgroundColor: &apos;#fff&apos;,
    flex: 1
  }
});
// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120258_ezqI.png" alt=""><br><br>看看这个！你会注意到当前的文本覆在了状态条上面，我们稍后会修复这个问题。<br><br>TabBarIOS 组件对它的每一个子项都使用了 TabBarIOS.Item。我们将会有三个页面——分别是你给人们评级的页面，一个消息列表以及一个设置的页面。<br><br>TabBarIOS.Item 必须有一个子项。他将会是已经被选取的页面的内容(你可以发现我们会根据组件的状态来选择设置成true还是false)。<br><br>很明显，一个 TAB 条没有图标不会好看。有几个系统图标是你可以拿来用的，不过如果你用了他们的话，TAB 的文字也会发生变化，以与系统的图标配对. 所以我们会使用自己的图标。为了在 React Native 中引入本地的图片资源，你可以使用 require 后面带上图片的资源名称！<br><br>我使用的图标是可以免费拿来用的，来自于 <a href="http://www.flaticon.com/" target="_blank" rel="external">flaticon</a> 的 CC 3.0 许可.<br></p>
<h3 id="使用静态图片"><a href="#使用静态图片" class="headerlink" title="使用静态图片"></a>使用静态图片</h3><hr>
<p>为了向 React Native 添加静态图片，请打开 XCode。在 Project Navigator (左手边的第一个图标)中, 打开 Images.xcassets 。你所有的图片都在那儿。<br><br>这可以让我们将所有的资源保持在同一个名称下，这样可以针对每一个分辨率、甚至是设备的特定图片提供不同的图像资源。<br><br>图像必须遵循一个严格的命名约定。使用的资源名称(比如 messages 或者是 settings) 并在后面给它带上它应该适用来显示的分辨率。例如，我要为 iPhone6 构建一个应用程序，我会为此使用 @2x 分辨率。<br><br>一旦为你的图片进行了正确的命名，就可以将它拖入左手边的 Images.xcassets 中了。<br><br><img src="http://static.oschina.net/uploads/img/201505/19120259_JAJg.png" alt=""><br><br>然后你就可以在 React Native 中使用 require(‘image!assetname’) 了！<br></p>
<h3 id="回到代码"><a href="#回到代码" class="headerlink" title="回到代码"></a>回到代码</h3><hr>
<p>下一个逻辑步骤就是设置我们的主组件使得 Tab 之间的切换可用。我们可以通过设置用户点击它时的状态来做到。TabBarIOS.Item 让我们可以给它一个 onPress 属性，可以拿来检测用户何时按下了一个tab。<br></p>
<pre><code>// omitted code

var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  changeTab(tabName) {
    this.setState({
      selectedTab: tabName
    });
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        &lt;TabBarIOS.Item
          title=&quot;FaceMash&quot;
          icon={ require(&apos;image!facemash&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;faceMash&apos;) }
          selected={ this.state.selectedTab === &apos;faceMash&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Face Mash&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Messages&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Settings&quot;
          icon={ require(&apos;image!settings&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;settings&apos;) }
          selected={ this.state.selectedTab === &apos;settings&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Settings&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
      &lt;/TabBarIOS&gt;
    );
  }
});

// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120259_Aiww.png" alt=""><br><br>可以了！它是多么的简单. 通过在 iOS 模拟器中按下 Command+R 来刷新应用(或者如果你是在真实设备上开发，可以通过 XCode 来对它进行重新编译) 你就会看到现在我们可以进行按下 tab 的操作了，并且主屏幕的显示也发生了变化！<br><br>尽管我们还没有写太多的代码，但是已经见第一个步骤分支的代码 checkout 出来了，里面也包含了我们在这个 tab 上用上了的图标。<br></p>
<h3 id="让我们打分吧"><a href="#让我们打分吧" class="headerlink" title="让我们打分吧"></a>让我们打分吧</h3><hr>
<p>让我们来实现 FaceMash 的 tab 界面吧。我们将会从一个端点那里使用获取来加载到数据。在步骤一的分支中，我已经在 rest/ 目录中包含进来了一个 config.yaml 文件，那是我们将会用来使用 stubby 对端点进行模拟的。所有 endpoint/pictures 中的用户都会被从 randomuser.me 处随机的生成。<br><br>打开你的终端并且运行命令<br></p>
<pre><code>stubby -d rest/config.yaml
</code></pre><p>接着我们就开始吧！<br><br>在名为 tabs/ 的目录中创建一个新文件，命名为 FaceMash.js，在里面放一个基础的 React 组件 -<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View
  } = React;

var facemashTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;
          FaceMash tab!
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = facemashTab;
</code></pre><p>目前我们能从这个Tab上得到全部就是一个里面有一些文字的基础的 View 组件。我们还可以为这个 View 弄一些基础的样式，这样可以确保它具有合适的高和宽。<br><br>我们会添加一个头部，纯粹是用于展示的目的.<br></p>
<pre><code>// omitted code

var facemashTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
        &lt;/View&gt;
        &lt;View style={ styles.content }&gt;
          &lt;Text&gt;
            FaceMash tab!
          &lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
  header: {
    height: 40,
    background: &apos;#ff0000&apos;
  }
});

module.exports = facemashTab;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120259_BD0O.png" alt=""><br><br>现在我们会抱怨状态条的黑色很糟糕，不过不要担心，因为我们可以使用 StatusBarIOS 的 API 来对其进行修改。当 changeTabfunction 被调用时，我们可以检查看看当前的 tab 是不是 FaceMash 的 tab。如果是的话，我们将会把状态调的状态设置为1（白色），如果不是就设置为0(黑色).<br></p>
<h4 id="index-ios-js"><a href="#index-ios-js" class="headerlink" title="index.ios.js"></a>index.ios.js</h4><pre><code>// omitted code

var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  TabBarIOS,
  StatusBarIOS
} = React;

var facemash = React.createClass({
  ...,
  changeTab(tabName) {
  StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0);
    this.setState({
      selectedTab: tabName
    });
  },
  ...
});

// omitted code
</code></pre><p>刷新你就会看到一个白色的状态条 - 解决了!<br><br>我们现在可以访问端点来向我们的用户进行展示了。我们将会使用 fetch，它在 React Native 中默认是被包含了进来的。<br></p>
<pre><code>// omitted code

var facemashTab = React.createClass({
  getInitialState: function() {
    return {
      list: [],
      currentIndex: 0
    };
  },
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/mash&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.setState({ list: res }));
  },
  render: function() {
    return (
      ...
    );
  }
});

// omitted code
</code></pre><p>请求会用返回的数据对我们的状态进行填充。因为初始的数据时一个空的数组，所以我们可以在 render 函数中进行检查，在他们等待的时候显示一个加载页面。<br></p>
<pre><code>var {
  StyleSheet,
  Text,
  View,
  ActivityIndicatorIOS
  } = React;

var facemashTab = React.createClass({
  ...,
  render: function() {
    var contents;
    if (!this.state.list.length) {
      contents = (
        &lt;View style={ styles.loading }&gt;
          &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt;
          &lt;ActivityIndicatorIOS /&gt;
        &lt;/View&gt;
      )
    } else {
      contents = (
        &lt;View style={ styles.content }&gt;
          &lt;Text&gt;Loaded&lt;/Text&gt;
        &lt;/View&gt;
      )
    }
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
          &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt;
        &lt;/View&gt;
        { contents }
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
  loading: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;
  },
  loadingText: {
    fontSize: 14,
    marginBottom: 20
  },
  header: {
    height: 50,
    backgroundColor: &apos;#760004&apos;,
    paddingTop: 20,
    alignItems: &apos;center&apos;
  },
  headerText: {
    color: &apos;#fff&apos;,
    fontSize: 20,
    fontWeight: &apos;bold&apos;
  }
});
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120300_zj6X.png" alt=""><br><br><img src="http://static.oschina.net/uploads/img/201505/19120300_KWEJ.png" alt=""><br><br>现在我们将对位于 this.state.list 的数据进行访问。我们也会在端点返回一个对象的数组时，得到位于状态中的数组的当前索引 - 每个对象都是用户可以进行评比的两个人.<br><br>因为要从两个人中选一个，两者都有同自身相关联的相同数据，我们将创建一个 React 组件来展示他们的数据。<br></p>
<pre><code>// omitted code

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Text&gt;Person!&lt;/Text&gt;
      &lt;/View&gt;
    )
  }
});

var facemashTab = React.createClass({
  getInitialState: function() {
    return {
      list: [],
      currentIndex: 0
    };
  },
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/mash&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.setState({ list: res }));
  },
  render: function() {
    var contents;
    if (!this.state.list.length) {
      contents = (
        &lt;View style={ styles.loading }&gt;
          &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt;
          &lt;ActivityIndicatorIOS /&gt;
        &lt;/View&gt;
      )
    } else {
      var { list, currentIndex } = this.state;
      var record = list[currentIndex];
      var people = record.users.map(person =&gt; &lt;Person person={ person } /&gt;);
      contents = (
        &lt;View style={ styles.content }&gt;
          { people }
        &lt;/View&gt;
      )
    }
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
          &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt;
        &lt;/View&gt;
        { contents }
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  ...,
  person: {
    flex: 1,
    margin: 10,
    borderRadius: 3,
    overflow: &apos;hidden&apos;
  }
});
</code></pre><p>我们现在就有了一个进行两次数据装入（每个人一次）的组件，合适的配置会向它进行传递。现在就可以将个人资料图片和相关的用户信息展示出来了。<br></p>
<h4 id="展示外部的图片"><a href="#展示外部的图片" class="headerlink" title="展示外部的图片"></a>展示外部的图片</h4><p>不同于我们的 tab 图标，我们用来展示的每一个用户的图片都来自一个外部的源. 这不是问题，事实上展示它们要比展示静态资源更加简单.<br><br>我们只是向 Image 组件传递一个对象，而不是向它传入一个需要的图片. 这个对象会有一个属性—— url，它会指向我们想要加载的图片.<br><br>当我们将用户信息作为一个叫做person的属性进行传递时，我们可以通过 this.props.person.picture 访问到图片的 URL。<br></p>
<pre><code>// omitted code
</code></pre><p>var Person = React.createClass({<br>  render: function() {<br>    var person = this.props.person;<br>    return (<br>      <view style="{" styles.person="" }=""><br>        <image style="{" styles.personimage="" }="" source="{" {="" uri:="" person.picture=""><br>      </image></view><br>    )<br>  }<br>});</p>
<p>// omitted code</p>
<p>var styles = StyleSheet.create({<br>  …<br>  person: {<br>    flex: 1,<br>    margin: 10,<br>    borderRadius: 3,<br>    overflow: ‘hidden’<br>  },<br>  personImage: {<br>    flex: 1,<br>    height: 200<br>  },<br>  …<br>});<br>module.exports = facemashTab;</p>
<p>这里也还有一些必要的样式 - 重新设置图片的大小难以置信的简单. 类似的 CSS 属性，比如  background-size，可以在 React Native 中被应用到图片之上, 而这里我们智慧在上面放一个 height，而图片会据此对尺寸进行重新设置.</p>
<p>现在我们可以将剩下的用户信息添加进去了。</p>
<pre><code>// omitted code

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt;
        &lt;View style={ styles.personInfo }&gt;
          &lt;Text style={ styles.personName }&gt;
            { person.firstName } { person.lastName }
          &lt;/Text&gt;
          &lt;View style={ styles.personScore }&gt;
            &lt;Text style={ styles.personScoreHeader }&gt;
              WON
            &lt;/Text&gt;
            &lt;Text style={ [styles.personScoreValue, styles.won] }&gt;
              { person.won }
            &lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={ styles.personScore }&gt;
            &lt;Text style={ styles.personScoreHeader }&gt;
              LOST
            &lt;/Text&gt;
            &lt;Text style={ [styles.personScoreValue, styles.lost] }&gt;
              { person.lost }
            &lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={ styles.personScore }&gt;
            &lt;Text style={ styles.personScoreHeader }&gt;
              SCORE
            &lt;/Text&gt;
            &lt;Text style={ styles.personScoreValue }&gt;
              { person.score }
            &lt;/Text&gt;
          &lt;/View&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    )
  }
});

// omitted code

var styles = StyleSheet.create({
  ...,
  person: {
    flex: 1,
    margin: 10,
    borderRadius: 3,
    overflow: &apos;hidden&apos;
  },
  personInfo: {
    borderLeftColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderLeftWidth: 1,
    borderRightColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderRightWidth: 1,
    borderBottomColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderBottomWidth: 1,
    padding: 10,
    alignItems: &apos;center&apos;,
    flexDirection: &apos;row&apos;
  },
  personImage: {
    flex: 1,
    height: 200
  },
  personName: {
    fontSize: 18,
    flex: 1,
    paddingLeft: 5
  },
  personScore: {
    flex: 0.25,
    alignItems: &apos;center&apos;
  },
  personScoreHeader: {
    color: &apos;rgba( 0, 0, 0, 0.3 )&apos;,
    fontSize: 10,
    fontWeight: &apos;bold&apos;
  },
  personScoreValue: {
    color: &apos;rgba( 0, 0, 0, 0.6 )&apos;,
    fontSize: 16
  },
  won: {
    color: &apos;#93C26D&apos;
  },
  lost: {
    color: &apos;#DD4B39&apos;
  }
});
module.exports = facemashTab;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120300_Q1RG.png" alt=""><br><br>你可以从分支二检出到目前这儿为止的代码。<br><br>现在我们已经让用户显示了出来，可以着手加入点击时间来让用户选择出谁比较热门了。<br></p>
<h4 id="手指触击"><a href="#手指触击" class="headerlink" title="手指触击"></a>手指触击</h4><p> React Native 为我们提供了 TouchableHighlight 组件. 它能让我们的View组件正常的响应触摸. 当它被触摸时，被封装视图的透明度降低了. 这就让我们的组件“感官上”是可以触摸的了.<br><br>我们准备用这个东西封装个人信息部分. 将来我们可能想要创建它来让用户可以在上面点击，从而看到更多有关那个人的图片.<br></p>
<pre><code>// omitted code

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt;
        &lt;TouchableHighlight&gt;
          &lt;View style={ styles.personInfo }&gt;
            &lt;Text style={ styles.personName }&gt;
              { person.firstName } { person.lastName }
            &lt;/Text&gt;
            &lt;View style={ styles.personScore }&gt;
              &lt;Text style={ styles.personScoreHeader }&gt;
                WON
              &lt;/Text&gt;
              &lt;Text style={ [styles.personScoreValue, styles.won] }&gt;
                { person.won }
              &lt;/Text&gt;
            &lt;/View&gt;
            &lt;View style={ styles.personScore }&gt;
              &lt;Text style={ styles.personScoreHeader }&gt;
                LOST
              &lt;/Text&gt;
              &lt;Text style={ [styles.personScoreValue, styles.lost] }&gt;
                { person.lost }
              &lt;/Text&gt;
            &lt;/View&gt;
            &lt;View style={ styles.personScore }&gt;
              &lt;Text style={ styles.personScoreHeader }&gt;
                SCORE
              &lt;/Text&gt;
              &lt;Text style={ styles.personScoreValue }&gt;
                { person.score }
              &lt;/Text&gt;
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    )
  }
});

// omitted code
</code></pre><p>当你重新载入我们所做的修改并且在用户信息上点击，会发现它起作用了 - 但看起来有点糟糕. 这是因为我们还没有在视图上设置一个背景颜色，其意义是让整个组件变暗.<br></p>
<pre><code>// omitted code

var styles = StyleSheet.create({
  ...,
  person: {
    flex: 1,
    margin: 10,
    borderRadius: 3,
    overflow: &apos;hidden&apos;
  },
  personInfo: {
    backgroundColor: &apos;#fff&apos;,
    borderLeftColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderLeftWidth: 1,
    borderRightColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderRightWidth: 1,
    borderBottomColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderBottomWidth: 1,
    padding: 10,
    alignItems: &apos;center&apos;,
    flexDirection: &apos;row&apos;
  },
  ...
});

// omitted code
</code></pre><p>现在当你在信息盒子上点击时，它就能正确工作了!<br><br>TouchableHighlight 为我们提供了 TouchableWithoutFeedback 也有的一个相同的事件。<br>TouchableWithoutFeedback 不应该被使用，因为所有被触摸的东西都应该提供某些类型的视觉上可见的反馈。<br><br>这样我们就可以利用 onPress - 它会在用户已经释放了触摸，但是还没有被打断 (比如还在让他们的手指在可触摸的区域移动)时被调用。<br><br>我们需要向下将一个属性传递到我们的 Person 组件，当其被触摸到时。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ActivityIndicatorIOS,
  TouchableHighlight
  } = React;

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt;
        &lt;TouchableHighlight onPress={ this.props.onPress }&gt;
          ...
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    )
  }
});

var facemashTab = React.createClass({
  ...,
  onPersonPress: function() {
    this.setState({
      currentIndex: this.state.currentIndex + 1
    });
  },
  ...,
  render: function() {
    var contents;
    if (!this.state.list.length) {
      contents = (
        &lt;View style={ styles.loading }&gt;
          &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt;
          &lt;ActivityIndicatorIOS /&gt;
        &lt;/View&gt;
      )
    } else {
      var { list, currentIndex } = this.state;
      var record = list[currentIndex];
      var people = record.users.map(person =&gt; &lt;Person person={ person } onPress={ this.onPersonPress } /&gt;);
      contents = (
        &lt;View style={ styles.content }&gt;
          { people }
        &lt;/View&gt;
      )
    }
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
          &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt;
        &lt;/View&gt;
        { contents }
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>如你所见，在你的主TAB组件里面现在有了一个 onPersonPress 属性. 然后我们就可以将这个传到 Person 组件那儿, 而它们会在 TouchableHighlight 区域被触摸时调用到它. 而后我们可以增加索引，视图就会用新的人物集合来进行重新渲染.<br><br><img src="http://static.oschina.net/uploads/img/201505/19120302_u6Ii.png" alt=""><br><br>这是对 facemash 的 tab 所做的最后修改. 如果你希望走得更远，下面是一些好主意<br><br>1.当选取了一个人物时可以去请求一个 REST 的端点<br><br>2.检查是否已经到达了列表的尽头，显示一条消息<br><br>3.让用户可以在照片上面点击来看更多的照片<br><br>你可以在分支三上面检出 facemash 的 tab 的最终代码。<br></p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><hr>
<p>我们现在将注意力转移到消息tab上了。这一功能有点像 iMessage - 它是有关用户的一个可滚动列表，在其中一项上面点击将会导航至一个针对那个用户的聊天视图。<br><br>幸运的是， React Native 给了我们 ListView 组件，它能让我们拥有一个简单的，（使用了ScrollView的）可滚动列表，而且能高效的显示出列表(只对发生变化的行进行重新渲染，并限制了每次事件循环渲染的行只有一个)。<br><br>为了使用一个 ListView, 我们需要有一个数据源. 数据元让我们可以拥有一个定制的函数来检查一行是不是发生了变化 (可以想到它类似于 toshouldComponentUpdate) ，我们可以把JSON数据放到它里面去. 数据源存在于我们的状态对象之中。<br><br>在 thetabs/folder 下创建一个名为 Messages.js 的新文件 <br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image
  } = React;

var messagesTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>你同时需要编辑 editindex.ios.jsto 来指向新创建的组件 - <br></p>
<pre><code>// omitted code

var MessagesTab = require(&apos;./tabs/Messages&apos;);

var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  changeTab(tabName) {
    StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0);
    this.setState({
      selectedTab: tabName
    });
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        ...
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;MessagesTab /&gt;
        &lt;/TabBarIOS.Item&gt;
        ...
      &lt;/TabBarIOS&gt;
    );
  }
});

// omitted code
</code></pre><p>根据我上面所说的，我们列表视图需要的一个数据源。这个可以通过 viaListView.DataSource 访问。我们将会在 ourgetInitialState 赋初值。 <br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView
  } = React;

var messagesTab = React.createClass({
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>现在我们已经获取到数据源，需要从服务器获取一些数据，知道我们跟谁在通信。我已经包含在一个端点配置中，在 thestep-threebranch 显得更短。 <br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/messages&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.updateDataSource(res));
  },
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  updateDataSource: function(data){
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(data)
    })
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p> 这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。 <br><br>现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。<br><br> andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。 <br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (){
    return (
      &lt;View&gt;
        &lt;Text&gt;Row goes here!&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。 <br><br>现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。<br><br>andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。 <br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (){
    return (
      &lt;View&gt;
        &lt;Text&gt;Row goes here!&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120304_NI1m.png" alt=""><br><br>我们现在每一行都可以显示正确的数据。每个项的对象都作为第一个参数传递给 ourrenderRowfunction。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (person){
    return (
      &lt;View&gt;
        &lt;Text&gt;{ person.user.firstName } { person.user.lastName }&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>我们继续我们的步骤，在这里添加其他的信息，比如图片和最新接收到的信息。 <br><br>在 thetabs/folder 下创建一个名为 Messages.js 的新文件<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image
  } = React;

var messagesTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>你同时需要编辑 editindex.ios.jsto 来指向新创建的组件 -<br></p>
<pre><code>// omitted code

var MessagesTab = require(&apos;./tabs/Messages&apos;);

var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  changeTab(tabName) {
    StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0);
    this.setState({
      selectedTab: tabName
    });
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        ...
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;MessagesTab /&gt;
        &lt;/TabBarIOS.Item&gt;
        ...
      &lt;/TabBarIOS&gt;
    );
  }
});

// omitted code
</code></pre><p>根据我上面所说的，我们列表视图需要的一个数据源。这个可以通过 viaListView.DataSource 访问。我们将会在 ourgetInitialState 赋初值。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView
  } = React;

var messagesTab = React.createClass({
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>现在我们已经获取到数据源，需要从服务器获取一些数据，知道我们跟谁在通信。我已经包含在一个端点配置中，在 thestep-threebranch 显得更短。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/messages&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.updateDataSource(res));
  },
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  updateDataSource: function(data){
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(data)
    })
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。</p>
<p>现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (){
    return (
      &lt;View&gt;
        &lt;Text&gt;Row goes here!&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>我们现在每一行都可以显示正确的数据。每个项的对象都作为第一个参数传递给 ourrenderRowfunction。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (person){
    return (
      &lt;View&gt;
        &lt;Text&gt;{ person.user.firstName } { person.user.lastName }&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>我们继续我们的步骤，在这里添加其他的信息，比如图片和最新接收到的信息。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView,
  PixelRatio
  } = React;

function prettyTime(timestamp) {
  var createdDate = new Date(timestamp);
  var distance = Math.round( ( +new Date() - timestamp ) / 60000 );
  var hours = (&apos;0&apos; + createdDate.getHours()).slice(-2);
  var minutes = (&apos;0&apos; + createdDate.getMinutes()).slice(-2);
  var month = (&apos;0&apos; + (createdDate.getMonth() + 1)).slice(-2);
  var date = (&apos;0&apos; + createdDate.getDate()).slice(-2);
  var year = createdDate.getFullYear();
  var string;
  if (distance &lt; 1440) {
    string = [hours, minutes].join(&apos;:&apos;);
  } else if (distance &lt; 2879) {
    string = &apos;Yesterday&apos;;
  } else {
    string = [date, month, year].join(&apos;/&apos;);
  }
  return string;
}

var messagesTab = React.createClass({
  ...,
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;View style={ styles.row }&gt;
          &lt;Image
            source={ { uri: person.user.picture } }
            style={ styles.cellImage }
            /&gt;
          &lt;View style={ styles.textContainer }&gt;
            &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
              { person.user.firstName } { person.user.lastName }
            &lt;/Text&gt;
            &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
              { time }
            &lt;/Text&gt;
            &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
              { person.lastMessage.contents }
            &lt;/Text&gt;
          &lt;/View&gt;
        &lt;/View&gt;
        &lt;View style={ styles.cellBorder } /&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
  row: {
    flex: 1,
    alignItems: &apos;center&apos;,
    backgroundColor: &apos;white&apos;,
    flexDirection: &apos;row&apos;,
    padding: 10
  },
  textContainer: {
    flex: 1
  },
  cellImage: {
    height: 60,
    borderRadius: 30,
    marginRight: 10,
    width: 60
  },
  time: {
    position: &apos;absolute&apos;,
    top: 0,
    right: 0,
    fontSize: 12,
    color: &apos;#cccccc&apos;
  },
  name: {
    flex: 1,
    fontSize: 16,
    fontWeight: &apos;bold&apos;,
    marginBottom: 2
  },
  lastMessage: {
    color: &apos;#999999&apos;,
    fontSize: 12
  },
  cellBorder: {
    backgroundColor: &apos;rgba(0, 0, 0, 0.1)&apos;,
    height: 1 / PixelRatio.get(),
    marginLeft: 4
  }
});

module.exports = messagesTab;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120304_W92q.png" alt=""><br><br>Looking good! <br><br>你会注意到我们在样式表中使用了一个叫做 PixelRatio 的东西. 用这个我们就可以得到能够拿来在设备上显示的最细的线. 一般，我们会用 1px 作为最细的边框，但是 React Native 中没有 px 的概念。<br><br>现在我们可以添加代码来处理在用户项上面的触摸了。我们将使用 NavigatorIOS 组件 - 你会在诸如 iMessage 和 Notes 这样的应用上看到这个东西. 它能让我们获得视图之间的回退功能，顶端的导航条也会如此。<br><br>实际上我们准备创建一个新的 React 组件来装这个导航。这是因为组件需要对一个初始的 React 组件进行渲染。<br><br>我们会将 messagesTab 组件改称做 messageList，并创建另外一个叫做 messagesTab 的组件<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView,
  PixelRatio,
  NavigatorIOS
  } = React;
// omitted code

var messageList = React.createClass({
  ...,
  render: function(){
    return (
      &lt;View style={ &gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

var messagesTab = React.createClass({
  render: function() {
    return (
      &lt;NavigatorIOS
        style={ styles.container }
        initialRoute={
          {
            title: &apos;Messages&apos;,
            component: messageList
          }
        }
        /&gt;
    );
  }
});

// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120304_kG1d.png" alt=""><br><br>看看已经变得更专业了哦。就像我们在 facemash 的 Tab 中所做的，我们现在可以向行中添加触摸时高亮效果（ TouchableHighlight） 了。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView,
  PixelRatio,
  NavigatorIOS,
  TouchableHighlight
  } = React;

// omitted code

var messageList = React.createClass({
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/messages&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.updateDataSource(res));
  },
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  updateDataSource: function(data){
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(data)
    })
  },
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight&gt;
          &lt;View style={ styles.row }&gt;
            &lt;Image
              source={ { uri: person.user.picture } }
              style={ styles.cellImage }
              /&gt;
            &lt;View style={ styles.textContainer }&gt;
              &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
                { person.user.firstName } { person.user.lastName }
              &lt;/Text&gt;
              &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
                { time }
              &lt;/Text&gt;
              &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
                { person.lastMessage.contents }
              &lt;/Text&gt;
            &lt;/View&gt;
          &lt;/View&gt;
          &lt;View style={ styles.cellBorder } /&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>重新加载然后，你会收到一个错误。这是因为我们传了两个子组件到 TouchableHighlight，但它只能很好的拿一个来进行显示。不要担心啦，我们还可以把这俩子组件封装到另外一个 View 组件中来解决问题啊。<br></p>
<pre><code>// omitted code

var messageList = React.createClass({
  ...,
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight&gt;
          &lt;View&gt;
            &lt;View style={ styles.row }&gt;
              &lt;Image
                source={ { uri: person.user.picture } }
                style={ styles.cellImage }
                /&gt;
              &lt;View style={ styles.textContainer }&gt;
                &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
                  { person.user.firstName } { person.user.lastName }
                &lt;/Text&gt;
                &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
                  { time }
                &lt;/Text&gt;
                &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
                  { person.lastMessage.contents }
                &lt;/Text&gt;
              &lt;/View&gt;
            &lt;/View&gt;
            &lt;View style={ styles.cellBorder } /&gt;
          &lt;/View&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  ...
});

// omitted code
</code></pre><p>现在，当我们在一行上面触摸时，就会收到我们预期的效果了。等等 - 我们的底部边框看起来怪怪的！这是因为我们使用的是 rgba 值。整个视图的背景颜色正在发生变化，这意味着我们的边框随后会变得更暗。不要担心，我们可以给它一个十六进制值的。<br></p>
<pre><code>var styles = StyleSheet.create({
  ...,
  cellBorder: {
    backgroundColor: &apos;#F2F2F2&apos;,
    height: 1 / PixelRatio.get(),
    marginLeft: 4
  }
});
</code></pre><p>如上所述的代码你可以在分支四中看到。<br></p>
<h3 id="按下和弹出"><a href="#按下和弹出" class="headerlink" title="按下和弹出"></a>按下和弹出</h3><hr>
<p>现在我们已经让主列表有了样式，可以来处理用户触摸时导航发生的变化了。<br>]]<br>NavigatorIOS 让我们可以在想要改变当前的路由时，“按下”到组件的里面去。为此，我们需要子组件以及 messagList 中能有某些方式能访问到 NavigatorIOS 实体。幸运的是，这个已经以叫做 navigator 的属性传入了。<br><br>让我们向 TouchableHighlight 组件加入一个 onPress 事件吧.<br></p>
<pre><code>// omitted code

var messageList = React.createClass({
  ...,
  openChat: function (user){
  },
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight onPress={ this.openChat.bind(this, person.user) }&gt;
          ...
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  ...
});

// omitted code
</code></pre><p>现在我们需要一个 React 组件来传递到 navigator。请在 tabs/ 文件夹中创建一个叫做 MessageView.js 的新文件。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);
var {
  StyleSheet,
  Text,
  View
  } = React;

var messageView = React.createClass({
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Message view!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
});

module.exports = messageView;
</code></pre><p>我们可以将这个包含到 Messages.js 文件中，并将它放到 navigator 那儿去。<br></p>
<pre><code>// omitted code

var messageList = React.createClass({
  ...,
  openChat: function (user){
    this.props.navigator.push({
      title: `${user.firstName} ${user.lastName}`,
      component: MessageView,
      passProps: { user }
    });
  },
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight onPress={ this.openChat.bind(this, person.user) }&gt;
          &lt;View&gt;
            &lt;View style={ styles.row }&gt;
              &lt;Image
                source={ { uri: person.user.picture } }
                style={ styles.cellImage }
                /&gt;
              &lt;View style={ styles.textContainer }&gt;
                &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
                  { person.user.firstName } { person.user.lastName }
                &lt;/Text&gt;
                &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
                  { time }
                &lt;/Text&gt;
                &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
                  { person.lastMessage.contents }
                &lt;/Text&gt;
              &lt;/View&gt;
            &lt;/View&gt;
            &lt;View style={ styles.cellBorder } /&gt;
          &lt;/View&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  ...
});

// omitted code
</code></pre><p>从这儿你可以看到我们将下一个路由压入了 navigator。在这儿我们可以设置下一个路由的标题 (用户的姓名)，渲染什么组件 (我们新创建的 MessageView) 以及传入什么属性。这让我们可以访问我们在 MessageView 组件中需要的任何东西 (我们准备传入用户对象)。<br><br><img src="http://static.oschina.net/uploads/img/201505/19120305_AIYQ.png" alt=""><br><br><img src="http://static.oschina.net/uploads/img/201505/19120305_0oGb.png" alt=""><br><br>这对于我们聊天列表中的每一个都会起作用，不管其数量多还是少。<br><br>不过，文本会被我们新的标题条切段。解决这个问题，主要在第一个 View 组件上放一个内边距（padding）就可以了。<br><br>我们现在已经有一个用户属性被传进来了，同样可以对其进行展示！<br></p>
<h3 id="MessageView-js"><a href="#MessageView-js" class="headerlink" title="MessageView.js"></a>MessageView.js</h3><hr>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View
  } = React;
var messageView = React.createClass({
  render: function(){
    var user = this.props.user;
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Chat with { user.firstName } { user.lastName }&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;,
    paddingTop: 64
  },
});

module.exports = messageView;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120305_B0Mj.png" alt=""><br><br>你可以在 <code>step-five</code> 分支检测出上面的代码。<br></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>请自由地在设置 tab 中加入一些功能。尝试使用其他的组件，比如 DatePickerIOS 遗迹 TextInput，来做一些通用的设置 (DOB，name，等等)。<br><br>希望这里的讨论能触及一些同你在你的 React Native 应用程序中通常会用到有所不同的组件。如有任何疑问，可以在推特  @rynclark 上联系我.<br><br>转自：<a href="http://www.oschina.net/translate/going-native-with-react" target="_blank" rel="external">http://www.oschina.net/translate/going-native-with-react</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/21/23/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/21/23/" itemprop="url">
                  requestAnimationFrame，Web中写动画的另一种选择
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-21T12:45:51+08:00">
                2016-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTML5/CSS3时代，我们要在web里做动画选择其实已经很多了:<br><br>你可以用CSS3的animattion+keyframes;<br></p>
<p>你也可以用css3的transition;<br></p>
<p>你还可以用通过在canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现;<br></p>
<p>当然最原始的你还可以使用window.setTimout()或者window.setInterval()通过不断更新元素的状态位置等来实现动画，前提是画面的更新频率要达到每秒60次才能让肉眼看到流畅的动画效果。<br></p>
<p>现在又多了一种实现动画的方案，那就是还在草案当中的window.requestAnimationFrame()方法。<br></p>
<h2 id="初识requestAnimationFrame"><a href="#初识requestAnimationFrame" class="headerlink" title="初识requestAnimationFrame"></a>初识requestAnimationFrame</h2><hr>
<p>来看<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="external">MDN</a>上对其给出的诠释：<br></p>
<pre><code>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint. 

window.requestAnimationFrame() 将告知浏览器你马上要开始动画效果了，后者需要在下次动画前调用相应方法来更新画面。这个方法就是传递给window.requestAnimationFrame()的回调函数。
</code></pre><p>也可这个方法原理其实也就跟setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。<br></p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>可以直接调用，也可以通过window来调用，接收一个函数作为回调，返回一个ID值，通过把这个ID值传给window.cancelAnimationFrame()可以取消该次动画。<br></p>
<pre><code>requestAnimationFrame(callback)//callback为回调函数
</code></pre><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>模拟一个进度条动画，初始div宽度为1px,在step函数中将进度加1然后再更新到div宽度上，在进度达到100之前，一直重复这一过程。<br></p>
<pre><code>&lt;div id=&quot;test&quot; style=&quot;width:1px;height:17px;background:#0f0;&quot;&gt;0%&lt;/div&gt;
&lt;input type=&quot;button&quot; value=&quot;Run&quot; id=&quot;run&quot;/&gt;

window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var start = null;
var ele = document.getElementById(&quot;test&quot;);
var progress = 0;

function step(timestamp) {
    progress += 1;
    ele.style.width = progress + &quot;%&quot;;
    ele.innerHTML=progress + &quot;%&quot;;
    if (progress &lt; 100) {
        requestAnimationFrame(step);
    }
}
requestAnimationFrame(step);
document.getElementById(&quot;run&quot;).addEventListener(&quot;click&quot;, function() {
    ele.style.width = &quot;1px&quot;;
    progress = 0;
    requestAnimationFrame(step);
}, false);
</code></pre><h2 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h2><p>既然还是草案状态下引入的一个功能，在使用全我们就需要关心一下各浏览器对它的支持情况了。就目前来说，主流现代浏览器都对它提供了支持，请看下图：<br></p>
<table>
<thead>
<tr>
<th><img src="http://images.cnitblog.com/blog/431064/201402/131716057436728.png" alt=""></th>
<th><img src="http://images.cnitblog.com/blog/431064/201402/131716525507291.png" alt=""></th>
<th><img src="http://images.cnitblog.com/blog/431064/201402/131717024884229.png" alt=""></th>
<th><img src="http://images.cnitblog.com/blog/431064/201402/131717310762164.png" alt=""></th>
<th><img src="http://images.cnitblog.com/blog/431064/201402/131717469633418.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td>31+</td>
<td>26+</td>
<td>10+</td>
<td>19+</td>
<td>6+</td>
<td></td>
</tr>
</tbody>
</table>
<p>更为具体的浏览器兼容性可以在<a href="http://caniuse.com/" target="_blank" rel="external">这里看到</a>。<br></p>
<h3 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h3><hr>
<p><a href="https://remysharp.com/2010/10/08/what-is-a-polyfill" target="_blank" rel="external">Polyfill</a>就是垫片，按发明这个词的人的原话来说，它就是一段这样的代码，让浏览器原生地支持我们期望使用的一些API。<br><br>就比如这里的requestAnimationFrame，在看到了上面的浏览器支持情况后，你就知道了比上面列出的浏览器版本老的就不支持该方法，但为了让代码能够有更好的浏览器兼容性在老机器上也能运行不报错，我们可以写一些代码让浏览器在不支持requestAnimationFrame的情况下使用window.setTimeout()，这是一种回退（fallback）到过去的方法。<br><br>这样一来，就可以通俗一点的理解polyfill了，它就是备胎。<br><br>下面是由Paul Irish及其他贡献者放在GitHub Gist上的代码片段，用于在浏览器不支持requestAnimationFrame情况下的回退，回退到使用setTmeout的情况。当然，如果你确定代码是工作在现代浏览器中，下面的代码是不必的。<br></p>
<pre><code>// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
// MIT license
(function() {
    var lastTime = 0;
    var vendors = [&apos;ms&apos;, &apos;moz&apos;, &apos;webkit&apos;, &apos;o&apos;];
    for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + &apos;RequestAnimationFrame&apos;];
        window.cancelAnimationFrame = window[vendors[x] + &apos;CancelAnimationFrame&apos;] || window[vendors[x] + &apos;CancelRequestAnimationFrame&apos;];
    }
    if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    };
}());
</code></pre><p>上面代码作用有二，一是把各浏览器前缀进行统一，二是在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法。<br><br>提到备胎代码呢，这里多说一句，在CSS代码中，我们也经常使用这种回退的技巧，即对同一条CSS规则，编写多条以不同浏览器前缀开头代码，或者编写一条备用样式。<br><br>下面是一个CSS中的备胎代码的例子：<br></p>
<pre><code>div {
background: rgb(0, 0, 0); /* fallback */
background: rgba(0, 0, 0, 0.5);
}
</code></pre><p>代码中设置div背景为黑色带50%的透明度，但IE9-的浏览器是不支持rbga格式的颜色的，所以浏览器会回退到上一条CSS规则应用rgb颜色。<br></p>
<p>Reference:</p>
<ol>
<li><p>article about rAF from css tricks: <a href="http://css-tricks.com/using-requestanimationframe/" target="_blank" rel="external">http://css-tricks.com/using-requestanimationframe/</a></p>
</li>
<li><p>article about rAF from Paul Irish:<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="external">http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/</a></p>
</li>
<li><p>what is polyfill <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/" target="_blank" rel="external">http://remysharp.com/2010/10/08/what-is-a-polyfill/</a></p>
</li>
</ol>
<p>转自：<a href="http://www.cnblogs.com/Wayou/p/requestAnimationFrame.html#home" target="_blank" rel="external">http://www.cnblogs.com/Wayou/p/requestAnimationFrame.html#home</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/18/22/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/18/22/" itemprop="url">
                  移动前端知识总结🌟
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-18T21:55:54+08:00">
                2016-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="meta基础知识"><a href="#meta基础知识" class="headerlink" title="meta基础知识"></a>meta基础知识</h3><h4 id="H5页面窗口自动调整到设备宽度，并禁止用户缩放页面"><a href="#H5页面窗口自动调整到设备宽度，并禁止用户缩放页面" class="headerlink" title="H5页面窗口自动调整到设备宽度，并禁止用户缩放页面"></a>H5页面窗口自动调整到设备宽度，并禁止用户缩放页面</h4><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;
</code></pre><h4 id="忽略将页面中的数字识别为电话号码"><a href="#忽略将页面中的数字识别为电话号码" class="headerlink" title="忽略将页面中的数字识别为电话号码"></a>忽略将页面中的数字识别为电话号码</h4><pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;
</code></pre><h4 id="忽略Android平台中对邮箱地址的识别"><a href="#忽略Android平台中对邮箱地址的识别" class="headerlink" title="忽略Android平台中对邮箱地址的识别"></a>忽略Android平台中对邮箱地址的识别</h4><pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;
</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a><meta name="format-detection" content="email=no"></h4><pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;
&lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt;
</code></pre><h4 id="将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式"><a href="#将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式" class="headerlink" title="将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式"></a>将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式</h4><pre><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;
&lt;!-- 可选default、black、black-translucent --&gt;
</code></pre><h3 id="viewport模板"><a href="#viewport模板" class="headerlink" title="viewport模板"></a>viewport模板</h3><h4 id="viewport模板——通用"><a href="#viewport模板——通用" class="headerlink" title="viewport模板——通用"></a>viewport模板——通用</h4><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;
&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;
&lt;title&gt;标题&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
这里开始内容
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>viewport模板 – target-densitydpi=device-dpi，android 2.3.5以下版本不支持<br></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=750, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&lt;!-- width取值与页面定义的宽度一致 --&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;
&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;
&lt;title&gt;标题&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;
&lt;/head&gt;

&lt;body&gt;
这里开始内容
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>参考案例：<a href="http://action.weixin.qq.com/payact/readtemplate?t=Mobile/2015/wxzfsht/index_tmpl" target="_blank" rel="external">http://action.weixin.qq.com/payact/readtemplate?t=Mobile/2015/wxzfsht/index_tmpl</a><br></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="移动端如何定义字体font-family"><a href="#移动端如何定义字体font-family" class="headerlink" title="移动端如何定义字体font-family"></a>移动端如何定义字体font-family</h4><p>中文字体使用系统默认即可，英文用Helvetica<br></p>
<pre><code>/* 移动端定义字体的代码 */
body{font-family:Helvetica;}
</code></pre><p><strong>参考《移动端使用字体的思考》<br></strong></p>
<h4 id="移动端字体单位font-size选择px还是rem"><a href="#移动端字体单位font-size选择px还是rem" class="headerlink" title="移动端字体单位font-size选择px还是rem"></a>移动端字体单位font-size选择px还是rem</h4><p>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可<br><br>著作权归作者所有。<br>商业转载请联系作者获得授权,非商业转载请注明出处。<br>链接:<a href="http://caibaojian.com/mobile-knowledge.html" target="_blank" rel="external">http://caibaojian.com/mobile-knowledge.html</a><br>来源:<a href="http://caibaojian.com" target="_blank" rel="external">http://caibaojian.com</a></p>
<p>对于需要适配各种移动设备，使用rem，例如只需要适配iphone和iPad等分辨率差别比较挺大的设备rem配置参考：<br></p>
<pre><code>html{font-size:10px}
@media screen and (min-width:321px) and (max-width:375px){html{font-size:11px}}
@media screen and (min-width:376px) and (max-width:414px){html{font-size:12px}}
@media screen and (min-width:415px) and (max-width:639px){html{font-size:15px}}
@media screen and (min-width:640px) and (max-width:719px){html{font-size:20px}}
@media screen and (min-width:720px) and (max-width:749px){html{font-size:22.5px}}
@media screen and (min-width:750px) and (max-width:799px){html{font-size:23.5px}}
@media screen and (min-width:800px){html{font-size:25px}}
</code></pre><h4 id="移动端touch事件-区分webkit-和-winphone"><a href="#移动端touch事件-区分webkit-和-winphone" class="headerlink" title="移动端touch事件(区分webkit 和 winphone)"></a>移动端touch事件(区分webkit 和 winphone)</h4><p>当用户手指放在移动设备在屏幕上滑动会触发的touch事件<br><br>以下支持webkit<br><br>1.touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指<br><br>2.touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动<br><br>3.touchend——当手指离开屏幕时触发<br><br>4.touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用<br><br><strong>TouchEvent</strong><br><br>1.touches：屏幕上所有手指的信息<br><br>2.targetTouches：手指在目标区域的手指信息<br><br>3.changedTouches：最近一次触发该事件的手指信息<br><br>4.touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息<br><br><strong>参数信息(changedTouches[0])</strong><br><br>1.clientX、clientY在显示区的坐标<br><br>2.target：当前元素<br><br>参考：<a href="https://developer.mozilla.org/en-US/docs/web/API/TouchEvent" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/web/API/TouchEvent</a><br><br><strong>以下支持winphone 8</strong><br><br>1.MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指<br><br>2.MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动<br><br>3.MSPointerUp——当手指离开屏幕时触发<br></p>
<h4 id="移动端click屏幕产生200-300-ms的延迟响应"><a href="#移动端click屏幕产生200-300-ms的延迟响应" class="headerlink" title="移动端click屏幕产生200-300 ms的延迟响应"></a>移动端click屏幕产生200-300 ms的延迟响应</h4><p>移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。<br><br>以下是历史原因，来源一个公司内一个同事的分享：<br><br>2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。<br><br>双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。<br><br>原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接<a href="”#”"></a>，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面JS捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。<br><br><strong>解决方案：</strong><br><br>1.fastclick可以解决在手机上点击事件的300ms延迟<br><br>2.zepto的touch模块，tap事件也是为了解决在click的延迟问题<br><br><strong>触摸事件的响应顺序</strong><br><br>1.ontouchstart<br><br>2.ontouchmove<br><br>3.ontouchend<br><br>4.onclick<br><br>解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应<br></p>
<h4 id="什么是Retina-显示屏，带来了什么问题"><a href="#什么是Retina-显示屏，带来了什么问题" class="headerlink" title="什么是Retina 显示屏，带来了什么问题"></a>什么是Retina 显示屏，带来了什么问题</h4><p>retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个<br><br>在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍<br><br>那么，前端的应对方案是：<br><br>设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2<br><br>//例如图片宽高为：200px*200px，那么写法如下<br></p>
<pre><code>.css{width:100px;height:100px;background-size:100px 100px;}
</code></pre><p>其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px<br></p>
<pre><code>.css{font-size:20px}
</code></pre><p><strong>参考《高清显示屏原理及设计方案》</strong><br><br>ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉<br><br>ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩<br></p>
<pre><code>a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)}
</code></pre><p>部分android系统中元素被点击时产生的边框怎么去掉<br><br>android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果<br></p>
<pre><code>a,button,input,textarea{
-webkit-tap-highlight-color: rgba(0,0,0,0;)
-webkit-user-modify:read-write-plaintext-only;
}
</code></pre><p>-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符<br><br>另外，有些机型去除不了，如小米2<br><br>对于按钮类还有个办法，不使用a或者input标签，直接用div标签<br><br><strong>参考《如何去除android上a标签产生的边框》</strong><br><br><strong>winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉</strong><br></p>
<pre><code>&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;
</code></pre><p><strong>webkit表单元素的默认外观怎么重置</strong><br></p>
<pre><code>.css{-webkit-appearance:none;}
</code></pre><p><strong>webkit表单输入框placeholder的颜色值能改变么</strong><br></p>
<pre><code>input::-webkit-input-placeholder{color:#AAAAAA;}
input:focus::-webkit-input-placeholder{color:#EEEEEE;}
</code></pre><p><strong>webkit表单输入框placeholder的文字能换行么</strong><br><br>ios可以，android不行~<br><br>在textarea标签下都可以换行~<br><br><strong>IE10（winphone8）表单元素默认外观如何重置</strong><br><br><strong>禁用 select 默认下拉箭头</strong><br><br>::-ms-expand 适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。<br></p>
<pre><code>select::-ms-expand {
display: none;
}
</code></pre><p><strong>禁用 radio 和 checkbox 默认样式</strong><br><br>::-ms-check 适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。<br></p>
<pre><code>input[type=radio]::-ms-check,
input[type=checkbox]::-ms-check
{
display: none;
}
</code></pre><h4 id="禁用PC端表单输入框默认清除按钮"><a href="#禁用PC端表单输入框默认清除按钮" class="headerlink" title="禁用PC端表单输入框默认清除按钮"></a>禁用PC端表单输入框默认清除按钮</h4><p>当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear 适用于该清除按钮的修改，同样设置使它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。<br></p>
<pre><code>input[type=text]::-ms-clear,
input[type=tel]::-ms-clear,
input[type=number]::-ms-clear
{
display: none;
}
</code></pre><h4 id="禁止ios-长按时不触发系统的菜单，禁止ios-amp-android长按时下载图片"><a href="#禁止ios-长按时不触发系统的菜单，禁止ios-amp-android长按时下载图片" class="headerlink" title="禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片"></a>禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片</h4><pre><code>.css{-webkit-touch-callout: none}
</code></pre><h4 id="禁止ios和android用户选中文字"><a href="#禁止ios和android用户选中文字" class="headerlink" title="禁止ios和android用户选中文字"></a>禁止ios和android用户选中文字</h4><pre><code>.css{-webkit-user-select:none}
</code></pre><p><strong>参考《如何改变表单元素的外观(for Webkit and IE10)</strong><br></p>
<h3 id="打电话发短信写邮件怎么实现"><a href="#打电话发短信写邮件怎么实现" class="headerlink" title="打电话发短信写邮件怎么实现"></a>打电话发短信写邮件怎么实现</h3><h4 id="打电话"><a href="#打电话" class="headerlink" title="打电话"></a>打电话</h4><pre><code>&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;
</code></pre><h4 id="发短信，winphone系统无效"><a href="#发短信，winphone系统无效" class="headerlink" title="发短信，winphone系统无效"></a>发短信，winphone系统无效</h4><pre><code>&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;
</code></pre><h4 id="写邮件，可参考《移动web页面给用户发送邮件的方法》"><a href="#写邮件，可参考《移动web页面给用户发送邮件的方法》" class="headerlink" title="写邮件，可参考《移动web页面给用户发送邮件的方法》"></a>写邮件，可参考《移动web页面给用户发送邮件的方法》</h4><pre><code>&lt;a href=&quot;mailto:peun@foxmail.com&quot;&gt;peun@foxmail.com&lt;/a&gt;
</code></pre><h4 id="模拟按钮hover效果"><a href="#模拟按钮hover效果" class="headerlink" title="模拟按钮hover效果"></a>模拟按钮hover效果</h4><p>移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下，<br></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;
&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;
&lt;style type=&quot;text/css&quot;&gt;
a{-webkit-tap-highlight-color: rgba(0,0,0,0);}
.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}
.btn-blue:active{background-color: #357AE8;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;btn-blue&quot;&gt;按钮&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
document.addEventListener(&quot;touchstart&quot;, function(){}, true)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>兼容性ios5+、部分android 4+、winphone 8<br><br>要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名<br></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;
&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;
&lt;style type=&quot;text/css&quot;&gt;
a{-webkit-tap-highlight-color: rgba(0,0,0,0);}
.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}
.btn-blue-on{background-color: #357AE8;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;btn-blue&quot;&gt;按钮&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
var btnBlue = document.querySelector(&quot;.btn-blue&quot;);
btnBlue.ontouchstart = function(){
this.className = &quot;btn-blue btn-blue-on&quot;
}
btnBlue.ontouchend = function(){
this.className = &quot;btn-blue&quot;
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="屏幕旋转的事件和样式"><a href="#屏幕旋转的事件和样式" class="headerlink" title="屏幕旋转的事件和样式"></a>屏幕旋转的事件和样式</h4><p><strong>事件</strong><br><br><strong>window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；</strong><br></p>
<pre><code>window.onorientationchange = function(){
switch(window.orientation){
case -90:
case 90:
alert(&quot;横屏:&quot; + window.orientation);
case 0:
case 180:
alert(&quot;竖屏:&quot; + window.orientation);
break;
}
}
</code></pre><p><strong>样式</strong><br></p>
<pre><code>//竖屏时使用的样式
@media all and (orientation:portrait) {
.css{}
}

//横屏时使用的样式
@media all and (orientation:landscape) {
.css{}
}
</code></pre><p><strong>audio元素和video元素在ios和andriod中无法自动播放</strong><br><br><strong>应对方案：触屏即播</strong><br></p>
<pre><code>$(&apos;html&apos;).one(&apos;touchstart&apos;,function(){
audio.play()
})
</code></pre><p>可参考《无法自动播放的audio元素》<br></p>
<h3 id="摇一摇功能"><a href="#摇一摇功能" class="headerlink" title="摇一摇功能"></a>摇一摇功能</h3><p>HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。<br><br><strong>手机拍照和上传图片</strong><br></p>
<pre><code>&lt;input type=”file”&gt;的accept 属性&lt;br&gt;
&lt;!-- 选择照片 --&gt;
&lt;input type=file accept=&quot;image/*&quot;&gt;
&lt;!-- 选择视频 --&gt;
&lt;input type=file accept=&quot;video/*&quot;&gt;
</code></pre><h4 id="使用总结："><a href="#使用总结：" class="headerlink" title="使用总结："></a>使用总结：</h4><p>ios 有拍照、录像、选取本地图片功能<br><br>部分android只有选取本地图片功能<br><br>winphone不支持<br><br>input控件默认外观丑陋<br><br>微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整<br><br><strong>原因</strong><br><br>android侧是复写了layoutinflater 对textview做了统一处理<br><br>ios侧是修改了body.style.webkitTextSizeAdjust值<br><br><strong>解决方案：</strong><br><br>android使用以下代码，该接口只在微信浏览器下有效(感谢jationhuang同学提供)<br></p>
<pre><code>/**
* 页面加入这段代码可使Android机器页面不再受到用户字体缩放强制改变大小
* 但是会有一个1秒左右的延迟，期间可以考虑通过loading展示
* 仅供参考
*/
(function(){
if (typeof(WeixinJSBridge) == &quot;undefined&quot;) {
document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) {
setTimeout(function(){
WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;,{&quot;fontSize&quot;:0}, function(res) {
alert(JSON.stringify(res));
});
},0);
});
} else {
setTimeout(function(){
WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;,{&quot;fontSize&quot;:0}, function(res) {
alert(JSON.stringify(res));
});
},0);
}
})();
</code></pre><p>ios使用-webkit-text-size-adjust禁止调整字体大小<br></p>
<pre><code>body{-webkit-text-size-adjust: 100%!important;}
</code></pre><p><strong>最好的解决方案：</strong><br><br>整个页面用rem或者百分比布局<br><br>消除transition闪屏<br><br>网络都是这么写的，但我并没有测试出来<br></p>
<pre><code>.css{
/*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/
-webkit-transform-style: preserve-3d;
/*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/
-webkit-backface-visibility: hidden;
}
</code></pre><h4 id="开启硬件加速"><a href="#开启硬件加速" class="headerlink" title="开启硬件加速"></a>开启硬件加速</h4><h4 id="解决页面闪白"><a href="#解决页面闪白" class="headerlink" title="解决页面闪白"></a>解决页面闪白</h4><h4 id="保证动画流畅"><a href="#保证动画流畅" class="headerlink" title="保证动画流畅"></a>保证动画流畅</h4><pre><code>.css {
-webkit-transform: translate3d(0, 0, 0);
-moz-transform: translate3d(0, 0, 0);
-ms-transform: translate3d(0, 0, 0);
transform: translate3d(0, 0, 0);
}
</code></pre><p><strong>参考《用CSS开启硬件加速来提高网站性能》</strong><br><br><strong>取消input在ios下，输入的时候英文首字母的默认大写</strong><br></p>
<pre><code>&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;
</code></pre><p><strong>android 上去掉语音输入按钮</strong><br></p>
<pre><code>input::-webkit-input-speech-button {display: none}
</code></pre><h3 id="android-2-3-bug"><a href="#android-2-3-bug" class="headerlink" title="android 2.3 bug"></a>android 2.3 bug</h3><p>1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉<br><br>2.after和before伪类无法使用动画animation<br><br>3.border-radius不支持%单位<br><br>4.translate百分比的写法和scale在一起会导致失效，例如-webkit-transform: translate(-50%,-50%) scale(-0.5, 1)<br></p>
<h3 id="android-4-x-bug"><a href="#android-4-x-bug" class="headerlink" title="android 4.x bug"></a>android 4.x bug</h3><p>1.三星 Galaxy S4中自带浏览器不支持border-radius缩写<br><br>2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分<br><br>3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色<br><br>4.android无法同时播放多音频audio<br><br><strong>参考《border-radius 移动之伤》</strong><br></p>
<h3 id="设计高性能css3动画的几个要素"><a href="#设计高性能css3动画的几个要素" class="headerlink" title="设计高性能css3动画的几个要素"></a>设计高性能css3动画的几个要素</h3><p>1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位<br><br>2.利用translate3D开启GPU加速<br><br>参考《High Performance Animations》<br></p>
<h4 id="fixed-bug"><a href="#fixed-bug" class="headerlink" title="fixed bug"></a>fixed bug</h4><p>1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位<br>2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位<br>3.ios4下不支持position:fixed</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>可用isroll.js，暂无完美方案<br><br>参考<br><br>《移动端web页面使用position:fixed问题总结》<br><br>《使用iScroll.js解决ios4下不支持position:fixed的问题》<br><br>如何阻止windows Phone的默认触摸事件<br><br>winphone下默认触摸事件事件使用e.preventDefault是无效的<br><br>目前解决方法是使用样式来禁用<br></p>
<pre><code>html{-ms-touch-action: none;}/* 禁止winphone默认触摸事件 */
</code></pre><p><strong>参考</strong><br><br>《Windows phone 8 touch support》<br></p>
<h4 id="播放视频不全屏"><a href="#播放视频不全屏" class="headerlink" title="播放视频不全屏"></a>播放视频不全屏</h4><pre><code>&lt;!--
1.ios7+支持自动播放
2.支持Airplay的设备（如：音箱、Apple TV)播放
x-webkit-airplay=&quot;true&quot;
3.播放视频不全屏
webkit-playsinline=&quot;true&quot;
--&gt;
&lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt;
</code></pre><h3 id="常用的移动端框架"><a href="#常用的移动端框架" class="headerlink" title="常用的移动端框架"></a>常用的移动端框架</h3><h4 id="zepto-js"><a href="#zepto-js" class="headerlink" title="zepto.js"></a>zepto.js</h4><p>语法与jquery几乎一样，会jquery基本会zepto~<br><br>最新版本已经更新到1.16<br><br>官网：<a href="http://zeptojs.com/" target="_blank" rel="external">http://zeptojs.com/</a><br><br>中文(非官网)：<a href="http://www.css88.com/doc/zeptojs_api/" target="_blank" rel="external">http://www.css88.com/doc/zeptojs_api/</a><br><br>常使用的扩展模块：<br><br>浏览器检测：<a href="https://github.com/madrobby/zepto/blob/master/src/detect.js" target="_blank" rel="external">https://github.com/madrobby/zepto/blob/master/src/detect.js</a><br><br>tap事件：<a href="https://github.com/madrobby/zepto/blob/master/src/touch.js" target="_blank" rel="external">https://github.com/madrobby/zepto/blob/master/src/touch.js</a><br></p>
<h4 id="iscroll-js"><a href="#iscroll-js" class="headerlink" title="iscroll.js"></a>iscroll.js</h4><p>解决页面不支持弹性滚动，不支持fixed引起的问题~<br><br>实现下拉刷新，滑屏，缩放等功能~<br><br>最新版本已经更新到5.0<br><br>官网：<a href="http://cubiq.org/iscroll-5" target="_blank" rel="external">http://cubiq.org/iscroll-5</a><br></p>
<h4 id="underscore-js"><a href="#underscore-js" class="headerlink" title="underscore.js"></a>underscore.js</h4><p>笔者没用过，不过听说好用，推荐给大家~<br><br>该库提供了一整套函数式编程的实用功能，但是没有扩展任何javascript内置对象。<br><br>最新版本已经更新到1.8.2<br><br>官网：<a href="http://underscorejs.org/" target="_blank" rel="external">http://underscorejs.org/</a><br></p>
<h4 id="滑屏框架"><a href="#滑屏框架" class="headerlink" title="滑屏框架"></a>滑屏框架</h4><p>适合上下滑屏、左右滑屏等滑屏切换页面的效果<br><br>slip.js<br><br>iSlider.js<br><br>fullpage.js<br></p>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flex布局目前可使用在移动中，并非所有的语法都全兼容，但以下写法笔者实践过，效果良好~<br></p>
<pre><code>/* ============================================================
flex：定义布局为盒模型
flex-v：盒模型垂直布局
flex-1：子元素占据剩余的空间
flex-align-center：子元素垂直居中
flex-pack-center：子元素水平居中
flex-pack-justify：子元素两端对齐
兼容性：ios 4+、android 2.3+、winphone8+
============================================================ */
.flex{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}
.flex-v{-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}
.flex-1{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;}
.flex-align-center{-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;}
.flex-pack-center{-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}
.flex-pack-justify{-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}
</code></pre><p>示例：两端对齐<br></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;
&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;
&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;
&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;
&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;
&lt;style type=&quot;text/css&quot;&gt;
/* ============================================================
flex：定义布局为盒模型
flex-v：盒模型垂直布局
flex-1：子元素占据剩余的空间
flex-align-center：子元素垂直居中
flex-pack-center：子元素水平居中
flex-pack-justify：子元素两端对齐
兼容性：ios 4+、android 2.3+、winphone8+
============================================================ */
.flex{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}
.flex-v{-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}
.flex-1{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;}
.flex-align-center{-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;}
.flex-pack-center{-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;}
.flex-pack-justify{-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;flex flex-pack-justify&quot;&gt;
&lt;div&gt;模块一&lt;/div&gt;
&lt;div&gt;模块二&lt;/div&gt;
&lt;div&gt;模块三&lt;/div&gt;
&lt;div&gt;模块四&lt;/div&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>使用注意：flex下的子元素必须为块级元素，非块级元素在android2.3机器下flex失效<br><br>参考：<br><br>flexyboxes<br><br>“老”的Flexbox和“新”的Flexbox<br><br>跨浏览器的Flexbox<br></p>
<h4 id="FastClick"><a href="#FastClick" class="headerlink" title="FastClick"></a>FastClick</h4><p>消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300延迟<br><br>参考《FastClick》<br><br>转载：<a href="http://peunzhang.cnblogs.com/" target="_blank" rel="external">http://peunzhang.cnblogs.com/</a><br><br>原文链接：<a href="http://caibaojian.com/mobile-knowledge.html" target="_blank" rel="external">移动前端知识总结</a><br>转自：前端开发博客 <a href="http://caibaojian.com/mobile-knowledge.html" target="_blank" rel="external">http://caibaojian.com/mobile-knowledge.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/15/21/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/15/21/" itemprop="url">
                  利用Gulp优化部署Web项目👗
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-15T20:11:09+08:00">
                2016-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a>是一款项目自动化的构建工具，与<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>一样可以通过创建任务（Task）来帮助我们自动完成一些工作流的内容。当然，今天我们的内容并不是讨论这二者的区别，仅仅是介绍介绍如何利用Gulp来优化我们的Web项目中前端自动化工作流。<br></p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>相信不少人看过百度大牛<a href="https://github.com/fouber" target="_blank" rel="external">张云龙</a>的那篇讲解<a href="https://github.com/fouber/blog/issues/6" target="_blank" rel="external">大公司里怎样开发和部署前端代码?</a>的文章，如果没有阅读的朋友请戳。由于在项目部署时，我们需要对项目js，css,image等文件进行压缩，合并处理，从而减少客户端对服务Http请求，已达到增强页面的加载速度，优化服务器带宽压力等等目的。所以本文主要讲的是利用Gulp优化我们Web部署优化工作。<br></p>
<h4 id="安装-amp-初始化"><a href="#安装-amp-初始化" class="headerlink" title="安装&amp;初始化"></a>安装&amp;初始化</h4><p>首先你得确保你的电脑上面是否已经安装了Nodejs, 如果没有安装的话，那么请<a href="https://nodejs.org/en/" target="_blank" rel="external">移步</a>。假定有如下一个Nodejs的Web项目（当然你也可以是其他的例如Java，.Net的Web项目，且具体开发目录如下：<br></p>
<pre><code>|- project
|- src // 前端项目的源文件
    |- js 
    |- html
    |- images
    |- css
    |- bower_component // bower 前端依赖包管理
    |- node_component // nodejs 插件
|- server
    |- api
    |- views
        |- app
    |- assets // 前端静态文件存放目录
        |- js
        |- css
        |- images
        |- templates
    |- ... // 其他目录就不一一列出了
</code></pre><p><code>src</code>文件夹为前端的<code>js</code>，<code>css</code>, <code>html</code>, <code>image</code>的开发目录, 我们会通过<code>gulp</code>将这些源文件进行压缩合并后打包到目标目录，也就是<code>assets</code>目录下相应的<code>js</code>,<code>css</code>目录，<code>html</code>视图文件会打包到<code>views</code>下的<code>app</code>文件夹和<code>assets</code>下的<code>templates</code>模板文件夹，具体视情况而定。其中的<code>bower_component</code>为<a href="https://bower.io/" target="_blank" rel="external">bower</a>前端包管理，我们可以用<code>bower</code>直接下载几乎任何我们前端日常所需的库，框架,而且可以任选版本，例如<code>JQuery</code>,<code>Bootstrap</code>,<code>Angular</code>，只需执行<code>bower install packageName</code>即可，不同版本只需<code>bower install packageName#version</code>,更多内容，可以去<a href="https://bower.io/" target="_blank" rel="external">官网</a>自行查阅，这里就不展开了。至于node_component 文件夹即是用npm安装的我们打包会用到的插件资源了。<br></p>
<h5 id="1-全局安装Gulp"><a href="#1-全局安装Gulp" class="headerlink" title="1.全局安装Gulp"></a>1.全局安装Gulp</h5><pre><code>$ npm install --global gulp
</code></pre><h5 id="2-安装Gulp到开发项目中"><a href="#2-安装Gulp到开发项目中" class="headerlink" title="2.安装Gulp到开发项目中"></a>2.安装Gulp到开发项目中</h5><pre><code>$ npm install --save-dev gulp
</code></pre><h5 id="3-在src创建gulpfile-js文件，这个文件用来配置我们所需的task-接下来会具体讲解。"><a href="#3-在src创建gulpfile-js文件，这个文件用来配置我们所需的task-接下来会具体讲解。" class="headerlink" title="3.在src创建gulpfile.js文件，这个文件用来配置我们所需的task,接下来会具体讲解。"></a>3.在<code>src</code>创建<code>gulpfile.js</code>文件，这个文件用来配置我们所需的<code>task</code>,接下来会具体讲解。</h5><h5 id="4-执行"><a href="#4-执行" class="headerlink" title="4.执行"></a>4.执行</h5><pre><code>$ gulp 
或者
$ gulp taskName
</code></pre><p>gulp会执行gulpfile.js文件下定义的default任务，如果我们需要执行特定的task，则需要执行下面的命令<br></p>
<h4 id="gulpfile-js文件"><a href="#gulpfile-js文件" class="headerlink" title="gulpfile.js文件"></a>gulpfile.js文件</h4><p><code>gulpfile.js</code>用来定义我们需要自动化的任务，里面包含了很多依赖关系。这里我们会创建4个<code>Task</code>，第一个<code>develop task</code>,用于开发时使用，另一个<code>release task</code>,用于部署发布时用的，还有一个<code>watch task</code>, 用于实时监听文件修改行为，可及时打包，最后一个<code>default task</code>, <code>gulp</code>默认执行的<code>task</code>.<br></p>
<h4 id="创建Default-Task"><a href="#创建Default-Task" class="headerlink" title="创建Default Task"></a>创建Default Task</h4><pre><code> var gulp = require(&apos;gulp&apos;);

gulp.task(&apos;default&apos;, function() {
  // place code for your default task here
});

// 如果默认情况下我们会执行一个叫develop的task，则这么写，执行gulp命令时，
// 会自动调用develop
gulp.task(&apos;default&apos;, [&apos;develop&apos;]);
</code></pre><h4 id="创建Develop-Task"><a href="#创建Develop-Task" class="headerlink" title="创建Develop Task"></a>创建Develop Task</h4><h4 id="创建develop-task前，先介绍下我们今天要用到的一些插件"><a href="#创建develop-task前，先介绍下我们今天要用到的一些插件" class="headerlink" title="创建develop task前，先介绍下我们今天要用到的一些插件"></a>创建develop task前，先介绍下我们今天要用到的一些插件</h4><p>1.<a href="https://github.com/terinjokes/gulp-uglify" target="_blank" rel="external">gulp-uglify</a> Js压缩插件<br><br>2.<a href="https://github.com/jonathanepollack/gulp-minify-css" target="_blank" rel="external">gulp-minify-css</a> Css压缩插件<br><br>3.<a href="https://github.com/sindresorhus/gulp-imagemin" target="_blank" rel="external">gulp-imagemin</a>图片压缩插件，支持格式： PNG, JPEG, GIF and SVG images<br><br>4.<a href="https://github.com/sindresorhus/gulp-strip-debug" target="_blank" rel="external">gulp-strip-debug</a>清除源文件console,debugger代码<br><br>5.<a href="https://github.com/jonkemp/gulp-useref" target="_blank" rel="external">gulp-useref</a>合并压缩html文件中的文件<br><br>以上列出的插件为我个人常用的一些插件，如果你还有fonts文件的话，也可以添加进去，gulp有很多其他或者相似的插件，都可以去google搜索。安装方法则是正常的npm安装，可以戳进官网去查看。<br><br><strong>首先我们需要为我们要压缩的源文件配置路径以及导入插件，假设我们bower里面已有jquery和bootstrap插件，以及其他源文件目录，如下：</strong><br></p>
<pre><code>// 引入插件
var uglify = require(&apos;gulp-uglify&apos;); // 压缩
var minifyCss = require(&apos;gulp-minify-css&apos;);
var stripDebug = require(&apos;gulp-strip-debug&apos;); // 该插件用来去掉console和debugger语句
var useref = require(&apos;gulp-useref&apos;);
var imagemin = require(&apos;gulp-imagemin&apos;);
var pngquant = require(&apos;imagemin-pngquant&apos;);

// 任务处理的文件路径配置
var paths = {
    js: [ // js目录
        &apos;app/*&apos;
    ],
    css: [
         &apos;css/*&apos;
    ],
    img: [
         &apos;images/*&apos;
    ],
    html: [
        &apos;html/*&apos;
    ],
    lib: { // 第三方依赖文件
        js: [
            &apos;bower_components/bootstrap/dist/js/bootstrap.js&apos;,
            &apos;bower_components/jquery/jquery.js&apos;
        ],
        css: [
            &apos;bower_components/bootstrap/dist/css/bootstrap.css&apos;
        ],
        img: [
            &apos;bower_components/bootstrap/dist/images/*&apos;
        ]
    }
};
</code></pre><p><strong>定义develop task</strong></p>
<pre><code>var output = &quot;../server/assets/&quot;; // output 

/* 开发环境 */
gulp.task(&apos;develop&apos;, function() {
gulp.src(paths.js)
    .pipe(gulp.dest(output + &apos;/js&apos;));

gulp.src(paths.lib.js)
    .pipe(gulp.dest(output + &apos;/js&apos;));

gulp.src(paths.css)
    .pipe(gulp.dest(output + &apos;/css&apos;));

gulp.src(paths.lib.css)
    .pipe(gulp.dest(output + &apos;/css&apos;));

gulp.src(paths.img)
    .pipe(gulp.dest(output + &apos;/images&apos;)); 

gulp.src(paths.lib.img)
    .pipe(gulp.dest(output + &apos;/images&apos;));
});
</code></pre><p>上面的<strong>develop task</strong>直接将代码都输出到了我们的<strong>server</strong>目录下，并未通过插件进行相应的处理，主要是因为我们等会还会创建<strong>release task</strong>， 当真正部署的时候我们才进行压缩合并这些处理。<br><br><strong>定义release task</strong></p>
<pre><code>/* 部署环境 */
    gulp.task(&apos;release&apos;, function() {
gulp.src(paths.js)
    .pipe(stripDebug())
    .pipe(gulp.dest(output + &apos;/js&apos;));

gulp.src(paths.lib.js)
    .pipe(stripDebug())
    .pipe(gulp.dest(output + &apos;/js&apos;));

gulp.src(paths.css)
    .pipe(gulp.dest(output + &apos;/css&apos;));

gulp.src(paths.lib.css)
    .pipe(gulp.dest(output + &apos;/css&apos;));

gulp.src(paths.img)
    .pipe(imagemin({
        progressive: true,
        svgoPlugins: [{removeViewBox: false}],
        use: [pngquant()]
    }))
    .pipe(gulp.dest(output + &apos;/images&apos;)); 

gulp.src(paths.lib.img)
     .pipe(imagemin({
        progressive: true,
        svgoPlugins: [{removeViewBox: false}],
        use: [pngquant()]
    }))
    .pipe(gulp.dest(output + &apos;/images&apos;));

var assets = useref.assets();
gulp.src(paths.html)
 .pipe(assets)
    .pipe(gulpif(&apos;*.js&apos;, uglify()))
    .pipe(gulpif(&apos;*.css&apos;, minifyCss()))
    .pipe(assets.restore())
    .pipe(useref())
    .pipe(gulp.dest(output + &apos;/templates&apos;));
});
</code></pre><p>上面的代码首先是先打包静态文件到指定包，去掉多余的console,debugger,给图片文件进行压缩处理，最后利用useref插件对ejs视图文件中的js,css进行压缩合并处理，并打包到指定目录。<br><br>利用<code>useref</code>对<code>html</code>内部的文件进行压缩合并<br><br>上面的<code>release</code>中我们以及定义了对<code>app</code>目录下<code>html</code>文件内部的<code>js</code>，<code>css</code>进行压缩何必，仅仅配置<code>task</code>是还不够的，我还需要在html内部做如下配置：<br></p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;!-- build:css css/main.css --&gt;
    &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;link href=&quot;css/bootstrap.cs.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;!-- endbuild --&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- build:js scripts/main.js --&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;!-- endbuild --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>经过合并后的文件：<br></p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/htm&gt;
</code></pre><p>更多关于<a href="https://github.com/jonkemp/gulp-useref" target="_blank" rel="external">gulp-useref</a>的使用方法<a href="https://github.com/jonkemp/gulp-useref" target="_blank" rel="external">请戳</a>。<br><br><strong>定义watch Task</strong><br><code>watch task</code> 是为了监听文件发生改变后立即触发的任务，已便于我们开发。代码如下：<br></p>
<pre><code>var watcher = gulp.watch(paths.scripts, [&apos;develop&apos;]);
watcher.on(&apos;change&apos;, function (event) {
   console.log(&apos;Event type: &apos; + event.type); // added, changed, or deleted
   console.log(&apos;Event path: &apos; + event.path); // The path of the modified file
});
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上基本介绍了如何使用gulp来自动完成打包，压缩，合并文件等任务，Gulp插件非常多，本文只是简单的介绍了几种基本的。总之，使用gulp，只需要几行命令便可以完成以上任务，使很多优化工作变得十分简单。<br></p>
<ul>
<li>原文地址：<a href="http://imziv.com/blog/article/read.htm?id=60" target="_blank" rel="external">http://imziv.com/blog/article/read.htm?id=60</a></li>
<li>作者： <a href="http://imziv.com/blog/article/index.htm" target="_blank" rel="external">Ziv小威</a></li>
</ul>
<p>转自：<a href="http://www.imziv.com/blog/article/read.htm?id=60" target="_blank" rel="external">http://www.imziv.com/blog/article/read.htm?id=60</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/11/20/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/11/20/" itemprop="url">
                  回味js基础:call/bind🍕
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-11T23:06:27+08:00">
                2016-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JavaScript中，<code>call</code>、<code>apply</code>和<code>bind</code>是<code>Function</code>对象自带的三个方法，本文将通过几个场景的应用，来详细理解三个方法。<br></p>
<h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p><code>call()</code> 方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<p>当调用一个函数时，可以赋值一个不同的 <code>this</code> 对象。<code>this</code> 引用当前对象，即<code>call</code>方法的第一个参数。<br><br>通过 <code>call</code> 方法，你可以在一个对象上借用另一个对象上的方法，比如<code>Object.prototype.toString.call([])</code>，就是一个<code>Array</code>对象借用了<code>Object</code>对象上的方法。<br></p>
<pre><code>语法 fun.call(thisArg[, arg1[, arg2[, ...]]])
</code></pre><h5 id="thisArg"><a href="#thisArg" class="headerlink" title="thisArg"></a>thisArg</h5><p>在fun函数运行时指定的<code>this</code>值。需要注意的是下面几种情况<br><br>（1）不传，或者传<code>null</code>，<code>undefined</code>， 函数中的<code>this</code>指向window对象<br><br>（2）传递另一个函数的函数名，函数中的<code>this</code>指向这个函数的引用，并不一定是该函数执行时真正的<code>this</code>值<br><br>（3）值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动包装对象，如 <code>String</code>、<code>Number</code>、<code>Boolean</code><br><br>（4）传递一个对象，函数中的this指向这个对象<br></p>
<h5 id="arg1-arg2-…"><a href="#arg1-arg2-…" class="headerlink" title="arg1, arg2, …"></a>arg1, arg2, …</h5><p>指定的参数列表。<br><br><strong>例子</strong><br><strong>初级应用例子</strong></p>
<pre><code>function a(){
//输出函数a中的this对象
    console.log(this); 
}
//定义函数b
function b(){} 

var obj = {name:&apos;这是一个屌丝&apos;}; //定义对象obj
a.call(); //window
a.call(null); //window
a.call(undefined);//window
a.call(1); //Number
a.call(&apos;&apos;); //String
a.call(true); //Boolean
a.call(b);// function b(){}
a.call(obj); //Object
</code></pre><p><strong>使用call方法调用匿名函数并且指定上下文的<code>this</code></strong><br>在下面的例子中，当调用 <code>greet</code> 方法的时候，该方法的 <code>this</code> 值会绑定到 <code>i</code>对象。<br></p>
<pre><code>function greet() {
  var reply = [this.person, &apos;是一个轻量的&apos;, this.role].join(&apos; &apos;);
  console.log(reply);
}

var i = {
  person: &apos;JSLite.io&apos;, role: &apos;Javascript 库。&apos;
};

greet.call(i); 
// JSLite.io 是一个轻量的 Javascript 库。
</code></pre><h5 id="使用call方法调用匿名函数"><a href="#使用call方法调用匿名函数" class="headerlink" title="使用call方法调用匿名函数"></a>使用call方法调用匿名函数</h5><p>在下例中的<code>for</code>循环体内，我们创建了一个匿名函数，然后通过调用该函数的<code>call</code>方法，将每个数组元素作为指定的<code>this</code>值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个<code>print</code>方法，这个<code>print</code>方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为<code>this</code>值传入那个匿名函数（普通参数就可以），目的是为了演示<code>call</code>的用法。<br></p>
<pre><code>var animals = [
  {species: &apos;Lion&apos;, name: &apos;King&apos;},
  {species: &apos;Whale&apos;, name: &apos;Fail&apos;}
];

for (var i = 0; i &lt; animals.length; i++) {
  (function (i) { 
    this.print = function () { 
      console.log(&apos;#&apos; + i  + &apos; &apos; + this.species + &apos;: &apos; + this.name); 
    } 
    this.print();
  }).call(animals[i], i);
}
//#0 Lion: King
//#1 Whale: Fail
</code></pre><h5 id="使用call方法调用函数传参数"><a href="#使用call方法调用函数传参数" class="headerlink" title="使用call方法调用函数传参数"></a>使用call方法调用函数传参数</h5><pre><code>var a = {
name:&apos;JSLite.io&apos;, //定义a的属性
say:function(){ //定义a的方法
        console.log(&quot;Hi,I&apos;m function a!&quot;);
    }
};
function b(name){
    console.log(&quot;Post params: &quot;+ name);
    console.log(&quot;I&apos;m &quot;+ this.name);
    this.say();
}

b.call(a,&apos;test&apos;);
//Post params: test
//I&apos;m JSLite.io
//I&apos;m function a!
</code></pre><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>语法与 <code>call()</code> 方法的语法几乎完全相同，唯一的区别在于，<code>apply</code>的第二个参数必须是一个包含多个参数的数组（或类数组对象）。<code>apply</code>的这个特性很重要，<br><br>在调用一个存在的函数时，你可以为其指定一个 <code>this</code>对象。 <code>this</code> 指当前对象，也就是正在调用这个函数的对象。 使用 <code>apply</code>， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。<br></p>
<pre><code>语法：fun.apply(thisArg[, argsArray])
</code></pre><p>注意: 需要注意：<code>Chrome 14</code> 以及 <code>Internet Explorer 9</code> 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。<br></p>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p><strong>thisArg</strong><br><br>同上<code>call</code> 的<code>thisArg</code>参数。<br><br><strong>argsArray</strong><br><br>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>fun</code> 函数。如果该参数的值为<code>null</code> 或 <code>undefined</code>，则表示不需要传入任何参数。从<code>ECMAScript 5</code> 开始可以使用类数组对象。<br><br><strong>例子</strong><br></p>
<pre><code>function jsy(x,y,z){
console.log(x,y,z);
}

jsy.apply(null,[1,2,3]); 
// 1 2 3
</code></pre><p><strong>使用apply来链接构造器的例子</strong><br><br>你可以使用<code>apply</code>来给一个对象链接构造器，类似于<code>Java</code>. 在接下来的例子中我们会创建一个叫做<code>construct</code>的全局的<code>Function</code>函数,来使你能够在构造器中使用一个类数组对象而非参数列表。<br></p>
<pre><code>Function.prototype.construct = function(aArgs) {
  var fConstructor = this, 
  fNewConstr = function() { 
    fConstructor.apply(this, aArgs); 
  };
  fNewConstr.prototype = fConstructor.prototype;
  return new fNewConstr();
};
function MyConstructor () {
    for (var nProp = 0; nProp &lt; arguments.length; nProp++) {
        console.log(arguments,this)
        this[&quot;property&quot; + nProp] = arguments[nProp];
    }
}
var myArray = [4, &quot;Hello world!&quot;, false];
var myInstance = MyConstructor.construct(myArray);

console.log(myInstance.property1);                // logs &quot;Hello world!&quot;
console.log(myInstance instanceof MyConstructor); // logs &quot;true&quot;
console.log(myInstance.constructor);              // logs &quot;MyConstructor&quot;
</code></pre><p><strong>使用apply和内置函数</strong><br><br>聪明的apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。在接下里的例子中我们会使用<code>Math.max</code>/<code>Math.min</code>来找出一个数组中的最大/最小值。<br></p>
<pre><code>//里面有最大最小数字值的一个数组对象
var numbers = [5, 6, 2, 3, 7];

/* 使用 Math.min/Math.max 在 apply 中应用 */
var max = Math.max.apply(null, numbers);
// 一般情况是用 Math.max(5, 6, ..) 或者 Math.max(numbers[0], ...) 来找最大值
var min = Math.min.apply(null, numbers);

//通常情况我们会这样来找到数字的最大或者最小值
//比对上面的栗子，是不是下面的看起来没有上面的舒服呢？
max = -Infinity, min = +Infinity;
for (var i = 0; i &lt; numbers.length; i++) {
  if (numbers[i] &gt; max)
    max = numbers[i];
  if (numbers[i] &lt; min) 
    min = numbers[i];
}
</code></pre><p><strong>参数数组切块后循环传入</strong><br></p>
<pre><code>function minOfArray(arr) {
  var min = Infinity;
  var QUANTUM = 32768;

  for (var i = 0, len = arr.length; i &lt; len; i += QUANTUM) {
    var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));
    console.log(submin, min)
    min = Math.min(submin, min);
  }

  return min;
}

var min = minOfArray([5, 6, 2, 3, 7]);
</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind() 函数会创建一个新函数（称为绑定函数）<br><br>1.bind() 函数会创建一个新函数（称为绑定函数）<br><br>2.传参和call或apply类似<br><br>3.不会执行对应的函数，call或apply会自动执行对应的函数<br><br>4.返回对函数的引用<br></p>
<pre><code>语法 fun.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre><p>下面例子：当点击网页时，<code>EventClic</code>k被触发执行，输出<code>JSLite.io p1 p2</code>, 说明E<code>ventClick中</code>的<code>this</code>被<code>bind</code>改变成了<code>obj</code>对象。如果你将<code>EventClick.bind(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 变成 <code>EventClick.call(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 的话，页面会直接输出 <code>JSLite.io p1 p2</code><br></p>
<pre><code>var obj = {name:&apos;JSLite.io&apos;};
/**
 * 给document添加click事件监听，并绑定EventClick函数
 * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2
 */
document.addEventListener(&apos;click&apos;,EventClick.bind(obj,&apos;p1&apos;,&apos;p2&apos;),false);
//当点击网页时触发并执行
function EventClick(a,b){
    console.log(
            this.name, //JSLite.io
            a, //p1
            b  //p2
    )
}
</code></pre><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><pre><code>if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== &quot;function&quot;) {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }

    var aArgs = Array.prototype.slice.call(arguments, 1), 
        fToBind = this, // this在这里指向的是目标函数
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply(this instanceof fNOP
                 ? this //此时的this就是new出的obj
                 : oThis || this,//如果传递的oThis无效，就将fBound的调用者作为this

               //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递
               aArgs.concat(Array.prototype.slice.call(arguments)));
        };
    fNOP.prototype = this.prototype;
    //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用
    fBound.prototype = new fNOP();
    //返回fBond的引用，由外部按需调用
    return fBound;
  };
}
</code></pre><p>兼容例子来源于：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility</a><br></p>
<h3 id="应用场景：继承"><a href="#应用场景：继承" class="headerlink" title="应用场景：继承"></a>应用场景：继承</h3><pre><code>function Animal(name,weight){
   this.name = name;
   this.weight = weight;
}
function Cat(){
    // 在call中将this作为thisArgs参数传递
    // Animal方法中的this就指向了Cat中的this
    // 所以Animal中的this指向的就是cat对象
    // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性
    // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的
    Animal.call(this,&apos;cat&apos;,&apos;50&apos;);
    //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]);
    this.say = function(){
       console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight);
    }
}
//当通过new运算符产生了cat时，Cat中的this就指向了cat对象
var cat = new Cat();
cat.say();
//输出=&gt; I am cat,my weight is 50
</code></pre><h3 id="原型扩展"><a href="#原型扩展" class="headerlink" title="原型扩展"></a>原型扩展</h3><p>在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 <code>forEach</code><br></p>
<pre><code>function test(){
// 检测arguments是否为Array的实例
console.log(
    arguments instanceof Array, //false
    Array.isArray(arguments)  //false
);
// 判断arguments是否有forEach方法
console.log(arguments.forEach); 
// undefined
// 将数组中的forEach应用到arguments上
Array.prototype.forEach.call(arguments,function(item){
    console.log(item); // 1 2 3 4
});
}
test(1,2,3,4);
</code></pre><p>转自：<a href="http://gold.xitu.io/post/57dc97f35bbb50005e5b39bd" target="_blank" rel="external">http://gold.xitu.io/post/57dc97f35bbb50005e5b39bd</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/08/19/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/08/19/" itemprop="url">
                  不得不学的js技巧之关键字this🍭
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-08T22:02:24+08:00">
                2016-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript的初学者，很容易迷惑于函数中的this关键字，本文简明扼要地说明了this的含义，包你读后不再迷惑。<br><br><strong>一句话解决疑问：函数中的this代表一个对象，具体是哪个对象取决于函数的调用方式。</strong><br><br>好的，现在问题变成了这样：函数有几种调用方式？每种调用方式中this代表哪个对象？<br></p>
<h3 id="调用方式一：直接调用"><a href="#调用方式一：直接调用" class="headerlink" title="调用方式一：直接调用"></a>调用方式一：直接调用</h3><p>设有如下函数：<br></p>
<pre><code>function setName(name) {
  this.name = name;

}
</code></pre><p>我们现在直接调用它：<br></p>
<pre><code>setName(&apos;milter&apos;);  
</code></pre><p>这时，函数setName中的this代表的是一个全局对象，这个对象是代码的宿主环境提供的，比如在浏览器中是window对象，在node.js中是global对象，如果宿主环境中没有提供这个全局对象，那么直接调用函数setName将会报错！<br></p>
<h3 id="调用方式二：new-调用"><a href="#调用方式二：new-调用" class="headerlink" title="调用方式二：new 调用"></a>调用方式二：new 调用</h3><p>还以上面的setName函数为例，new 调用是指这样： <code>new setName(&#39;milter&#39;)</code>; 本人之前的文章讲过，对函数进行new 调用时，解释器会创建一个新的对象，this就指向这个新的对象，函数最后也会返回这个新的对象。<br></p>
<h3 id="调用方式三：引用调用"><a href="#调用方式三：引用调用" class="headerlink" title="调用方式三：引用调用"></a>调用方式三：引用调用</h3><p>假设有这样一个对象： <code>var person = { }</code> 我们将函数setName赋值给person的一个属性，如下： <code>person.setName = setName</code> ; 此时，通过person.setName调用函数就是引用调用，如下：<br></p>
<pre><code>person.setName(&apos;milter&apos;);
</code></pre><p>引用调用函数时，this指向引用所属的对象，在上面的例子中，就是setName属性所属的对象person。<br></p>
<h3 id="调用方式四：call和apply调用"><a href="#调用方式四：call和apply调用" class="headerlink" title="调用方式四：call和apply调用"></a>调用方式四：call和apply调用</h3><p>先说call调用，接着上面的例子，如下：<br></p>
<pre><code>setName.call(person,&apos;milter&apos;);
</code></pre><p>call调用中，call的第一个参数就是this代表的对象，后面的参数代表传给函数的参数，上面的例子中，this指向person对象，setName函数的参数是字符串’milter’。 apply调用与call调用类似，第一个参数代表this对象，不同的是它用数组包含传给函数的参数。<br></p>
<h3 id="调用方式五：bind调用"><a href="#调用方式五：bind调用" class="headerlink" title="调用方式五：bind调用"></a>调用方式五：bind调用</h3><p>所谓bind调用，请看示例： <code>var binded = setName.bind(person); binded(&#39;milter&#39;)</code>; 在上面的binded调用中，this指向绑定的person对象。<br><br>好了，基本就这五种函数调用方式，如果有遗漏的，欢迎补充。<br></p>
<p>转自：<a href="http://gold.xitu.io/post/57e48c0075c4cd2d9f3485f1" target="_blank" rel="external">http://gold.xitu.io/post/57e48c0075c4cd2d9f3485f1</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="menggeNIU" />
          <p class="site-author-name" itemprop="name">menggeNIU</p>
          <p class="site-description motion-element" itemprop="description">个人收藏</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">menggeNIU</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
