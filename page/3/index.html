<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="个人收藏">
<meta property="og:type" content="website">
<meta property="og:title" content="NNNの博客">
<meta property="og:url" content="https://menggeniu.github.io/page/3/index.html">
<meta property="og:site_name" content="NNNの博客">
<meta property="og:description" content="个人收藏">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NNNの博客">
<meta name="twitter:description" content="个人收藏">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://menggeniu.github.io/page/3/"/>

  <title> NNNの博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">NNNの博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">前端小菜鸟</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/05/18/" itemprop="url">
                  免费实用的API接口🌳
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-05T22:42:56+08:00" content="2016-04-05">
              2016-04-05
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://pic2.zhimg.com/113b92948f1dae563a31cc289dbae239_b.png" alt=""><br><br>早晨很安静，所以每次都喜欢在早晨整理整理资料，中午太困，晚上太浮躁，而我不喜欢熬夜。是不是有人会笑话：做一个程序员怎么能不会熬夜？<br><br><strong>如果你想学习编程，但是找不到学习路径和资源，欢迎关注专栏：<a href="https://zhuanlan.zhihu.com/passer" target="_blank" rel="external">学习编程</a></strong><br><br>今天的内容，很适合你去做一些好玩、实用的东西出来。<br><br>先来科普个概念，开放应用程序的API（即Application Program Interface，应用程序接口）可以让开发者在无需访问源码，或理解内部工作机制细节的情况下，调用他人共享的功能和资源。对于数据源的获取上API是个好伙伴。<br><br>所以有了这些内容，本文分为两个部分，第一部分是平台的接口汇总，第二部分是非常实用的单个的接口汇总。<br></p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="1、聚合数据（API数据接口-开发者数据定制）"><a href="#1、聚合数据（API数据接口-开发者数据定制）" class="headerlink" title="1、聚合数据（API数据接口_开发者数据定制）"></a>1、聚合数据（<a href="https://link.zhihu.com/?target=https%3A//www.juhe.cn/" target="_blank" rel="external">API数据接口_开发者数据定制</a>）</h4><p><img src="https://pic2.zhimg.com/3bb6c5e333d01efe03749842cf7ca8d5_b.png" alt=""><br></p>
<h4 id="2、百度API-Store（API集市-APIStore）"><a href="#2、百度API-Store（API集市-APIStore）" class="headerlink" title="2、百度API Store（API集市_APIStore）"></a>2、百度API Store（<a href="https://link.zhihu.com/?target=http%3A//apistore.baidu.com/astore/classificationservicelist.html" target="_blank" rel="external">API集市_APIStore</a>）</h4><p><img src="https://pic3.zhimg.com/7f62f439d2ee6e041182459c6be44d26_b.png" alt=""><br></p>
<h4 id="2、webxml（确实不错）-WebXml-WEB服务"><a href="#2、webxml（确实不错）-WebXml-WEB服务" class="headerlink" title="2、webxml（确实不错）[WebXml | WEB服务"></a>2、webxml（确实不错）[WebXml | WEB服务</h4><p><img src="https://pic3.zhimg.com/4329ee05341cac7e788bbb2f993eb53e_b.png" alt=""><br></p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><h4 id="1、地图接口"><a href="#1、地图接口" class="headerlink" title="1、地图接口"></a>1、地图接口</h4><p>阿里云根据经纬度获取地区名接口：<br><br><a href="http://gc.ditu.aliyun.com/regeocoding?l=39.938133,116.395739&amp;type=001" target="_blank" rel="external">http://gc.ditu.aliyun.com/reg</a><br><br>阿里云根据地区名获取经纬度接口：<br><br><a href="http://gc.ditu.aliyun.com/geocoding?a=" target="_blank" rel="external">http://gc.ditu.aliyun.com/geoc</a>苏州市<br><br>参数解释: 纬度,经度type 001 (100代表道路，010代表POI，001代表门址，111可以同时显示前三项)<br></p>
<h4 id="2、查ip接口"><a href="#2、查ip接口" class="headerlink" title="2、查ip接口"></a>2、查ip接口</h4><p>太平洋接口<br><br><a href="http://whois.pconline.com.cn/?ip=117.89.35.98" target="_blank" rel="external">太平洋网络IP地址查询Web接口</a><br><br>淘宝接口<br><br><a href="http://ip.taobao.com/service/getIpInfo.php?ip=117.89.35.58" target="_blank" rel="external">http://ip.taobao.com/service/g</a><br><br>新浪接口<br><br><a href="http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=117.89.35.58" target="_blank" rel="external">http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=117.89.35.58</a><br></p>
<h4 id="3、电商接口"><a href="#3、电商接口" class="headerlink" title="3、电商接口"></a>3、电商接口</h4><p>京东 商品接口<br><br><a href="http://p.3.cn/prices/mgets?skuIds=J_" target="_blank" rel="external">http://p.3.cn/prices/mgets?…</a>商品ID&amp;type=1<br></p>
<h4 id="4、音乐接口"><a href="#4、音乐接口" class="headerlink" title="4、音乐接口"></a>4、音乐接口</h4><p>豆瓣音乐　<a href="https://www.douban.com/j/app/radio/channels" target="_blank" rel="external">http://www.douban.com/j/app/radio/</a><br><br>百度音乐  <a href="http://play.baidu.com/x?op=12&amp;count=1&amp;title=" target="_blank" rel="external">http://box.zhangmen.baidu.com/…</a>歌名$$歌<br><br>虾米    <a href="http://www.xiami.com/error/error" target="_blank" rel="external">http://kuang.xiami.com/app/nin…</a>歌曲名称/diandian/1/page/歌曲当前页?_=当前毫秒&amp;callback=getXiamiData<br><br>QQ空间音乐 <a href="http://qzone-music.qq.com/fcg-bin/cgi_playlist_xml.fcg?uin=QQ" target="_blank" rel="external">　http://qzone-music.qq.com/fcg-…</a>号码&amp;json=1&amp;g_tk=1916754934<br><br>多米音乐 <a href="http://v5.pc.duomi.com/search-ajaxsearch-searchall?kw=" target="_blank" rel="external">http://v5.pc.duomi.com/search-</a>关键字&amp;pi=页码&amp;pz=每页音乐数<br></p>
<h4 id="5、翻译、词典接口"><a href="#5、翻译、词典接口" class="headerlink" title="5、翻译、词典接口"></a>5、翻译、词典接口</h4><p>腾讯：<br><br><a href="http://dict.qq.com/dict?q=" target="_blank" rel="external">http://dict.qq.com/dict?…</a>词语<br><br>有道翻译：<br><br><a href="http://fanyi.youdao.com/openapi" target="_blank" rel="external">有道翻译API</a><br><br>爱词霸：<br><br><a href="http://dict-co.iciba.com/search.php?word=%E5%93%88%E5%93%88&amp;submit=%E6%9F%A5%E8%AF%A2" target="_blank" rel="external">http://dict-co.iciba.com/search.php?word=词语&amp;submit=提交</a><br></p>
<h4 id="6、酒店住宿接口"><a href="#6、酒店住宿接口" class="headerlink" title="6、酒店住宿接口"></a>6、酒店住宿接口</h4><p><a href="http://open.zhuna.cn/" target="_blank" rel="external">住哪网开放平台</a><br></p>
<h4 id="7、腾讯qq相关的接口"><a href="#7、腾讯qq相关的接口" class="headerlink" title="7、腾讯qq相关的接口"></a>7、腾讯qq相关的接口</h4><p><a href="http://wiki.open.qq.com/wiki/API%E6%96%87%E6%A1%A3" target="_blank" rel="external">API列表 - 腾讯开放平台</a><br></p>
<h4 id="8、物流接口"><a href="#8、物流接口" class="headerlink" title="8、物流接口"></a>8、物流接口</h4><p><a href="http://www.kuaidi100.com/query?type=" target="_blank" rel="external">http://www.kuaidi100.com/query?..</a>快递公司代号&amp;postid=快递单号<br><br>ps:快递公司编码:申通=”shentong” EMS=”ems” 顺丰=”shunfeng” 圆通=”yuantong” 中通=”zhongtong” 韵达=”yunda” 天天=”tiantian” 汇通=”huitongkuaidi” 全峰=”quanfengkuaidi” 德邦=”debangwuliu” 宅急送=”zhaijisong”<br><br><strong>利用以上一些接口是些过一些简单的聚合，比如这个做了一个机器人订阅号</strong><br></p>
<p>转自：<a href="https://zhuanlan.zhihu.com/p/21320392?refer=passer" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21320392?refer=passer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/02/17/" itemprop="url">
                  前端的性能优化都有哪些东西？👍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-02T21:32:51+08:00" content="2016-04-02">
              2016-04-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。<br><br>Yslow是雅虎开发的基于网页性能分析浏览器插件，可以检测出网页的具体性能值，并且有著名的Yslow 23条优化规则，这23条，就够我们玩的了。<br></p>
<h4 id="1-减少HTTP请求次数"><a href="#1-减少HTTP请求次数" class="headerlink" title="1. 减少HTTP请求次数"></a>1. 减少HTTP请求次数</h4><p>尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。<br></p>
<h4 id="2-使用CDN"><a href="#2-使用CDN" class="headerlink" title="2. 使用CDN"></a>2. 使用CDN</h4><p>网站上静态资源即css、js全都使用cdn分发，图片亦然。<br></p>
<h4 id="3-避免空的src和href"><a href="#3-避免空的src和href" class="headerlink" title="3. 避免空的src和href"></a>3. 避免空的src和href</h4><p>当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。<br></p>
<h4 id="4-为文件头指定Expires"><a href="#4-为文件头指定Expires" class="headerlink" title="4. 为文件头指定Expires"></a>4. 为文件头指定Expires</h4><p>Exipres是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子：<br><br>新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14.<br><br><img src="http://upload-images.jianshu.io/upload_images/1903456-3efc5d77e5af7164.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br></p>
<h4 id="5-使用gzip压缩内容"><a href="#5-使用gzip压缩内容" class="headerlink" title="5. 使用gzip压缩内容"></a>5. 使用gzip压缩内容</h4><p>gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。<br></p>
<h4 id="6-把CSS放到顶部"><a href="#6-把CSS放到顶部" class="headerlink" title="6. 把CSS放到顶部"></a>6. 把CSS放到顶部</h4><p>网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。<br></p>
<h4 id="7-把JS放到底部"><a href="#7-把JS放到底部" class="headerlink" title="7. 把JS放到底部"></a>7. 把JS放到底部</h4><p>加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。<br></p>
<h4 id="8-避免使用CSS表达式"><a href="#8-避免使用CSS表达式" class="headerlink" title="8. 避免使用CSS表达式"></a>8. 避免使用CSS表达式</h4><p>举个css表达式的例子<br><br>font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF” : “#AAAAAA” );<br><br>这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。<br></p>
<h4 id="9-将CSS和JS放到外部文件中"><a href="#9-将CSS和JS放到外部文件中" class="headerlink" title="9. 将CSS和JS放到外部文件中"></a>9. 将CSS和JS放到外部文件中</h4><p>目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。<br></p>
<h4 id="10-权衡DNS查找次数"><a href="#10-权衡DNS查找次数" class="headerlink" title="10. 权衡DNS查找次数"></a>10. 权衡DNS查找次数</h4><p>减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。<br><br>IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。<br><br>下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。<br><br><img src="http://upload-images.jianshu.io/upload_images/1903456-53a9f504989386c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br></p>
<h4 id="11-精简CSS和JS"><a href="#11-精简CSS和JS" class="headerlink" title="11. 精简CSS和JS"></a>11. 精简CSS和JS</h4><p>这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。<br></p>
<h4 id="12-避免跳转"><a href="#12-避免跳转" class="headerlink" title="12. 避免跳转"></a>12. 避免跳转</h4><p>有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 baidu.com/（注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。<br><br>另一种是不用域名之间的跳转， 比如访问 baidu.com/bbs 跳转到bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。<br></p>
<h4 id="13-删除重复的JS和CSS"><a href="#13-删除重复的JS和CSS" class="headerlink" title="13. 删除重复的JS和CSS"></a>13. 删除重复的JS和CSS</h4><p>重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。<br></p>
<h4 id="14-配置ETags"><a href="#14-配置ETags" class="headerlink" title="14. 配置ETags"></a>14. 配置ETags</h4><p>它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载<br></p>
<h4 id="15-可缓存的AJAX"><a href="#15-可缓存的AJAX" class="headerlink" title="15. 可缓存的AJAX"></a>15. 可缓存的AJAX</h4><p>异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存<br></p>
<pre><code>$.ajax({      url : &apos;url&apos;,      dataType : &quot;json&quot;,      cache: true,      success : function(son, status){                  }
</code></pre><h4 id="16-使用GET来完成AJAX请求"><a href="#16-使用GET来完成AJAX请求" class="headerlink" title="16. 使用GET来完成AJAX请求"></a>16. 使用GET来完成AJAX请求</h4><p>当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。<br></p>
<h4 id="17-减少DOM元素数量"><a href="#17-减少DOM元素数量" class="headerlink" title="17. 减少DOM元素数量"></a>17. 减少DOM元素数量</h4><p>这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。<br></p>
<h4 id="18-避免404"><a href="#18-避免404" class="headerlink" title="18. 避免404"></a>18. 避免404</h4><p>比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。<br></p>
<h4 id="19-减少Cookie的大小"><a href="#19-减少Cookie的大小" class="headerlink" title="19. 减少Cookie的大小"></a>19. 减少Cookie的大小</h4><p>Cookie里面别塞那么多东西，因为每个请求都得带着他跑。<br></p>
<h4 id="20-使用无cookie的域"><a href="#20-使用无cookie的域" class="headerlink" title="20. 使用无cookie的域"></a>20. 使用无cookie的域</h4><p>比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。<br></p>
<h4 id="21-不要使用滤镜"><a href="#21-不要使用滤镜" class="headerlink" title="21. 不要使用滤镜"></a>21. 不要使用滤镜</h4><p>IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。<br><br>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。<br></p>
<h4 id="22-不要在HTML中缩放图片"><a href="#22-不要在HTML中缩放图片" class="headerlink" title="22. 不要在HTML中缩放图片"></a>22. 不要在HTML中缩放图片</h4><p>比如你需要的图片尺寸是50<em> 50<br><br>那就不用用一张500</em>500的大尺寸图片，影响加载<br></p>
<h4 id="23-缩小favicon-ico并缓存"><a href="#23-缩小favicon-ico并缓存" class="headerlink" title="23. 缩小favicon.ico并缓存"></a>23. 缩小favicon.ico并缓存</h4><p>以上是Yslow的23个优化原则，基本可以涵盖现在前端大部分的性能优化原则了，很多更加geek和精细优化方法都是从这些原则里面延伸出来的。 具体想了解更多优化细则的童鞋建议去看看下面的一本书，毕竟页数多讲的也细嘛：<br><br>《<a href="https://book.douban.com/subject/26411563/" target="_blank" rel="external">高性能网站建设指南（第二版</a>》，这里面其实就是细化的讲解了上面的23原则。<br><br>前端优化是条漫长的路，不是说一天两天就能全部做完的。我们可以参考上面的准则去把我们目前能做的都给优化了，剩下的更加小的一些细节点不用太过着急，毕竟也是要考虑优化性价比的。比如为了减小一个文件几个字节花上个把月根本不值得。这些优化的东西都可以在我们的工作中慢慢去通过积累，去通过google解决。<br><br>如果想了解更多前端知识，可以跑去这里看看：<a href="http://www.gongchengketang.com/?utm_source=csdn&amp;utm_medium=blog&amp;utm_campaign=xingnengyouhua" target="_blank" rel="external">系统学习前端知识</a><br></p>
<p>转自：<a href="http://www.jianshu.com/p/ce90a60a0a77" target="_blank" rel="external">http://www.jianshu.com/p/ce90a60a0a77</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/28/16/" itemprop="url">
                  本地存储小结💘
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-28T22:10:54+08:00" content="2016-03-28">
              2016-03-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>总括：详细讲述<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>的区别和用法。<br></p>
<h4 id="人生如画，岁月如歌。"><a href="#人生如画，岁月如歌。" class="headerlink" title="人生如画，岁月如歌。"></a>人生如画，岁月如歌。</h4><p>原文博客地址：<a href="http://damonare.github.io/2016/11/16/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93/#more" target="_blank" rel="external">Javascript本地存储小结</a><br><br>知乎专栏&amp;&amp;简书专题：<a href="https://zhuanlan.zhihu.com/damonare" target="_blank" rel="external">前端进击者（知乎）</a>&amp;&amp;<a href="http://www.jianshu.com/collection/bbaa63e264f5" target="_blank" rel="external">前端进击者（简书）</a><br></p>
<h4 id="1-各种存储方案的简单对比"><a href="#1-各种存储方案的简单对比" class="headerlink" title="1. 各种存储方案的简单对比"></a>1. 各种存储方案的简单对比</h4><ul>
<li>Cookies：浏览器均支持，容量为4KB</li>
<li>UserData：仅IE支持，容量为64KB</li>
<li>Flash：100KB，非HTML原生，需要插件支持</li>
<li>Google Gears SQLite ：需要插件支持，容量无限制</li>
<li>LocalStorage：HTML5，容量为5M</li>
<li>SesstionStorage：HTML5，容量为5M</li>
<li>globalStorage：Firefox独有的，Firefox13开始就不再支持这个方法</li>
</ul>
<p>UserData仅IE支持， Google Gears SQLite需要插件，Flash已经伴随着HTML5的出现渐渐退出了历史舞台，因此今天我们的主角只有他们三个：<code>Cookie</code>,<code>LocalStorge</code>,<code>SesstionStorge</code>;<br></p>
<h4 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h4><p>作为一个前端和Cookie打交道的次数肯定不会少了，Cookie算是比较古老的技术了。<br><br>1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。<br></p>
<ul>
<li>1）cookie的大小受限制，cookie大小被限制在4KB，不能接受像大文件或邮件那样的大数据。</li>
<li>2）只要有请求涉及cookie，cookie就要在服务器和浏览器之间来回传送（这解释为什么本地文件不能测试cookie）。而且cookie数据始终在同源的http请求中携带（即使不需要），这也是Cookie不能太大的重要原因。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。</li>
<li>3）用户每请求一次服务器数据，cookie则会随着这些请求发送到服务器，服务器脚本语言如PHP等能够处理cookie发送的数据，可以说是非常方便的。当然前端也是可以生成Cookie的，用js对cookie的操作相当的繁琐，浏览器只提供document.cookie这样一个对象，对cookie的赋值，获取都比较麻烦。而在PHP中，我们可以通过setcookie()来设置cookie，通过$_COOKIE这个超全局数组来获取cookie。</li>
</ul>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>
<h5 id="2-2-Session"><a href="#2-2-Session" class="headerlink" title="2.2 Session"></a>2.2 Session</h5><p>说到Cookie就不能不说Session。<br></p>
<p>Session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。比如：<code>http://damonare.cn?sessionid=123456</code>还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：<br></p>
<pre><code>&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;123456&quot;&gt;
    &lt;input type=&quot;text&quot;&gt;
&lt;/form&gt;
</code></pre><p>实际上这种技术可以简单的用对action应用URL重写来代替。<br></p>
<h5 id="2-3-Cookie和Session简单对比"><a href="#2-3-Cookie和Session简单对比" class="headerlink" title="2.3 Cookie和Session简单对比"></a>2.3 Cookie和Session简单对比</h5><h6 id="Cookie和Session-的区别："><a href="#Cookie和Session-的区别：" class="headerlink" title="Cookie和Session 的区别："></a>Cookie和Session 的区别：</h6><p>1）cookie数据存放在客户的浏览器上，session数据放在服务器上。<br><br>2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。<br><br>3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。<br><br> 4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br><br>5）所以建议：a.将登陆信息等重要信息存放为SESSION b.其他信息如果需要保留，可以放在cookie中<br></p>
<h5 id="2-4-document-cookie的属性"><a href="#2-4-document-cookie的属性" class="headerlink" title="2.4 document.cookie的属性"></a>2.4 document.cookie的属性</h5><h6 id="expires属性"><a href="#expires属性" class="headerlink" title="expires属性"></a>expires属性</h6><p>指定了coolie的生存期，默认情况下coolie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户推出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。<br></p>
<h6 id="path属性"><a href="#path属性" class="headerlink" title="path属性"></a>path属性</h6><p>它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联。<br></p>
<h6 id="domain属性"><a href="#domain属性" class="headerlink" title="domain属性"></a>domain属性</h6><p>domain属性可以使多个web服务器共享cookie。domain属性的默认值是创建cookie的网页所在服务器的主机名。不能将一个cookie的域设置成服务器所在的域之外的域。例如让位于order.damonare.cn的服务器能够读取catalog.damonare.cn设置的cookie值。如果catalog.damonare.cn的页面创建的cookie把自己的path属性设置为“/”，把domain属性设置成“.damonare.cn”，那么所有位于catalog.damonare.cn的网页和所有位于orlders.damonare.cn的网页，以及位于damonare.cn域的其他服务器上的网页都可以访问这个cookie。<br></p>
<h6 id="secure属性"><a href="#secure属性" class="headerlink" title="secure属性"></a>secure属性</h6><p>它是一个布尔值，指定在网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输。<br></p>
<h5 id="2-5-cookie实战"><a href="#2-5-cookie实战" class="headerlink" title="2.5 cookie实战"></a>2.5 cookie实战</h5><p>这里我们使用javascript来写一段cookie,借用w3cschool的demo:<br></p>
<pre><code>function getCookie(c_name){
    if (document.cookie.length&gt;0){
        c_start=document.cookie.indexOf(c_name + &quot;=&quot;)
        if (c_start!=-1){
            c_start=c_start + c_name.length+1
            c_end=document.cookie.indexOf(&quot;;&quot;,c_start)
            if (c_end==-1) c_end=document.cookie.length
            return unescape(document.cookie.substring(c_start,c_end))
        }
    }
    return &quot;&quot;;
}

function setCookie(c_name,value,expiredays){
    var exdate=new Date()
    exdate.setDate(exdate.getDate()+expiredays)
    document.cookie=c_name+ &quot;=&quot; +escape(value)+
            ((expiredays==null) ? &quot;&quot; : &quot;; expires=&quot;+exdate.toUTCString())
}
function checkCookie(){
    username=getCookie(&apos;username&apos;)
    if(username!=null &amp;&amp; username!=&quot;&quot;){alert(&apos;Welcome again &apos;+username+&apos;!&apos;)}
    else{
        username=prompt(&apos;Please enter your name:&apos;,&quot;&quot;)
        if (username!=null &amp;&amp; username!=&quot;&quot;){
            setCookie(&apos;username&apos;,username,355)
        }
    }
}
</code></pre><p>注意这里对Cookie的生存期进行了定义，也就是355天<br></p>
<h4 id="3-localStorage"><a href="#3-localStorage" class="headerlink" title="3. localStorage"></a>3. localStorage</h4><p>这是一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。<br>它也是采用Key - Value的方式存储数据，底层数据接口是sqlite，按域名将数据分别保存到对应数据库文件里。它能保存更大的数据（IE8上是10MB，Chrome是5MB），同时保存的数据不会再发送给服务器，避免带宽浪费。<br></p>
<h5 id="3-1-localStorage的属性方法"><a href="#3-1-localStorage的属性方法" class="headerlink" title="3.1 localStorage的属性方法"></a>3.1 localStorage的属性方法</h5><p>下表是localStorge的一些属性和方法<br></p>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>localStorage.length</td>
<td>获得storage中的个数</td>
<td></td>
</tr>
<tr>
<td>localStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
<td></td>
</tr>
<tr>
<td>localStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
<td></td>
</tr>
<tr>
<td>localStorage.key</td>
<td>获取键值key对应的值</td>
<td></td>
</tr>
<tr>
<td>localStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
<td></td>
</tr>
<tr>
<td>localStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
<td></td>
</tr>
<tr>
<td>localStorage.clear()</td>
<td>清除所有数据</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="3-2-localStorage的缺点"><a href="#3-2-localStorage的缺点" class="headerlink" title="3.2 localStorage的缺点"></a>3.2 localStorage的缺点</h5><p>① localStorage大小限制在500万字符左右，各个浏览器不一致<br><br>② localStorage在隐私模式下不可读取<br><br>③ localStorage本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存，想想就觉得吓人啊）<br><br>④ localStorage不能被爬虫爬取，不要用它完全取代URL传参<br></p>
<h4 id="4-sessionStorage"><a href="#4-sessionStorage" class="headerlink" title="4. sessionStorage"></a>4. sessionStorage</h4><p>和服务器端使用的session类似，是一种会话级别的缓存，关闭浏览器会数据会被清除。不过有点特别的是它的作用域是窗口级别的，也就是说不同窗口间的sessionStorage数据不能共享的。使用方法（和localStorage完全相同）：<br></p>
<table>
<thead>
<tr>
<th>属性方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionStorage.length</td>
<td>获得storage中的个数</td>
<td></td>
</tr>
<tr>
<td>sessionStorage.key(n)</td>
<td>获得storage中第n个元素对的键值（第一个元素是0）</td>
<td></td>
</tr>
<tr>
<td>sessionStorage.getItem(key)</td>
<td>获取键值key对应的值</td>
<td></td>
</tr>
<tr>
<td>sessionStorage.key</td>
<td>获取键值key对应的值</td>
<td></td>
</tr>
<tr>
<td>sessionStorage.setItem(key, value)</td>
<td>添加数据，键值为key，值为value</td>
<td></td>
</tr>
<tr>
<td>sessionStorage.removeItem(key)</td>
<td>移除键值为key的数据</td>
<td></td>
</tr>
<tr>
<td>sessionStorage.clear()</td>
<td>清除所有数据</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="5-sessionStorage和localStorage的区别"><a href="#5-sessionStorage和localStorage的区别" class="headerlink" title="5. sessionStorage和localStorage的区别"></a>5. sessionStorage和localStorage的区别</h4><p>1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。当用户关闭浏览器窗口后，数据立马会被删除。<br><br>2.localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。第二天、第二周或下一年之后，数据依然可用。<br></p>
<h5 id="5-1-测试"><a href="#5-1-测试" class="headerlink" title="5.1 测试"></a>5.1 测试</h5><h6 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage:"></a>sessionStorage:</h6><pre><code>if (sessionStorage.pagecount){
sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;
}else{
      sessionStorage.pagecount=1;
}
console.log(&quot;Visits &quot;+ sessionStorage.pagecount + &quot; time(s).&quot;);
</code></pre><h6 id="测试过程：我们在控制台输入上述代码查看打印结果"><a href="#测试过程：我们在控制台输入上述代码查看打印结果" class="headerlink" title="测试过程：我们在控制台输入上述代码查看打印结果"></a>测试过程：我们在控制台输入上述代码查看打印结果</h6><h6 id="控制台首次输入代码："><a href="#控制台首次输入代码：" class="headerlink" title="控制台首次输入代码："></a>控制台首次输入代码：</h6><p><img src="http://ac-myg6wstv.clouddn.com/34ec5d30041c0ead9c6c" alt=""><br><br>关闭窗口，控制台再次输入代码：<br><br><img src="http://ac-myg6wstv.clouddn.com/34ec5d30041c0ead9c6c" alt=""><br><br><strong>所谓的关闭窗口即销毁，就是这样，关闭窗口重新打开输入代码输出结果还是上面图片的样子，也就是说关闭窗口后sessionStorage.pagecount即被销毁，除非重心创建。或者从历史记录进入才会相关数据才会存在。好的，我们再来看下localStorge表现：</strong><br></p>
<pre><code>if (localStorage.pagecount){
localStorage.pagecount=Number(localStorage.pagecount) +1;
}else{
    localStorage.pagecount=1;
 }
console.log(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;);
</code></pre><h6 id="控制台首次输入代码：-1"><a href="#控制台首次输入代码：-1" class="headerlink" title="控制台首次输入代码："></a>控制台首次输入代码：</h6><p><img src="http://ac-myg6wstv.clouddn.com/7228ef55d946a6e5a715" alt=""><br><br>localStorage测试结果1<br></p>
<h6 id="关闭窗口，控制台再次输入代码："><a href="#关闭窗口，控制台再次输入代码：" class="headerlink" title="关闭窗口，控制台再次输入代码："></a>关闭窗口，控制台再次输入代码：</h6><p><img src="http://ac-myg6wstv.clouddn.com/d81641bc27deaf3b3191" alt=""><br><br>localStorage测试结果2<br></p>
<h4 id="6-web-Storage和cookie的区别"><a href="#6-web-Storage和cookie的区别" class="headerlink" title="6. web Storage和cookie的区别"></a>6. web Storage和cookie的区别</h4><p>Web Storage(localStorage和sessionStorage)的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br><br>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。<br><br>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生<br></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>博主尽可能思路清晰的理了一遍cookie，session，localStorage，sessionStorage之间的区别和联系，希望可以帮到大家。<br><br>参考文章：<br><br><a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="external">cookie</a> 和<a href="http://www.cnblogs.com/shiyangxt/archive/2008/10/07/1305506.html" target="_blank" rel="external">session</a> 的区别详解<br></p>
<p>转自：<a href="http://gold.xitu.io/post/582c7d330ce463006ce33838" target="_blank" rel="external">http://gold.xitu.io/post/582c7d330ce463006ce33838</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/25/14/" itemprop="url">
                  TCP/IP🌿
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-25T23:00:06+08:00" content="2016-03-25">
              2016-03-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="TCP-IP详解学习笔记-这位仁兄写得太好了"><a href="#TCP-IP详解学习笔记-这位仁兄写得太好了" class="headerlink" title="TCP/IP详解学习笔记   这位仁兄写得太好了"></a>TCP/IP详解学习笔记   这位仁兄写得太好了<br></h6><p><a href="http://blog.csdn.net/goodboy1881/category/204448.aspx" target="_blank" rel="external">http://blog.csdn.net/goodboy1881/category/204448.aspx</a><br><br>TCP/IP详解学习笔记(13)-TCP坚持定时器，TCP保活定时器<br><br>TCP/IP详解学习笔记(12)-TCP的超时与重传<br><br>TCP/IP详解学习笔记(11)-TCP交互数据流，成块数据流<br></p>
<h3 id="TCP-IP详解学习笔记-1-基本概念"><a href="#TCP-IP详解学习笔记-1-基本概念" class="headerlink" title="TCP/IP详解学习笔记(1)-基本概念"></a>TCP/IP详解学习笔记(1)-基本概念</h3><h4 id="为什么会有TCP-IP协议"><a href="#为什么会有TCP-IP协议" class="headerlink" title="为什么会有TCP/IP协议"></a>为什么会有TCP/IP协议</h4><p>在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。就好像圣经中上帝打乱了各地人的口音，让他们无法合作一样。计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。<br><br>但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。<br></p>
<h4 id="TCP-IP协议分层"><a href="#TCP-IP协议分层" class="headerlink" title="TCP/IP协议分层"></a>TCP/IP协议分层</h4><p>提到协议分层，我们很容易联想到ISO-OSI的七层协议经典架构，但是TCP/IP协议族的结构则稍有不同。如图所示 <br><br>TCP/IP协议族按照层次由上到下，层层包装。最上面的就是应用层了，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次（不要告诉我你没用过udp玩星际）。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据（后面会讲到）以确定传输的目标。第四层是叫数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。再往下则是硬件层次了，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等（这些我们就不用关心了，我们也不做网卡），所以有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构非常有栈的味道，所以某些文章也把tcp/ip协议族称为tcp/ip协议栈。<br></p>
<h4 id="一些基本的常识"><a href="#一些基本的常识" class="headerlink" title="一些基本的常识"></a>一些基本的常识</h4><p>在学习协议之前，我们应该具备一些基本知识。<br></p>
<h5 id="互联网地址-ip地址"><a href="#互联网地址-ip地址" class="headerlink" title="互联网地址(ip地址)"></a>互联网地址(ip地址)</h5><p>网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。<br></p>
<h5 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h5><p>域名系统是一个分布的数据库，它提供将主机名（就是网址啦）转换成IP地址的服务。<br></p>
<h5 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h5><p>RFC是什么？RFC就是tcp/ip协议的标准文档，在这里我们可以看到RFC那长长的定义列表，现在它一共有4000多个协议的定义，当然，我们所要学习的，也就是那么十几个协议而已。 <br></p>
<h5 id="端口号-port"><a href="#端口号-port" class="headerlink" title="端口号(port)"></a>端口号(port)</h5><p>注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。<br></p>
<h5 id="应用编程接口"><a href="#应用编程接口" class="headerlink" title="应用编程接口"></a>应用编程接口</h5><p>现在常用的编程接口有socket和TLI。而前面的有时候也叫做“Berkeley socket”，可见Berkeley对于网络的发展有多大的贡献。<br></p>
<h3 id="TCP-IP详解学习笔记-2-数据链路层"><a href="#TCP-IP详解学习笔记-2-数据链路层" class="headerlink" title="TCP/IP详解学习笔记(2)-数据链路层"></a>TCP/IP详解学习笔记(2)-数据链路层</h3><p>数据链路层有三个目的：<br><br>1.为IP模块发送和 接收IP数据报。<br><br>2.为ARP模块发送ARP请求和接收ARP应答。<br><br>3.为RARP发送RARP请 求和接收RARP应答<br><br>ip大家都听说过。至于ARP和RARP，ARP叫做地址解析协议，是用IP地址换MAC地址的一种协议，而RARP则叫做逆地址解析协议，在tcp/ip协议的后面章节会介绍它们（在局域网里面用ARP协议可以很容易的搞瘫痪网络哦）<br><br>数据链路层的协议还是很多的，有我们最常用的以太网（就是平时我们用的网卡）协议，也有不太常见的令牌环，还有FDDI，当然，还有国内现在相当普及的PPP协议（就是adsl宽带），以及一个loopback协议。<br><br>联系linux里面的ifconfig -a命令，这个命令通常会得到如下的结果<br></p>
<pre><code>eth0 Link encap:Ethernet HWaddr 00:01:4A:03:5B:ED
inet addr:192.168.11.2 Bcast:192.168.11.255 Mask:255.255.255.0
inet6 addr: fe80::201:4aff:fe03:5bed/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:2819 errors:0 dropped:0 overruns:0 frame:0
TX packets:76 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:241609 (235.9 KiB) TX bytes:9596 (9.3 KiB)

lo Link encap:Local Loopback
inet addr:127.0.0.1 Mask:255.0.0.0
inet6 addr: ::1/128 Scope:Host
UP LOOPBACK RUNNING MTU:16436 Metric:1
RX packets:2713 errors:0 dropped:0 overruns:0 frame:0
TX packets:2713 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:3516032 (3.3 MiB) TX bytes:3516032 (3.3 MiB)
</code></pre><p>其中，eth0就是以太网接口，而lo则是loopback接口。这也说明这个主机在网络链路层上至少支持loopback协议和以太网协议。<br><br>以太网（Ether-net）的定是指数字设备公司（ Digital Equipment Corp.）、英特尔公司（Intel Corp.）和Xerox公司在1982年联合公布的一个标准，这个标准里面使用了一种称作CSMA/CD的接入方法。而IEEE802提供的标准集802.3(还有一部分定义到了802.2中)也提供了一个CSMA/CD的标准。这两个标准稍有不同，TCP/IP协议对这种情况的处理方式如下:<br></p>
<p>1.以太网的IP数据报封装在RFC894中定义，而IEEE802网络的IP数据报封装在RFC1042中定义。<br><br>2.一台主机一定要能发送和接收RFC894定义的数据报。<br><br>3.一台主机可以接收RFC894和RFC1042的封装格式的混合数据报。<br><br>4.一台主机也许能够发送RFC1042数据报。。如果主机能同时发送两种类型的分组数 据，那么发送的分组必须是可以设置的，而且默认条件下必须是RFC 894分组。<br></p>
<h6 id="可见，RFC1042在TCP-IP里面处于一个配角的地位。这两种不同的数据报格式请参考教材。"><a href="#可见，RFC1042在TCP-IP里面处于一个配角的地位。这两种不同的数据报格式请参考教材。" class="headerlink" title="可见，RFC1042在TCP/IP里面处于一个配角的地位。这两种不同的数据报格式请参考教材。"></a>可见，RFC1042在TCP/IP里面处于一个配角的地位。这两种不同的数据报格式请参考教材。</h6><p>ppp(点对点协议)是从SLIP的替代品。他们都提供了一种低速接入的解决方案。而每一种数据链路层协议，都有一个MTU（最大传输单元）定义，在这个定义下面，如果IP数据报过大，则要进行分片(fragmentation)，使得每片都小于MTU，注意PPP的MTU并不是一个物理定义，而是指一个逻辑定义（个人认为就是用程序控制）。可以用netstat来打印出MTU的结果，比如键入netstat -in<br><br><code>Kernel Interface table
Iface       MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0       1500   0     1774      0      0      0      587      0      0      0 BMRU
lo        16436   0     2667      0      0      0     2667      0      0      0 LRU</code><br><br>就可以观察到eth0的MTU是1500。而lo（环回接口）的MTU则是16436。<br><br>最后说说那个环回接口（loopback）。平时我们用127.0.0.1来尝试自己的机器服务器好使不好使。走的就是这个loopback接口。对于环回接口，有如下三点值得注意:<br>1.传给环回地址（一般是127.0.0.1）的任何数据均作为I P输入。<br><br>2.传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是 因为广播传送和多播传送的定义包含主机本身。<br><br>3.任何传给该主机IP地址的数据均送到环回接口。<br><br>这一章还是很简单的，一般作为了解知识也就足够了，没必要抠的那么详细。<br></p>
<h3 id="TCP-IP详解之IP协议ARP协议和RARP协议"><a href="#TCP-IP详解之IP协议ARP协议和RARP协议" class="headerlink" title="TCP/IP详解之IP协议ARP协议和RARP协议"></a>TCP/IP详解之IP协议ARP协议和RARP协议</h3><p>把这三个协议放到一起学习是因为这三个协议处于同一层，ARP协议用来找到目标主机的Ethernet网卡Mac地址，IP则承载要发送的消息。数据链路层可以从ARP得到数据的传送信息，而从IP得到要传输的数据信息。<br></p>
<h4 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1.IP协议"></a>1.IP协议</h4><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制–这被认为是上层协议–TCP或UDP要做的事情。所以这也就出现了TCP是一个可靠的协议，而UDP就没有那么可靠的区别。这是后话，暂且不提<br></p>
<h5 id="1-1-IP协议头"><a href="#1-1-IP协议头" class="headerlink" title="1.1.IP协议头"></a>1.1.IP协议头</h5><p>挨个解释它是教科书的活计，我感兴趣的只是那八位的TTL字段，还记得这个字段是做什么的么?这个字段规定该数据包在穿过多少个路由之后才会被抛弃(这里就体现出来IP协议包的不可靠性，它不保证数据被送达)，某个ip数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64，Tracerouter这个工具就是用这个原理工作的，tranceroute的-m选项要求最大值是255，也就是因为这个TTL在IP协议里面只有8bit。<br><br>现在的ip版本号是4，所以也称作IPv4。现在还有IPv6，而且运用也越来越广泛了。<br></p>
<h5 id="1-2-IP路由选择"><a href="#1-2-IP路由选择" class="headerlink" title="1.2.IP路由选择"></a>1.2.IP路由选择</h5><p>当一个IP数据包准备好了的时候，IP数据包(或者说是路由器)是如何将数据包送到目的地的呢?它是怎么选择一个合适的路径来”送货”的呢?<br><br>最特殊的情况是目的主机和主机直连，那么主机根本不用寻找路由，直接把数据传递过去就可以了。至于是怎么直接传递的，这就要靠ARP协议了，后面会讲到。<br><br>稍微一般一点的情况是，主机通过若干个路由器(router)和目的主机连接。那么路由器就要通过ip包的信息来为ip包寻找到一个合适的目标来进行传递，比如合适的主机，或者合适的路由。路由器或者主机将会用如下的方式来处理某一个IP数据包<br><br>如果IP数据包的TTL(生命周期)以到，则该IP数据包就被抛弃。<br><br>搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机<br><br>搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要“子网掩码(1.3.)”的协助。如果找到路由器，则将该包发向路由器。<br><br>搜索路由表，如果匹配同子网路由器失败，则匹配同网号(第一章有讲解)路由器，如果找到路由器，则将该包发向路由器。<br><br>搜索陆游表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包<br><br>如果都失败了，就丢掉这个包。<br><br>这再一次证明了，ip包是不可靠的。因为它不保证送达。<br></p>
<h5 id="1-3-子网寻址"><a href="#1-3-子网寻址" class="headerlink" title="1.3.子网寻址"></a>1.3.子网寻址</h5><p>IP地址的定义是网络号+主机号。但是现在所有的主机都要求子网编址，也就是说，把主机号在细分成子网号+主机号。最终一个IP地址就成为 网络号码+子网号+主机号。例如一个B类地址：210.30.109.134。一般情况下，这个IP地址的红色部分就是网络号，而蓝色部分就是子网号，绿色部分就是主机号。至于有多少位代表子网号这个问题上，这没有一个硬性的规定，取而代之的则是子网掩码，校园网相信大多数人都用过，在校园网的设定里面有一个255.255.255.0的东西，这就是子网掩码。子网掩码是由32bit的二进制数字序列,形式为是一连串的1和一连串的0，例如：255.255.255.0(二进制就是11111111.11111111.11111111.00000000)对于刚才的那个B类地址，因为210.30是网络号，那么后面的109.134就是子网号和主机号的组合，又因为子网掩码只有后八bit为0，所以主机号就是IP地址的后八个bit，就是134，而剩下的就是子网号码–109。<br></p>
<h4 id="2-ARP协议"><a href="#2-ARP协议" class="headerlink" title="2. ARP协议"></a>2. ARP协议</h4><p>还记得数据链路层的以太网的协议中，每一个数据包都有一个MAC地址头么?我们知道每一块以太网卡都有一个MAC地址，这个地址是唯一的，那么IP包是如何知道这个MAC地址的?这就是ARP协议的工作。<br><br>ARP(地址解析)协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存(就是一个IP-MAC地址对应表缓存)，如果查询的IP-MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机，而广播主机拿到ARP包后会更新自己的ARP缓存(就是存放IP-MAC对应表的地方)。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。<br><br>一个典型的arp缓存信息如下，在任意一个系统里面用“arp -a”命令:<br></p>
<pre><code>Interface: 192.168.11.3 --- 0x2&lt;br&gt;
Internet Address Physical Address Type&lt;br&gt;
</code></pre><p>　　192.168.11.1 00-0d-0b-43-a0-2e dynamic<br><br>　　192.168.11.2 00-01-4a-03-5b-ed dynamic<br><br>都会得到这样的结果。<br><br>这样的高速缓存是有时限的，一般是20分钟(伯克利系统的衍生系统)。<br></p>
<h3 id="TCP-IP详解学习笔记-4-ICMP协议，ping和Traceroute"><a href="#TCP-IP详解学习笔记-4-ICMP协议，ping和Traceroute" class="headerlink" title="TCP/IP详解学习笔记(4)-ICMP协议，ping和Traceroute"></a>TCP/IP详解学习笔记(4)-ICMP协议，ping和Traceroute</h3><h4 id="1-IMCP协议介绍"><a href="#1-IMCP协议介绍" class="headerlink" title="1.IMCP协议介绍"></a>1.IMCP协议介绍</h4><p>前面讲到了，IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。<br><br>当传送IP数据包发生错误－－比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成。而前 16bit就组成了ICMP所要传递的信息。书上的图6－3清楚的给出了错误类型和代码的组合代表的意思。<br><br>尽管在大多数情况下，错误的包传送应该给出ICMP报文，但是在特殊情况下，是不产生ICMP错误报文的。如下<br><br>1.ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）<br><br>2.目的地址是广播地址或多播地址的IP数据报。<br><br>3.作为链路层广播的数据报。<br><br>4.不是IP分片的第一片。<br><br>5.源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。<br><br>虽然里面的一些规定现在还不是很明白，但是所有的这一切规定，都是为了防止产生ICMP报文的无限传播而定义的。<br><br>ICMP协议大致分为两类，一种是查询报文，一种是差错报文。其中查询报文有以下几种用途:<br><br>1.ping查询（不要告诉我你不知道ping程序）<br><br>2.子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）<br><br>3.时间戳查询（可以用来同步时间） <br><br>而差错报文则产生在数据传送发生错误的时候。就不赘述了。<br></p>
<h4 id="2-ICMP的应用–ping"><a href="#2-ICMP的应用–ping" class="headerlink" title="2.ICMP的应用–ping"></a>2.ICMP的应用–ping</h4><p>ping可以说是ICMP的最著名的应用，当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:<br><br>Reply from 10.4.24.1: bytes=32 time<1ms ttl="255<br"><br>Reply from 10.4.24.1: bytes=32 time<1ms ttl="255<br"><br>Reply from 10.4.24.1: bytes=32 time<1ms ttl="255<br"><br>Reply from 10.4.24.1: bytes=32 time<1ms ttl="255<br"><br>Ping statistics for 10.4.24.1:<br><br>    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),<br><br>Approximate round trip times in milli-seconds:<br><br>    Minimum = 0ms, Maximum = 0ms, Average = 0ms<br><br>ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。我给的例子不太好，因为走的路由少，有兴趣地可以ping一下国外的网站比如sf.net，就可以观察到一些 丢包的现象，而程序运行的时间也会更加的长。<br><br>ping还给我们一个看主机到目的主机的路由的机会。这是因为，ICMP的ping请求数据报在每经过一个路由器的时候，路由器都会把自己的ip放到该数 据报中。而目的主机则会把这个ip列表复制到回应icmp数据包中发回给主机。但是，无论如何，ip头所能纪录的路由列表是非常的有限。如果要观察路由， 我们还是需要使用更好的工具，就是要讲到的Traceroute(windows下面的名字叫做tracert)。<br></1ms></1ms></1ms></1ms></p>
<h4 id="3-ICMP的应用–Traceroute"><a href="#3-ICMP的应用–Traceroute" class="headerlink" title="3.ICMP的应用–Traceroute"></a>3.ICMP的应用–Traceroute</h4><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。前面说到，尽管ping工具也可以进行侦测，但是，因为ip头的限制，ping不能完全的记录下所经过的路由器。所以Traceroute正好就填补了这个缺憾。<br><br>Traceroute的原理是非常非常的有意思，它受到目的主机的IP后，首先给目的主机发送一个TTL=1（还记得TTL是什么吗？）的UDP(后面就 知道UDP是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器ip。从而避开了ip头只能记录有限路由IP的问题。<br><br>有人要问，我怎么知道UDP到没到达目的主机呢？这就涉及一个技巧的问题，TCP和UDP协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较 小的端口，比如说80,比如说23,等等。而traceroute发送的是端口号&gt;30000(真变态)的UDP报，所以到达目的主机的时候，目的 主机只能发送一个端口不可达的ICMP数据报给主机。主机接到这个报告以后就知道，主机到了，所以，说Traceroute是一个骗子一点也不为过:)<br><br>Traceroute程序里面提供了一些很有用的选项，甚至包含了IP选路的选项，请察看man文档来了解这些，这里就不赘述了。<br></p>
<h3 id="TCP-IP详解学习笔记-5-IP选路，动态选路，和一些细节"><a href="#TCP-IP详解学习笔记-5-IP选路，动态选路，和一些细节" class="headerlink" title="TCP/IP详解学习笔记(5)-IP选路，动态选路，和一些细节"></a>TCP/IP详解学习笔记(5)-IP选路，动态选路，和一些细节</h3><h4 id="1-静态IP选路"><a href="#1-静态IP选路" class="headerlink" title="1.静态IP选路"></a>1.静态IP选路</h4><h5 id="1-1-一个简单的路由表"><a href="#1-1-一个简单的路由表" class="headerlink" title="1.1.一个简单的路由表"></a>1.1.一个简单的路由表</h5><p>选路是IP层最重要的一个功能之一。前面的部分已经简单的讲过路由器是通过何种规则来根据IP数据包的IP地址来选择路由。这里就不重复了。首先来看看一个简单的系统路由表。<br><br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br><br>192.168.11.0    <em>               255.255.255.0   U     0      0        0 eth0<br><br>169.254.0.0     </em>               255.255.0.0     U     0      0        0 eth0<br><br>default         192.168.11.1    0.0.0.0         UG    0      0        0 eth0<br><br>对于一个给定的路由器，可以打印出五种不同的flag。<br><br>1.U表明该路由可用。<br><br>2.G表明该路由是到一个网关。如果没有这个标志，说明和Destination是直连的，而相应的Gateway应该直接给出Destination的地址。<br><br>3.H表明该路由是到一个主机，如果没有该标志，说明Destination是一个网络，换句话说Destination就应该写成一个网络号和子网号的组合，而不包括主机号(主机号码处为0)，例如 192.168.11.0<br><br>4.D表明该路由是为重定向报文创建的<br><br>5.M该路由已经被重定向报文修改 <br><br>U没啥可说的，G说明这是一个网关，如果你要发数据给Destination，IP头应该写Destination的IP地址，而数据链路层的MAC地址就应该是GateWay的Mac地址了；反之，如果没有G标志，那么数据链路层和IP层的地址应该是对应的。H说明了Destination的性质，如果是H的，则说明该地址是一个完整的地址，既有网络号又有主机号，那么再匹配的时候就既要匹配网络号，又要匹配主机号；反之，Destination就代表一个网络，在匹配的时候只要匹配一下网络号就可以了。<br><br>这样，IP选路的方式就可以更加具体化了。如下<br><br>1.首先用IP地址来匹配那些带H标志的DestinationIP地址。<br><br>2.如果1失败就匹配那些网络地址。<br><br>3.如果2失败就发送到Default网关 <br><br>顺便提一下那个GenMask（还记得子网掩码么），它指定了目的地址的子网号，例如第一条的子网就是11。<br></p>
<h5 id="1-2-其他有关路由表的知识"><a href="#1-2-其他有关路由表的知识" class="headerlink" title="1.2.其他有关路由表的知识"></a>1.2.其他有关路由表的知识</h5><p>一般，我们在配置好一个网络接口的时候，一个路由就被直接创建好了。当然我们也可以手动添加路由。用route add命令就可以了。<br><br>而当一个IP包在某一个路由器的时候发现没有路由可走，那么该路由器就会给源主机发送“主机不可达”或者“网络不可达”的ICMP包来报错。<br><br>注意，一般的操作系统默认是没有路由功能的，这需要自己配置。这些历史原因就不细说了。<br></p>
<h5 id="1-3-ICMP的IP重定向报文和路由发现报文"><a href="#1-3-ICMP的IP重定向报文和路由发现报文" class="headerlink" title="1.3.ICMP的IP重定向报文和路由发现报文"></a>1.3.ICMP的IP重定向报文和路由发现报文</h5><p>当IP包在某一个地方转向的时候，都回给发送IP报的源主机一个ICMP重定向报文，而源主机就可以利用这个信息来更新自己的路由表，这样，随着网络通信的逐渐增多，路由表也就越来越完备，数据转发的速度也会越来越快。我们需要注意的是：<br><br>1.重定向报文只能由路由器发出。<br><br>2.重定向报文为主机所用，而不是为路由器所用。 <br><br>在主机引导的时候，一般会发送在网内广播一个路由请求的ICMP报文，而多个路由器则会回应一个路由通告报文。而且，路由其本身不定期的在网络内发布路由通告报文，这样，根据这些报文，每一个主机都会有机会建立自己的路由表而实现网络通信。路由器在一份通告报文中可以通告多个地址，并且给出每一个地址的优先等级，这个优先等级是该IP作为默认路由的等级，至于怎么算的就不深究了。<br><br>路由器一般会在450-600秒的时间间隔内发布一次通告，而一个给定的通告报文的寿命是30分钟。而主机在引导的时候会每三秒发送一次请求报文，一旦接受到一个有效的通告报文，就停止发送请求报文。<br><br>在TCP/IP详解编写的时候，只有Solaris2.x支持这两种报文，大多数系统还不支持这两种报文。（后面还会讲到一些有用的路由报文）<br></p>
<h4 id="2-动态选路协议"><a href="#2-动态选路协议" class="headerlink" title="2.动态选路协议"></a>2.动态选路协议</h4><p>前面的选路方法叫做静态选路，简要地说就是在配置接口的时候，以默认的方式生成路由表项。并通过route来增加表项，或者通过ICMP报文来更新表项（通常在默认方式出错的情况下）。 而如果上诉三种方法都不能满足，那么我们就使用动态选路。<br><br>动态选路协议是用于动态选路的重要组成部分，但是他们只是使用在路由器之间，相邻路由器之间互相通信。系统（路有选择程序）选择比较合适的路有放到核心路由表中，然后系统就可以根据这个核心路有表找到最合适的网路。也就是说，动态选路是在系统核心网络外部进行的，它只是用一些选路的策略影响路由表，而不会影响到最后通过路由表选择路由的那一部分。选路协议有一大类常用的叫做内部网关协议(IGP)，而在IGP中，RIP就是其中最重要的协议。一种新的IGP协议叫做<code>开放最短路经优先(OSPF)协议</code>，其意在取代RIP。另一种最早用在网路骨干网上的IGP协议–HELLO，现在已经不用了。<br><br>如今，任何支持动态选路的路由器都必须同时支持OSPF和RIP，还可以选择性的支持其他的IGP协议。<br></p>
<h5 id="2-1-Unix选路程序"><a href="#2-1-Unix选路程序" class="headerlink" title="2.1.Unix选路程序"></a>2.1.Unix选路程序</h5><p>Unix系统上面通常都有路由守护程序－－routed。还有一个叫做gate。gate所支持的协议要比routed多，routed只是支持RIPv1版本。而gate则支持RIPv1、v2，BGPv1 等等。<br></p>
<h5 id="2-1-RIP：选路信息协议"><a href="#2-1-RIP：选路信息协议" class="headerlink" title="2.1.RIP：选路信息协议"></a>2.1.RIP：选路信息协议</h5><p>它的定义可以在RFC1058内找到，这种协议使用UDP作为载体（也就是UDP的上层协议）。我们最关心的就是RIP其中的一个段，叫做度量的段，这是一个以hop作为计数器（就是以走过多少路由为计数器）的段（IP协议里面也有一个TTL不是么）。这个度量段将最终影响到路由表的建立。参考图:<br><br>一般说来routed要承担如下的工作：<br><br>1.给每一个已知的路由器发送rip请求报文，要求其他路由器给出完整的路由表。这种报文的命令字段为1，地址字段为0，度量地段为16（相当于无穷大）。<br><br>2.接受请求，如果接收到刚才的那个请求，就把自己的完整的路由表交给请求者。如果没有，就处理IP请求表项，把表项中自己有的部分添上跳数，没有的部分添上16。然后发给请求者。<br><br>3.接受回应。更新自己的路由表。使用hop数小的规则。<br><br>4.定期更新路由表，一般是30s(真频繁)给相邻的路有启发一次自己的路由表。这种形式可以使广播形式的。<br><br>这个协议看起来会工作的很好，但是，这里面其实有很多隐藏的忧患，比如说RIP没有子网的概念，比如说环路的危险。而且hop数的上限也限制了网络的大小。<br><br>因此，出现了很多RIPv1的替代品，比如说RIPv2,比如说OSPF。他们都是通过某种策略来影响路由表，所以就不说了。<br></p>
<p>　</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/25/15/" itemprop="url">
                  JS家的排序算法🎵
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-25T22:56:53+08:00" content="2016-03-25">
              2016-03-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>有句话怎么说来着：<br><br><code>雷锋推倒雷峰塔，Java implements JavaScript.</code><br><br>当年，想凭借抱Java大腿火一把而不惜把自己名字给改了的JavaScript（原名LiveScript），如今早已光芒万丈。node JS的出现更是让JavaScript可以前后端通吃。虽然Java依然制霸企业级软件开发领域（C/C + +的大神们不要打我。。。），但在Web的江湖，JavaScript可谓风头无两，坐上了头把交椅。<br><br>然而，在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +。这给最近想恶补算法和数据结构知识的我造成了一定困扰，因为我想寻找一本以JavaScript为默认语言的算法书籍。当我了解到O’REILLY家的动物丛书系列里有一本叫做《数据结构与算法JavaScript描述》时，便兴奋的花了两天时间把这本书从头到尾读了一遍。它是一本很好的针对前端开发者们的入门算法书籍，可是，它有一个很大的缺陷，就是里面有很多明显的小错误，明显到就连我这种半路出家的程序猿都能一眼看出来。还有一个问题是，很多重要的算法和数据结构知识并没有在这本书里被提到。这些问题对于作为一个晚期强迫症患者的我来说简直不能忍。于是乎，一言不合我就决定自己找资料总结算法。那么，我就从算法领域里最基础的知识点——排序算法总结起好了。<br><br>我相信以下的代码里一定会有某些bug或错误或语法不规范等问题是我自己无法发现的，所以敬请各位大神能够指出错误，因为只有在不断改错的道路上我才能取得长久的进步。<br></p>
<h3 id="十大经典算法排序总结对比"><a href="#十大经典算法排序总结对比" class="headerlink" title="十大经典算法排序总结对比"></a>十大经典算法排序总结对比</h3><p>一张图概括：<br><br><img src="http://upload-images.jianshu.io/upload_images/1867034-1d3e43cdb301fc9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><br>主流排序算法概览<br></p>
<h4 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h4><p><strong>n</strong>: 数据规模<br><br><strong>k</strong>: “桶”的个数<br><br><strong>In-place</strong>: 占用常数内存，不占用额外内存<br><br><strong>Out-place</strong>: 占用额外内存<br><br><strong>稳定性</strong>：排序后2个相等键值的顺序和排序之前它们的顺序相同<br></p>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><h4 id="冒泡排序须知："><a href="#冒泡排序须知：" class="headerlink" title="冒泡排序须知："></a>冒泡排序须知：</h4><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像Abandon在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。。。冒泡排序还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。。。<br></p>
<h4 id="什么时候最快（Best-Cases）："><a href="#什么时候最快（Best-Cases）：" class="headerlink" title="什么时候最快（Best Cases）："></a>什么时候最快（Best Cases）：</h4><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊。。。。）<br></p>
<h4 id="什么时候最慢（Worst-Cases）："><a href="#什么时候最慢（Worst-Cases）：" class="headerlink" title="什么时候最慢（Worst Cases）："></a>什么时候最慢（Worst Cases）：</h4><p>当输入的数据是反序时（写一个for循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗。。。）<br></p>
<h4 id="冒泡排序动图演示："><a href="#冒泡排序动图演示：" class="headerlink" title="冒泡排序动图演示："></a>冒泡排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-e19840224b331fae.gif?imageMogr2/auto-orient/strip" alt=""><br></p>
<h4 id="冒泡排序JavaScript代码实现："><a href="#冒泡排序JavaScript代码实现：" class="headerlink" title="冒泡排序JavaScript代码实现："></a>冒泡排序JavaScript代码实现：</h4><pre><code>function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
</code></pre><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><h4 id="选择排序须知："><a href="#选择排序须知：" class="headerlink" title="选择排序须知："></a>选择排序须知：</h4><p>在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。<br></p>
<h4 id="选择排序动图演示："><a href="#选择排序动图演示：" class="headerlink" title="选择排序动图演示："></a>选择排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-c6cc220cfb2b9ac8.gif?imageMogr2/auto-orient/strip" alt=""><br><br>Selection Sort 动图演示 算法可视化来源：<a href="http://visualgo.net/" target="_blank" rel="external">http://visualgo.net/</a>“<br></p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><h4 id="插入排序须知："><a href="#插入排序须知：" class="headerlink" title="插入排序须知："></a>插入排序须知：</h4><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了。。。<br><br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。对于这种算法，得了懒癌的我就套用教科书上的一句经典的话吧：感兴趣的同学可以在课后自行研究。。。<br></p>
<h4 id="插入排序动图演示："><a href="#插入排序动图演示：" class="headerlink" title="插入排序动图演示："></a>插入排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-d1537e355abdd298.gif?imageMogr2/auto-orient/strip" alt=""><br></p>
<h4 id="插入排序JavaScript代码实现："><a href="#插入排序JavaScript代码实现：" class="headerlink" title="插入排序JavaScript代码实现："></a>插入排序JavaScript代码实现：</h4><pre><code>function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
</code></pre><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><h4 id="希尔排序须知："><a href="#希尔排序须知：" class="headerlink" title="希尔排序须知："></a>希尔排序须知：</h4><p>希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。在这里，我就使用了这种方法。<br></p>
<h4 id="希尔排序JavaScript代码实现："><a href="#希尔排序JavaScript代码实现：" class="headerlink" title="希尔排序JavaScript代码实现："></a>希尔排序JavaScript代码实现：</h4><pre><code>function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while(gap &lt; len/3) {          //动态定义间隔序列
        gap =gap*3+1;
    }
    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
</code></pre><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><h4 id="归并排序须知："><a href="#归并排序须知：" class="headerlink" title="归并排序须知："></a>归并排序须知：</h4><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：<br></p>
<p>1.自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）<br><br>2.自下而上的迭代<br><br>在《数据结构与算法JavaScript描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：<br><br><code>However, it is not possible to do so in JavaScript, as the recursion goes too deep
for the language to handle.</code><br><br><code>然而,在 JavaScript 中这种方式不太可行,因为这个算法的递归深度对它来讲太深了。 &lt;br&gt;</code><br>更新：<br><br>在《JavaScript语言精粹》的第四章里提到了递归问题。对我之前的疑问进行了解答：<br><br><code>Some languages offer the tail recursion optimization. This means that if a function returns the result of invoking itself recursively, then the invocation is replaced with a loop, which can significantly speed things up. Unfortunately, JavaScript does not currently provide tail recursion optimization. Functions that recurse very deeply can fail by exhausting the return stack.</code><br><br><code>一些语言提供了尾递归优化。这意味着如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环，它可以显著提高速度。遗憾的是，JavaScript当前并没有提供尾递归优化。深度递归的函数可能会因为堆栈溢出而运行失败。</code><br><br>再次更新：<br><br>好消息！好消息！ES6已经添加了对尾递归优化的支持，妈妈再也不用担心我用JavaScript写递归了。不过，需要注意的是，ES6的尾递归优化只在严格模式下才会开启。这样规定的原因在阮一峰的《ECMAScript6 入门》里解释得很清楚：<br></p>
<pre><code>正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。
func.arguments：返回调用时函数的参数。
func.caller：返回调用当前函数的那个函数。
尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。
</code></pre><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。<br></p>
<h4 id="归并排序动图演示："><a href="#归并排序动图演示：" class="headerlink" title="归并排序动图演示："></a>归并排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-18c70f637b5c01c2.gif?imageMogr2/auto-orient/strip" alt=""><br><br>Merge Sort 动图演示 算法可视化来源：<a href="http://visualgo.net/" target="_blank" rel="external">http://visualgo.net/</a><br></p>
<h4 id="归并排序JavaScript代码实现："><a href="#归并排序JavaScript代码实现：" class="headerlink" title="归并排序JavaScript代码实现："></a>归并排序JavaScript代码实现：</h4><pre><code>function mergeSort(arr) {  //采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    var result = [];

    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}
</code></pre><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><h4 id="快速排序须知："><a href="#快速排序须知：" class="headerlink" title="快速排序须知："></a>快速排序须知：</h4><p>又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br><br>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。虽然Worst Case的时间复杂度达到了O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为O(n log n) 的排序算法表现要更好，可是这是为什么呢，我也不知道。。。好在我的强迫症又犯了，查了N多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：<br></p>
<pre><code>快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(n log n) ，且O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
</code></pre><p>更新：<br><br>《算法 第四版》里对于快速排序的优缺点进行了更加明确的解释：<br></p>
<pre><code>快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。
</code></pre><h4 id="快速排序动图演示："><a href="#快速排序动图演示：" class="headerlink" title="快速排序动图演示："></a>快速排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-cd65e35d7dce5045.gif?imageMogr2/auto-orient/strip" alt=""><br><br>Quick Sort 动图演示 算法可视化来源：<a href="http://visualgo.net/" target="_blank" rel="external">http://visualgo.net/</a><br></p>
<h4 id="快速排序JavaScript代码实现："><a href="#快速排序JavaScript代码实现：" class="headerlink" title="快速排序JavaScript代码实现："></a>快速排序JavaScript代码实现：</h4><pre><code>function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != &apos;number&apos; ? 0 : left,
        right = typeof right != &apos;number&apos; ? len - 1 : right;

    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}

function partition(arr, left ,right) {     //分区操作
    var pivot = left,                      //设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }        
    }
    swap(arr, pivot, index - 1);
    return index-1;
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><h4 id="堆排序须知："><a href="#堆排序须知：" class="headerlink" title="堆排序须知："></a>堆排序须知：</h4><p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：<br><br>1.大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列<br><br>2.小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列<br></p>
<h4 id="堆排序动图演示："><a href="#堆排序动图演示：" class="headerlink" title="堆排序动图演示："></a>堆排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-bf2472770e2258a9.gif?imageMogr2/auto-orient/strip" alt=""><br><br>Heap Sort 动图演示 算法可视化来源：<a href="http://www.ee.ryerson.ca/~courses/coe428/sorting/heapsort.html" target="_blank" rel="external">http://www.ee.ryerson.ca/~courses/coe428/sorting/heapsort.html</a><br></p>
<h4 id="堆排序JavaScript代码实现："><a href="#堆排序JavaScript代码实现：" class="headerlink" title="堆排序JavaScript代码实现："></a>堆排序JavaScript代码实现：</h4><pre><code>var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) {   //建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) {
        heapify(arr, i);
    }
}

function heapify(arr, i) {     //堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

function heapSort(arr) {
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
</code></pre><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><h4 id="计数排序须知："><a href="#计数排序须知：" class="headerlink" title="计数排序须知："></a>计数排序须知：</h4><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。<br><br>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br></p>
<h4 id="计数排序动图演示："><a href="#计数排序动图演示：" class="headerlink" title="计数排序动图演示："></a>计数排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-14067a57dd338fe3.gif?imageMogr2/auto-orient/strip" alt=""><br><br>Counting Sort 动图演示 算法可视化来源：<a href="http://visualgo.net/" target="_blank" rel="external">http://visualgo.net/</a><br></p>
<h4 id="计数排序JavaScript代码实现："><a href="#计数排序JavaScript代码实现：" class="headerlink" title="计数排序JavaScript代码实现："></a>计数排序JavaScript代码实现：</h4><pre><code>function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue+1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;

    for (var i = 0; i &lt; arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }

    for (var j = 0; j &lt; bucketLen; j++) {
        while(bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }

    return arr;
}
</code></pre><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><h4 id="桶排序须知："><a href="#桶排序须知：" class="headerlink" title="桶排序须知："></a>桶排序须知：</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br><br>为了使桶排序更加高效，我们需要做到这两点：<br><br>1.在额外空间充足的情况下，尽量增大桶的数量<br><br>2.使用的映射函数能够将输入的N个数据均匀的分配到K个桶中<br><br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<br></p>
<h4 id="什么时候最快（Best-Cases）：-1"><a href="#什么时候最快（Best-Cases）：-1" class="headerlink" title="什么时候最快（Best Cases）："></a>什么时候最快（Best Cases）：</h4><p>当输入的数据可以均匀的分配到每一个桶中<br></p>
<h4 id="什么时候最慢（Worst-Cases）：-1"><a href="#什么时候最慢（Worst-Cases）：-1" class="headerlink" title="什么时候最慢（Worst Cases）："></a>什么时候最慢（Worst Cases）：</h4><p>当输入的数据被分配到了同一个桶中<br></p>
<h4 id="桶排序JavaScript代码实现："><a href="#桶排序JavaScript代码实现：" class="headerlink" title="桶排序JavaScript代码实现："></a>桶排序JavaScript代码实现：</h4><pre><code>function bucketSort(arr, bucketSize) {
if (arr.length === 0) {
  return arr;
}

var i;
var minValue = arr[0];
var maxValue = arr[0];
for (i = 1; i &lt; arr.length; i++) {
  if (arr[i] &lt; minValue) {
      minValue = arr[i];                //输入数据的最小值
  } else if (arr[i] &gt; maxValue) {
      maxValue = arr[i];                //输入数据的最大值
  }
}

//桶的初始化
var DEFAULT_BUCKET_SIZE = 5;            //设置桶的默认数量为5
bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   
var buckets = new Array(bucketCount);
for (i = 0; i &lt; buckets.length; i++) {
    buckets[i] = [];
}

//利用映射函数将数据分配到各个桶中
for (i = 0; i &lt; arr.length; i++) {
    buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
}

arr.length = 0;
for (i = 0; i &lt; buckets.length; i++) {
    insertionSort(buckets[i]);                      //对每个桶进行排序，这里使用了插入排序
    for (var j = 0; j &lt; buckets[i].length; j++) {
        arr.push(buckets[i][j]);                      
    }
}    

    return arr;
}
</code></pre><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><h4 id="基数排序须知："><a href="#基数排序须知：" class="headerlink" title="基数排序须知："></a>基数排序须知：</h4><p>基数排序有两种方法：<br><br>1.MSD 从高位开始进行排序<br><br>2.LSD 从低位开始进行排序 <br></p>
<h4 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h4><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：<br><br>基数排序：根据键值的每位数字来分配桶<br><br>计数排序：每个桶只存储单一键值<br><br>桶排序：每个桶存储一定范围的数值<br></p>
<h4 id="LSD基数排序动图演示："><a href="#LSD基数排序动图演示：" class="headerlink" title="LSD基数排序动图演示："></a>LSD基数排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-54e33db459fca54f.gif?imageMogr2/auto-orient/strip" alt=""><br><br>Radix Sort 动图演示 算法可视化来源：<a href="http://visualgo.net/" target="_blank" rel="external">http://visualgo.net/</a><br></p>
<h4 id="基数排序JavaScript代码实现："><a href="#基数排序JavaScript代码实现：" class="headerlink" title="基数排序JavaScript代码实现："></a>基数排序JavaScript代码实现：</h4><pre><code>//LSD Radix Sort
var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j &lt; arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j &lt; counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}
</code></pre><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>排序算法实在是博大精深，还有hin多hin多我没有总结到或者我自己还没弄明白的算法，仅仅是总结这十种排序算法都把我写哭了。。。<br><br>因此，以后如果我掌握了更多的排序姿势，我一定还会回来的！<br></p>
<p>转自：<a href="http://www.jianshu.com/p/1b4068ccd505" target="_blank" rel="external">http://www.jianshu.com/p/1b4068ccd505</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/18/13/" itemprop="url">
                  【html】html特殊字符大全🍀
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-18T22:18:32+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来自: sugar<br><br>使用方法：<br><br>这些字符属于unicode字符集，所以，你的文档需要声明为UTF-8；下面符号列表的后面有两列编号，它们并不太一样，第一列是用于html的，你需要在前面加上&amp;#符号；第二列可以用于CSS文件中，但是需要用反斜杠\转义；第二列也可以用于javascript，和CSS用法一样，不过要用\u来转义。<br><br>需要主意的是： <br><br>有的字符在不同的浏览器下表现不太一样；比如小雪人 ☃ 在firefox和Chrome下不太一样，钻石 ◆ 在IE下要比Chrome下要大一点儿；有的字符在某个浏览器下不会显示；当然原因并不是字符代码的问题，而是浏览器的bug，比如，–在Chrome下。。。但是，98%的字符都能在所有浏览器下正常显示的，不过如果你真的要使用，最好仔细在各个浏览器下验证一番。经测试这些字符在Android/iOS等智能终端的识别度比较差，所以，使用的时候要特别注意移动浏览器～～ <br></p>
<h4 id="各种箭头"><a href="#各种箭头" class="headerlink" title="各种箭头"></a>各种箭头</h4><p>⇠ 8672 21E0<br><br>⇢ 8674 21E2<br><br>⇡ 8673 21E1<br><br>⇣ 8675 21E3<br><br>↞ 8606 219E<br><br>↠ 8608 21A0<br><br>↟ 8607 219F<br><br>↡ 8609 21A1<br><br>← 8592 2190<br><br>→ 8594 2192<br><br>↑ 8593 2191<br><br>↓ 8595 2193<br><br>↔ 8596 2194<br><br>↕ 8597 2195<br><br>⇄ 8644 21C4<br><br>⇅ 8645 21C5<br><br>↢ 8610 21A2<br><br>↣ 8611 21A3<br><br>⇞ 8670 21DE<br><br>⇟ 8671 21DF<br><br>↫ 8619 21AB<br><br>↬ 8620 21AC<br><br>⇜ 8668 21DC<br><br>⇝ 8669 21DD<br><br>↚ 8602 219A<br><br>↛ 8603 219B<br><br>↮ 8622 21AE<br><br>↭ 8621 21AD<br></p>
<h4 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h4><p>⇦ 8678 21E6<br><br>⇨ 8680 21E8<br><br>⇧ 8679 21E7<br><br>⇩ 8681 21E9<br><br>↷ 8631 21B7<br><br>↶ 8630 21B6<br><br>↻ 8635 21BB<br><br>↺ 8634 21BA<br><br>⟳ 10227 27F3<br><br>⟲ 10226 27F2<br><br>⟰ 10224 27F0<br><br>⟱ 10225 27F1<br><br>↵ 8629 21B5<br><br>↯ 8623 21AF<br><br>⇵ 8693 21F5<br></p>
<h4 id="向右的箭头"><a href="#向右的箭头" class="headerlink" title="向右的箭头"></a>向右的箭头</h4><p>➔ 10132 2794<br><br>➙ 10137 2799<br><br>➨ 10152 27A8<br><br>➲ 10162 27B2<br><br>➜ 10140 279C<br><br>➞ 10142 279E<br><br>➟ 10143 279F<br><br>➠ 10144 27A0<br><br>➤ 10148 27A4<br><br>➥ 10149 27A5<br><br>➦ 10150 27A6<br><br>➧ 10151 27A7<br><br>➵ 10165 27B5<br><br>➸ 10168 27B8<br><br>➼ 10172 27BC<br><br>➽ 10173 27BD<br><br>➺ 10170 27BA<br><br>➳ 10163 27B3<br><br>➾ 10174 27BE<br></p>
<h5 id="基本形状"><a href="#基本形状" class="headerlink" title="基本形状"></a>基本形状</h5><p>▲ 9650 25B2<br><br>► 9658 25BA<br><br>▼ 9660 25BC<br><br>◄ 9668 25C4<br><br>❤ 10084 2764<br><br>✈ 9992 2708<br><br>★ 9733 2605<br><br>✦ 10022 2726<br><br>☀ 9728 2600<br><br>◆ 9670 25C6<br><br>◈ 9672 25C8<br><br>▣ 9635 25A3<br></p>
<h4 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h4><p>« 171 00AB<br><br>» 187 00BB<br><br>‹ 139 008B<br><br>› 155 009B<br><br>“ 8220 201C<br><br>” 8221 201D<br><br>‘ 8216 2018<br><br>’ 8217 2019<br><br>• 8226 2022<br><br>◦ 9702 25E6<br><br>¡ 161 00A1<br><br>¿ 191 00BF<br><br>℅ 8453 2105<br><br>№ 8470 2116<br><br>&amp; 38 0026<br><br>@ 64 0040<br><br>℞ 8478 211E<br><br>℃ 8451 2103<br><br>℉ 8457 2109<br><br>° 176 00B0<br><br>| 124 007C<br><br>¦ 166 00A6<br><br>– 8211 2013<br><br>— 8212 2014<br><br>… 8230 2026<br><br>¶ 182 00B6<br><br>∼ 8764 223C<br><br>≠ 8800 2260<br></p>
<h4 id="法律符号"><a href="#法律符号" class="headerlink" title="法律符号"></a>法律符号</h4><p>® 174 00AE<br><br>© 169 00A9<br><br>℗ 8471 2117<br><br>™ 153 0099<br><br>℠ 8480 2120<br></p>
<h4 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h4><p>$ 36 0024<br><br>¢ 162 00A2<br><br>£ 163 00A3<br><br>¤ 164 00A4<br><br>€ 8364 20AC<br><br>¥ 165 00A5<br><br>₱ 8369 20B1<br><br>₹ 8377 20B9<br></p>
<h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>½ 189 00BD<br><br>¼ 188 00BC<br><br>¾ 190 00BE<br><br>⅓ 8531 2153<br><br>⅔ 8532 2154<br><br>⅛ 8539 215B<br><br>⅜ 8540 215C<br><br>⅝ 8541 215D<br><br>‰ 8240 2030<br><br>% 37 0025<br><br>&lt; 60 003C<br></p>
<blockquote>
<p>62 003E<br></p>
</blockquote>
<h4 id="音乐符号"><a href="#音乐符号" class="headerlink" title="音乐符号"></a>音乐符号</h4><p>♩ 9833 2669<br><br>♪ 9834 266A<br><br>♫ 9835 266B<br><br>♬ 9836 266C<br><br>♭ 9837 266D<br><br>♯ 9839 266F<br></p>
<h4 id="对号、错号"><a href="#对号、错号" class="headerlink" title="对号、错号"></a>对号、错号</h4><p>160 00A0<br><br>☐ 9744 2610<br><br>☑ 9745 2611<br><br>☒ 9746 2612<br><br>✓ 10003 2713<br><br>✔ 10004 2714<br><br>✕ 10005 10005<br><br>✖ 10006 2716<br><br>✗ 10007 2717<br><br>✘ 10008 2718<br></p>
<h4 id="十字"><a href="#十字" class="headerlink" title="十字"></a>十字</h4><p>☨ 9768 2628<br><br>☩ 9769 2629<br><br>✝ 10013 271D<br><br>✞ 10014 271E<br><br>✟ 10015 271F<br><br>✠ 10016 2720<br><br>✚ 10010 271A<br><br>† 8224 2020<br><br>✢ 10018 2722<br><br>✤ 10020 2724<br><br>✣ 10019 2723<br><br>✥ 10021 2725<br></p>
<h4 id="星星、星号、雪花"><a href="#星星、星号、雪花" class="headerlink" title="星星、星号、雪花"></a>星星、星号、雪花</h4><p>★ 9733 2605<br><br>✭ 10029 272D<br><br>✮ 10030 272E<br><br>☆ 9734 2606<br><br>✪ 10026 272A<br><br>✡ 10017 2721<br><br>✯ 10031 272F<br><br>✵ 10037 2735<br><br>✶ 10038 2736<br><br>✸ 10040 2738<br><br>✹ 10041 2739<br><br>✺ 10042 273A<br><br>✱ 10033 2731<br><br>✲ 10034 2732<br><br>✴ 10036 2734<br><br>✳ 10035 2733<br><br>✻ 10043 273B<br><br>✽ 10045 273D<br><br>❋ 10059 274B<br><br>❆ 10054 2746<br><br>❄ 10052 2744<br><br>❅ 10053 2745<br></p>
<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p>☻ 9787 263B<br><br>☺ 9786 263A<br><br>☹ 9785 2639<br><br>✉ 9993 2709<br><br>☎ 9742 260E<br><br>☏ 9743 260F<br><br>✆ 9990 2706<br><br>� 65533 FFFD<br><br>☁ 9729 2601<br><br>☂ 9730 2602<br><br>❄ 10052 2744<br><br>☃ 9731 2603<br><br>❈ 10056 2748<br><br>✿ 10047 273F<br><br>❀ 10048 2740<br><br>❁ 10049 2741<br><br>☘ 9752 2618<br><br>❦ 10086 2766<br><br>☕ 9749 9749<br><br>❂ 10050 2742<br><br>☥ 9765 2625<br><br>☮ 9774 262E<br><br>☯ 9775 262F<br><br>☪ 9770 262A<br><br>☤ 9764 2624<br><br>✄ 9988 2704<br><br>✂ 9986 2702<br><br>☸ 9784 2638<br><br>⚓ 9875 2693<br><br>☣ 9763 2623<br><br>⚠ 9888 26A0<br><br>⚡ 9889 26A1<br><br>☢ 9762 2622<br><br>♻ 9851 267B<br><br>♿ 9855 267F<br><br>☠ 9760 2620<br></p>
<h4 id="手型、铅笔、笔"><a href="#手型、铅笔、笔" class="headerlink" title="手型、铅笔、笔"></a>手型、铅笔、笔</h4><p>☜ 9756 261C<br><br>☞ 9758 261E<br><br>☝ 9757 261D<br><br>☟ 9759 261F<br><br>✌ 9996 270C<br><br>✍ 9997 270D<br><br>✎ 9998 270E<br><br>✐ 10000 2710<br><br>✏ 9999 270F<br><br>✑ 10001 2711<br><br>✒ 10002 2712<br></p>
<h4 id="天空、植物"><a href="#天空、植物" class="headerlink" title="天空、植物"></a>天空、植物</h4><p>☽ 9789 263D<br><br>☾ 9790 263E<br><br>♂ 9794 2642<br><br>♀ 9792 2640<br><br>☿ 9791 263F<br><br>♁ 9793 2641<br><br>♃ 9795 2643<br><br>♄ 9796 2644<br><br>♅ 9797 2645<br><br>♆ 9798 2646<br><br>♇ 9799 2647<br></p>
<h4 id="星座"><a href="#星座" class="headerlink" title="星座"></a>星座</h4><p>♈ 9800 2648<br><br>♉ 9801 2649<br><br>♊ 9802 264A<br><br>♋ 9803 264B<br><br>♌ 9804 264C<br><br>♍ 9805 264D<br><br>♎ 9806 264E<br><br>♏ 9807 264F<br><br>♑ 9809 2651<br><br>♒ 9810 2652<br><br>♓ 9811 2653<br></p>
<h4 id="象棋，扑克牌"><a href="#象棋，扑克牌" class="headerlink" title="象棋，扑克牌"></a>象棋，扑克牌</h4><p>♚ 9818 265A<br><br>♛ 9819 265B<br><br>♜ 9820 265C<br><br>♝ 9821 265D<br><br>♞ 9822 265E<br><br>♟ 9823 265F<br><br>♔ 9812 2654<br><br>♕ 9813 2655<br><br>♖ 9814 2656<br><br>♗ 9815 2657<br><br>♘ 9816 2658<br><br>♙ 9817 2659<br><br>♠ 9824 2660<br><br>♣ 9827 2663<br><br>♥ 9829 2665<br><br>♦ 9830 2666<br><br>♤ 9828 2664<br><br>♧ 9831 2667<br><br>♡ 9825 2661<br><br>♢ 9826 2662<br></p>
<h5 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h5><p>Α 913 0391<br><br>Β 914 0392<br><br>Γ 915 0393<br><br>Δ 916 0394<br><br>Ε 917 0395<br><br>Ζ 918 0396<br><br>Η 919 0397<br><br>Θ 920 0398<br><br>Ι 921 0399<br><br>Κ 922 039A<br><br>Λ 923 039B<br><br>Μ 924 039C<br><br>Ν 925 039D<br><br>Ξ 926 039E<br><br>Ο 927 039F<br><br>Π 928 03A0<br><br>Ρ 929 03A1<br><br>Σ 931 03A3<br><br>Τ 932 03A4<br><br>Υ 933 03A5<br><br>Φ 934 03A6<br><br>Χ 935 03A7<br><br>Ψ 936 03A8<br><br>Ω 937 03A9<br></p>
<p>转自：<a href="https://www.douban.com/group/topic/28046629/" target="_blank" rel="external">https://www.douban.com/group/topic/28046629/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/15/12/" itemprop="url">
                  布局教程：语法篇🎁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-15T21:13:47+08:00" content="2016-03-15">
              2016-03-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Flex-布局教程：语法篇"><a href="#Flex-布局教程：语法篇" class="headerlink" title="Flex 布局教程：语法篇"></a>Flex 布局教程：语法篇</h2><p>作者： 阮一峰<br><br>日期： 2015年7月10日<br><br>网页布局（layout）是CSS的一个重点应用。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt="layout"><br><br>布局的传统解决方案，基于盒状模型，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="external">display</a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="external">position</a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="external">float</a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="external">垂直居中</a>就不容易实现。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt=""><br><br>2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt=""><br><br>Flex布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的Flex写法。<br><br>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a>和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="external">A Visual Guide to CSS3 Flexbox Properties</a>。<br></p>
<h3 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br><br>任何一个容器都可以指定为Flex布局。<br></p>
<pre><code>.box{
  display: flex;
}
</code></pre><p>行内元素也可以使用Flex布局。<br></p>
<pre><code>.box{
  display: inline-flex;
}
</code></pre><p>Webkit内核的浏览器，必须加上<code>-webkit</code>前缀。<br></p>
<pre><code>.box{
  display: -webkit-flex; /* Safari */
  display: flex;
}
</code></pre><p>注意，设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。<br></p>
<h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt=""><br><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。<br></p>
<h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><p>以下6个属性设置在容器上。<br></p>
<pre><code>· flex-direction
· flex-wrap
· flex-flow
· justify-content
· align-items
· align-content
</code></pre><h4 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h4><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。<br></p>
<pre><code>.box {
  flex-direction: row | row-reverse | column | column-reverse;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt=""><br><br>它可能有4个值。<br></p>
<pre><code>· row（默认值）：主轴为水平方向，起点在左端。
· row-reverse：主轴为水平方向，起点在右端。
· column：主轴为垂直方向，起点在上沿。
· column-reverse：主轴为垂直方向，起点在下沿。
</code></pre><h4 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt=""><br></p>
<pre><code>.box{
      flex-wrap: nowrap | wrap | wrap-reverse;
}
</code></pre><p>它可能取三个值。<br><br>（1）<code>nowrap</code>（默认）：不换行。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt=""><br><br>（2）<code>wrap</code>：换行，第一行在上方。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt=""><br><br>（3）<code>wrap-reverse</code>：换行，第一行在下方。<br><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt=""><br></p>
<h4 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。<br></p>
<pre><code>.box {
  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
}
</code></pre><h4 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。<br></p>
<pre><code>.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt=""><br><br>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。<br></p>
<pre><code>· flex-start（默认值）：左对齐
· flex-end：右对齐
· center： 居中
· space-between：两端对齐，项目之间的间隔都相等。
· space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
</code></pre><h4 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h4><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。<br></p>
<pre><code>.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt=""><br><br>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。<br></p>
<pre><code>· flex-start：交叉轴的起点对齐。
· flex-end：交叉轴的终点对齐。
· center：交叉轴的中点对齐。
· baseline: 项目的第一行文字的基线对齐。
· stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
</code></pre><h4 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h4><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br></p>
<pre><code>.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt=""><br><br>该属性可能取6个值。<br></p>
<pre><code>· flex-start：与交叉轴的起点对齐。
· flex-end：与交叉轴的终点对齐。
· center：与交叉轴的中点对齐。
· space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
· space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
· stretch（默认值）：轴线占满整个交叉轴。
</code></pre><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。<br></p>
<pre><code>· order
· flex-grow
· flex-shrink
· flex-basis
· flex
· align-self
</code></pre><h4 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h4><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br></p>
<pre><code>.item {
  order: &lt;integer&gt;;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt=""><br></p>
<h4 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h4><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。<br></p>
<pre><code>.item {
  flex-grow: &lt;number&gt;; /* default 0 */
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt=""><br><br>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<br></p>
<h4 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h4><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br></p>
<pre><code>.item {
  flex-shrink: &lt;number&gt;; /* default 1 */
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt=""><br><br>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。<br><br>负值对该属性无效。<br></p>
<h4 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h4><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。<br></p>
<pre><code>.item {
  flex-basis: &lt;length&gt; | auto; /* default auto */
}
</code></pre><p>它可以设为跟<code>width</code>或`height属性一样的值（比如350px），则项目将占据固定空间。<br></p>
<h4 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h4><p><code>flex</code>属性是<code>flex-grow</code>,<code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。<br></p>
<pre><code>.item {
  flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]
}
</code></pre><p>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。<br><br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<br></p>
<h4 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h4><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。<br></p>
<pre><code>.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
</code></pre><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt=""><br><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。<br><br>（完）<br><br>转自：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a> </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/11/" itemprop="url">
                  CSS最佳实践——成为CSS忍者的十四步下😎
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-12T21:57:50+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言<br><br>继续上一篇的内容，本篇由@安生翻译分享。<br><br>正文从这开始~<br><br>下边的CSS最佳实践会帮助你掌握CSS，让你从专业人员过渡到CSS忍者。第二部分你会先学习到如何设置你的排版，然后掌握CSS类的命名约定。你还会学到模块化和DRY原则，最后你会找到如何解决CSS前缀问题的方法。<br></p>
<h3 id="第七条：一次性搞定排版"><a href="#第七条：一次性搞定排版" class="headerlink" title="第七条：一次性搞定排版"></a>第七条：一次性搞定排版</h3><p>这一条实践是关于排版的。经常阅读我博客的人可能知道我是个排版狂热爱好者。我相信排版是Web设计中最难的部分之一。学好它已经很难了，更别说掌握。数字化排版包含了很多细节，根据我的经验之谈，如果不清楚这些细节的话就没有办法设计得很好。<br><br>不管怎么说，掌握排版不是我们现在要探讨的问题。我写了篇文章<code>《crafting perfect web typography》</code>，如果你想深入了解网页排版的话可以阅读看看。对于CSS最佳实践，我们则是要坚持一条简单的规则，你应该一次性搞定好排版。不应该去覆盖你设过的默认排版风格。如果有特殊状况需要修改的话，修改一两次是可以接受的。<br></p>
<h4 id="有例外吗？"><a href="#有例外吗？" class="headerlink" title="有例外吗？"></a>有例外吗？</h4><p>那么什么时候可以不遵循这一条实践呢？我的回答是当你没有其他选择的时候。意思就是，假定你在设计一个博客，受Material design风格的影响可能会采用卡片布局，你可以通过这篇文章<code>《complete guide to Material design》</code>学习如何操作。由于每张卡片都是独立的模块，我们可以使用article元素来包装每张卡片的内容，内容包括标题、缩略图和文本。<br><br>每张卡片，或者说每篇文章，是页面中的一个包含独立内容的组件。理论上它们的内容之间是没有依赖关系的。换句话说，每张卡片都是不同的博文。因此我们可以给卡片的标题设置一个<code>h1</code>标签，通常情况下你应该只在一个页面中出现一个<code>h1</code>，但这只适合于充斥着div元素的旧HTML结构。<code>div</code>是没有语义的，所以当你在一个<code>div</code>中放入一个<code>h1</code>，它没有任何意义。<br><br>除此之外，它还会有些不同。简单地说，浏览器会将这个标题h1解释为<code>article</code>的一部分，而不是页面中的其他地方。所以如果你在这个页面中有五个<code>article</code>，理论上你可以有五个<code>h1</code>。因此我们就能给每张博文卡片的标题各设置一个<code>h1</code>了。这么并不会违背<code>HTML5</code>和其语义。但不好的一面是它可能会造成一个问题。<br></p>
<h4 id="有时候标题过大"><a href="#有时候标题过大" class="headerlink" title="有时候标题过大"></a>有时候标题过大</h4><p>我们经常在内容里划出一大块区域来定义标题。以一篇博文为例。即使是非常大的标题也是有足够的空间可以容纳的，假设你想让标题h1设为5.063rem（在font-size:16px的情况下），那么就是说标题的字体大小为80px，这对一篇博文来说是没有问题的，但如果它是在一张博文卡片里面呢？<br><br>这个标题大小会变得不成比例地大。那么有三种方案你可以采用。第一，改变全局的h1设置，代价是这个站点的每个页面都会受到影响。所有的标题都将小得多，这不是我们想要的。那么来看下其他的方案。<br><br>第二，改变标题标签。 没有人规定说博文卡片必须使用h1作为标题吧。当然从语义化的角度讲最好从<code>h1</code>的标题开始。但是使用<code>h2</code>、<code>h3</code>、<code>h4</code>甚至<code>h5</code>也是可以的。这种方案的好处在于不用重新定义全局排版设置了。因此也不会影响到站点里的其他页面。<br></p>
<h4 id="语义化，CSS最佳实践和例外"><a href="#语义化，CSS最佳实践和例外" class="headerlink" title="语义化，CSS最佳实践和例外"></a>语义化，CSS最佳实践和例外</h4><p>但当你又想语义化又想遵循CSS最佳实践时，你可以选择第三种方案。我们可以使用一条CSS样式覆盖博文卡片中标题所占据的空间。我会建议用一个特定的class来完成这件事。否则用元素选择器覆盖标题的话，如果有使用CSSLint则会出现警告。这个方案的坏处是我们会破坏掉另一条最佳实践。<br><br>和一两条实践起冲突也不是什么大事，而且当利大于弊时，破坏一两条实践也是件好事。首先你不用改变全局设置了，也就不用担心破坏其他页面的布局。其次你能使你的HTML保持语义化。所以当你用在线工具测试你的HTML代码时，测试会是通过的。<br></p>
<h4 id="遵循CSS最佳实践排版设置"><a href="#遵循CSS最佳实践排版设置" class="headerlink" title="遵循CSS最佳实践排版设置"></a>遵循CSS最佳实践排版设置</h4><p>把所有需要排版的元素给它们定义一个默认样式。你可以把这些样式赋在标题、段落、粗体、链接、列表等等。然后在理想状况下你就不需要再覆盖这些样式了，实现设计的一致性。<br></p>
<h3 id="第八条：使用描述性的类名"><a href="#第八条：使用描述性的类名" class="headerlink" title="第八条：使用描述性的类名"></a>第八条：使用描述性的类名</h3><p>这条最佳实践是要让你的CSS变得更清晰。清晰的意思就是有着更容易理解的类名。经常有些只有作者才能理解的CSS类名的例子。我做过很多项目，在极端情况下，没有前边开发者或者文档的帮助我是看不懂CSS的。这显然不是一个合理的方式。<br></p>
<h4 id="起些是人都可以明白的类名"><a href="#起些是人都可以明白的类名" class="headerlink" title="起些是人都可以明白的类名"></a>起些是人都可以明白的类名</h4><p>当你起一个CSS类名时你应该考虑下别人容不容易理解。一个好的class应该是看过去就能猜出大概来。而且明白什么时候应该使用和如何去使用。但也不是说你应该把每个小细节都描述出来。而是应该在不依赖文档和询问别人的情况下，这个CSS类名才算起得具有描述性。<br><br>比方你有一个样式化按钮的<code>class</code>，它应该带有像btn或者<code>button</code>的字符。许多框架都会用像<code>btn-primary</code>、<code>btn-secondary</code>、<code>btn-danger</code>、<code>btn-success</code>的类名。你就不需要知道关于框架或者开发者的额外信息了。而且你还能清楚使用这些按钮的场景。这同样适用于网站里的其他组件。你可以使用<code>.heading-big</code>、<code>.heading-small</code>、<code>.nav</code>、<code>.nav-primary</code>、<code>.nav-social</code>、<code>.link-active</code>、<code>.link-inactive</code>。<br><br>这些例子都有一个共同点，都能表明应该在什么场景下使用。我想你对<code>.btn-primary</code>、<code>nav-main</code>、<code>text-uppercase</code>不会使用不当。所有这些类名都很直观。即使你不懂英语只有一本字典，也可以理解得到大多数这些类名。<br></p>
<h4 id="不止是CSS最佳实践"><a href="#不止是CSS最佳实践" class="headerlink" title="不止是CSS最佳实践"></a>不止是CSS最佳实践</h4><p>如果你的类名外人不容易理解，你应该做出改变了。你需要把这条列入你的CSS最佳实践。不止是CSS，你写的任何代码都应该加上这条建议。如果你在JS，那么其他开发者应该不需要文档或者问你就能理解。测试的方法就是把你的代码给其他人看看，听听他们会怎么说。<br></p>
<h4 id="不要走极端"><a href="#不要走极端" class="headerlink" title="不要走极端"></a>不要走极端</h4><p>最后一点我想要说明的是不要走极端。对于描述性类名来说，在简洁和过细之间有一条边界。但要平衡好是不容易的事。一些类名像<code>.btn-danger</code>或者<code>.link-inactive</code>，只用了两个单词来描述；其他的类名可能需要三个或更多的单词，像<code>.progress-meter-text</code>、<code>.stacked-for-medium</code>、<code>.footer-button-to-top</code>。<br><br>找到边界的唯一途径就是实验。最好就是尝试不同的类名然后问下别人的建议。花点时间练习你就能拥有起个漂亮类名的技能。<br></p>
<h3 id="第九条：遵循一个命名约定"><a href="#第九条：遵循一个命名约定" class="headerlink" title="第九条：遵循一个命名约定"></a>第九条：遵循一个命名约定</h3><p>让我们再说点关于CSS类名的。CSS最佳实践的一个目标是让你的CSS变得可维护。可以通过命名约定来做到这点。上边我提过的类名都是用破折号来断字的，而没有出现过下划线的例子。而且所有例子都是小写，也都是元素后边跟着修饰词的结构(<code>.btn-primary</code>、<code>.nav-main</code>)。<br><br>所以这些让CSS变得可维护起来。这些特性让CSS可预测和可跟进。这样当别人加入你的团队就也能很快上手了。而且当坚持一种风格时，你也不用去时时查看别人的工作，不论她的技能如何或者对项目的熟悉程序。如果她遵循同一条命名规范，你们的CSS就会看起来没有区别。<br><br>即使你是独自工作的，遵循一种命名约定也是有用处的。你不用再想说应该用什么结构，用破折号还是下划线，用大写小写还是驼峰写法。只要你遵循一个命名约定并运用在你每个项目中，你就能空出一些时间来设计或者写代码来。<br></p>
<h3 id="第十条：使用BEM"><a href="#第十条：使用BEM" class="headerlink" title="第十条：使用BEM"></a>第十条：使用BEM</h3><p>使用BEM标记法可能看起来和CSS最佳实践没什么关系。但它还是和命名约定相关的。所以我简单地提及一下。BEM可以用来对CSS类名进行命名约定。<code>BEM</code>是<code>block</code>、<code>element</code>、<code>modifier</code>的缩写。它也使用了破折号和下划线。BEM旨在帮助开发者理解HTML和CSS之间的关系。<br><br>它是通过三个构建块和两个符号实现的。在<code>BEM</code>里，<code>block</code>是组件里的最高级别。可以是<code>.nav</code>、<code>sidebar</code>、<code>btn（navigation、sidebar、button）</code>。你可以认为这些块是父元素，之后就是子元素element了。这些元素采用父块名字加上两个下划线再加上子元素的名字。比如<code>.sidebar__list</code>、<code>.nav__link</code>、<code>.btn__icon</code>。<br><br>接着我们来解释下<code>modifier</code>。它在不改变组件本身的情况下改变<code>block</code>或者<code>element</code>的属性。换句话说，它允许你在不触及默认样式的情况下样式化组件。你需要做的就是在block和element后添加两个连字符。比如<code>.btn--primary</code>、<code>.list--inline</code>、<code>.icon--small</code>、<code>.heading--big</code>。这可能比较难理解。<br><br>你可以通过我这篇文章来了解<code>crash course on BEM》</code>。你可以掌握一切关于BEM的东西，或许之后你就会把这条CSS最佳实践列在执行之列。</p>
<h3 id="第十一条：让你的代码保持DRY"><a href="#第十一条：让你的代码保持DRY" class="headerlink" title="第十一条：让你的代码保持DRY"></a>第十一条：让你的代码保持DRY</h3><p>我想编程的人都听说过DRY这个缩略词。它是一条经验丰富的程序员给初学者的建议，因此它被列入CSS最佳实践里。DRY这个词是”Dont’t Repeat Yourself”（不要重复粘贴你的代码）的缩写。这很容易做到，这条实践的一点是还需要<code>定期重构</code>你的代码。也就是说通过浏览一遍你的代码然后找到你重复过的东西。<br><br>当你发现一些重复的代码，你应该把它变成可复用性的东西。在CSS中，你可以创建一个新的class然后把这些样式一并放入。然后你就不必经常重复写这些样式而是通过class来调取。当然这一条实践也有受限之处，你不用给那些只重复两三次的样式设置新class，不然都被类填满了，请看下一条吧。<br></p>
<h3 id="第十二条：模块化"><a href="#第十二条：模块化" class="headerlink" title="第十二条：模块化"></a>第十二条：模块化</h3><p>这是让你的CSS变得DRY又理性的方式。你应该把页面上的大部分元素看成一个模块或者组件。实际上这也是很多框架像Bootstrao和Foundation所遵循的。按钮、卡片、列表、模态、表格、提示信息，都是模块或者组件的例子。它们都有着一个关键特征，都是可复用的。列表、按钮或者模态的样式都不是局限在一个页面之中，你可以在任何地方使用它们。<br><br>这意味着你不用一次又一次地写相同的CSS代码。只要你使用正确的class你的工作便完成了。有许多方法可以模块化CSS。像SMACSS、OOCSS、ITCSS、Atomic design。大多数都很容易学习上手，有一些可能就难点。不同的方法可能适应不同的需求，所以没有说哪一种是最好的。<br><br>但我可以告诉你我最近使用哪一款。我用的是Atomic Design，我的博客读者可能知道这一点。我不久前写过这篇文章<code>《crash course on Atomic Design》</code>，如果你要使用这一款的话，这篇文章可以帮助你上手。无论使用哪种方法，你的目标都是减少你的CSS代码，从这个意义上说，模块化和DRY实践是一样的。<br></p>
<h3 id="第十三条：经常检查你的前缀"><a href="#第十三条：经常检查你的前缀" class="headerlink" title="第十三条：经常检查你的前缀"></a>第十三条：经常检查你的前缀</h3><p>你多久使用一次前缀？如果你经常尝试前沿的CSS技术，答案可能就是经常使用。那么你多久会检查一下这些前缀呢？前缀只是使用CSS最新特性的暂时性解决方案。一旦浏览器实现了一些特性，它们就会忽略掉关于这个特性的前缀。结果就是这前缀没有作用了。而且所有这些过时的前缀可能会影响到性能表现。<br><br>这不是说你应该停止使用前缀或者不使用前沿特性。这么做只会延缓这些特性的被采用。因为它们更少地被使用。因此为了促进这些特性的被录用我们应该使用它们。但这不能解决过时前缀带来的臃肿CSS，我们要做些什么呢？<br><br>你应该定期检查你的CSS然后移除那些没有用的前缀。但对于大项目来说可能就会变得很浪费时间。那么你就可能借助一些工具像autoprefixer或者prefix-free。这些工具不仅能给试验性CSS特性加上前缀，而且可以移除掉过时的前缀。自动化整个过程让CSS最佳实践执行起来更容易。<br></p>
<h3 id="第十四条：验证你的CSS"><a href="#第十四条：验证你的CSS" class="headerlink" title="第十四条：验证你的CSS"></a>第十四条：验证你的CSS</h3><p>最后一条非常简单，经常去校验你的CSS。CSS validator可以帮你不出错。而且CSS validator遵循W3C的规范。所以在你提交代码给客户或者老板之前先测试下。你的代码输出应该是有效且没有错误的。<br></p>
<h3 id="附一：你需要预处理器吗"><a href="#附一：你需要预处理器吗" class="headerlink" title="附一：你需要预处理器吗"></a>附一：你需要预处理器吗</h3><p>Sass，Less，PostCSS，你至少听过一种吧。CSS预处理器存在有一阵子了。许多开发者都在使用，我现在用着Sass。但我对PostCSS也很感兴趣。言归正传，我想说的是，你并不需要预处理器。<br><br>人们经常热衷于问说什么预处理器对Web设计来说是最好的。使用Sass，Stylus还是Less或者PostCSS？在回答之前，我们需要认清一件事，你对CSS的了解有多少，许多人想通过掌握预处理器而去取代掌握好CSS。你会想在学会开车之前先去开赛车吗?<br><br>假设你知道怎么使用踏板、方向盘和启动引擎，你会直接上跑道去开赛车吗？你可能开不到太远或者直接挂掉。那么对CSS来说也是如此，不要误会我的意思，我喜欢预处理器，它很强大，能改善你的工作流程和提高工作效率。<br></p>
<h4 id="能力越大，责任越大"><a href="#能力越大，责任越大" class="headerlink" title="能力越大，责任越大"></a>能力越大，责任越大</h4><p>能力伴随着责任。当你不大清楚CSS的基础时，你的代码可能写得不大好。当你添加了预处理器那么代码的糟糕性会有指数倍上升的危险。最简单普遍的例子来解释预处理器的强大就是嵌套。在纯CSS里，你不能嵌套选择器，你只能连续使用多个选择器来实现。但如果你用预处理器的话就很容易实现。<br><br>我看过有人嵌套超过五层，结果可能就像是<code>html .wrapper header .nav li a {...}</code>，问题就是当你用预处理器的时候你是意识不到这一点的。所以经常会很极端地去嵌套。这就是一个预处理器为何会失去控制的一个例子。所以我想在使用预处理器之前，你应该先好好地掌握CSS。<br></p>
<h4 id="你真的需要一个预处理器吗？"><a href="#你真的需要一个预处理器吗？" class="headerlink" title="你真的需要一个预处理器吗？"></a>你真的需要一个预处理器吗？</h4><p>让我们回到开头的问题，你真的需要使用预处理器吗？我的回答是不需要。如果你不想的话完全可以不用。这是自愿的选择，和你的技能水平没有任何关系。如果你没有使用也不用觉得尴尬。我身边很多很棒的Web开发者都用的纯CSS。无论你用了多少预处理器，你都达不到他们的水平。<br><br>我想这个问题可以引申到其他工具。你是不是会经常问别人用什么工具去做一件什么事最好？这些问题的初衷是什么？是我们想要找到一样可以把我们的技能提升10倍的工具吗？如果是这样的话那么妄想。能力不取决于工具，如果你会画画，无论你是用钢笔，铅笔，刷子还是棍子都一样。这些工具不会提升或者削弱你的技能。<br><br>你可能需要时间来适应你的新工具。假设你从使用PS到换成sketch，那么你开头可能运用地不是很好，但是这并不会让你的技能变糟糕。你只是还没适应这个新工具。当你知道怎么操作，你的技能依旧摆在那里。明白了你的能力和工具是没有关系的话，你就不用纠结于是否一定要去使用预处理器了。<br><br>如果你的CSS不好，预处理器并不能拯救你，如果你是CSS大神，不使用预处理器也不会让你变得不强大，所以你没有必要使用预处理器。<br></p>
<h3 id="附二：你应该lint吗？"><a href="#附二：你应该lint吗？" class="headerlink" title="附二：你应该lint吗？"></a>附二：你应该lint吗？</h3><p>这也是一个一直受到热议的问题。在这篇文章里我们将只讨论CSS和JS。赞成的人说它会让你的代码更简洁和更少漏洞。反对的人则说它的规则太严格约束了。是的当你想要使用某种工具时你必须受限于它的规则。但是这些规则有多严格取决于两个因素。<br></p>
<h4 id="你要记住的两个因素"><a href="#你要记住的两个因素" class="headerlink" title="你要记住的两个因素"></a>你要记住的两个因素</h4><p>第一个是你要运用的是哪种工具。假设是JS，现在有JSLint，JSHint,ESLint。JSLint是最老牌和最严格的，它的好处是它已配置好，你可以立刻上手。坏处是你不能改变它的配置。所以如果你不喜欢某条规则的话，你只能适应它或者换别的工具。<br><br>JSHint和ESLint允许你自定义。因此你可以讨厌某条规则，你只需要创建个性化的配置来使用。对于CSSLint来说也是如此，你可以随意改变规则，遵循定制化的CSS最佳实践。<br><br>第二个因素决定规则有多严格的是你自己。只有你可以决定你要跟进多严格的规则。当然有些工具不允许你自行配置，那么你可以不使用它们，它们可以互相取代的。如果不行你可以自己造轮子嘛。<br></p>
<h4 id="我们回答错问题了吗？"><a href="#我们回答错问题了吗？" class="headerlink" title="我们回答错问题了吗？"></a>我们回答错问题了吗？</h4><p>我想我们回答错问题了。我们不应该讨论使用代码检测是好还是坏。它只是一条CSS最佳实践。我们应该问的是我们是否理解了这些规则。检测你的代码和改正错误或者警告是一件事，另一件事是要明白为什么这些改变是有用的。当你决定去改变一些东西的时，你应该知道你为什么要这样做，这很重要。<br><br>这就是为什么我不能站在任何一边的原因。我不认为他们指向了问题的正确所在。他们试图找到方法来编写简洁的代码，但问题并不在于混乱或是错误的代码，而是知识。想想为什么你经常犯错，这发生在你对它认识不深的状况下。<br><br>诚然它可以让代码变得简洁和零失误，但不会告诉你为什么。这就是我们需要关注的问题所在。我经常鼓励开发者使用lint，但是这是在他们经常会去弄清为什么那些代码会抛出错误的情况下。不然的话就没有意义了。我的意思就是说这样你学不到任何东西，你可能记住了这些规则，但和完全理解它是不同的。<br></p>
<h4 id="所以，你需要lint吗？"><a href="#所以，你需要lint吗？" class="headerlink" title="所以，你需要lint吗？"></a>所以，你需要lint吗？</h4><p>你应该有能力去判断你是否应该改变你的代码。所以我对这个问题的回答是肯定的。用它来校验你的代码可能可以保持一个很好的状态。但你需要知道你为什么要遵循这些规则。对于这些CSS最佳实践来说都是如此，首先你要明白为什么，清楚它们的背景，然后你就可以自行决定了。在你可以理解的范围内它就是好的。<br></p>
<h4 id="不要想CSS最佳实践了"><a href="#不要想CSS最佳实践了" class="headerlink" title="不要想CSS最佳实践了"></a>不要想CSS最佳实践了</h4><p>我希望这十四条实践对你有所帮助。CSS有很多可说的，我选择了可以帮你解决重大困惑和让你的CSS看起来更佳的实践。最后我要说的是，你自己决定要选择哪些CSS最佳实践吧，CSS可以是美妙的。<br><br>最后<br><br>@安生曾经分享过的文章：<br><br>【第526期】提高你的Javascript水平<br><br>【第730期】提升你的CSS<br><br></p>
<p>关于本文<br><br>译者：@安生<br><br>原文：<a href="http://blog.alexdevero.com/css-best-practices-become-css-ninja-pt2/" target="_blank" rel="external">http://blog.alexdevero.com/css-best-practices-become-css-ninja-pt2/</a><br><br>转自：前端早读课</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/10/10/" itemprop="url">
                  CSS最佳实践——成为CSS忍者的十四步上😎
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-10T22:08:59+08:00" content="2016-03-10">
              2016-03-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言<br><br>本文来自@安生的翻译分享。本文有两篇，本文是上，下篇在第二条。<br><br>正文从这开始~<br><br>就算是专业的Web开发者，可能也很难管理好CSS。在这个系列里，你将了解十四条关于CSS的最佳实践。在第一部分，你将学习如何掌握CSS特殊的层次结构，你会发现!important声明和ID选择器的危险，也会学习到过高优先级选择器带来的代价，最后你还会学习如何规避浏览器带来的不一致性。让我们开始学习吧。<br></p>
<h3 id="第一条：掌握CSS特殊的层次结构"><a href="#第一条：掌握CSS特殊的层次结构" class="headerlink" title="第一条：掌握CSS特殊的层次结构"></a>第一条：掌握CSS特殊的层次结构</h3><p>让我们从最艰难的一步开始。如果你想要成为一个CSS忍者，那么这是你必须掌握的，即便你不想成为忍者，也至少应该了解它。如果你只是想在同事朋友面前吹嘘一下，那么这块知识你一定要懂。有大量的人自称他们是Web开发者或者Web设计人员。<br></p>
<h4 id="经常被忽略的基础知识"><a href="#经常被忽略的基础知识" class="headerlink" title="经常被忽略的基础知识"></a>经常被忽略的基础知识</h4><p>有趣的是，很多人对这个话题一无所知。这些人搭建了网站或者Web应用却不知道CSS是怎么工作的。他们知道一些层叠的知识，或者浏览器如何阅读选择器的（从右到左）。想象一下你认识一个对汽车的认知还不错的人，但你会让这个人给你造一辆车吗？恐怕不会。<br><br>不过如果你需要让人给你搭一个网站，你就需要寻找一个专业人士了。如果你同意我的话，那么真正专业的人士是会想去掌握好他的手艺的人。这种人会着迷于任何一个细节。如果CSS层次就是其中一个细节呢？或者是一个CSS最佳实践呢？那么，忽略这个细节的人就不能称之为专业人士了。<br><br>如果你想变得专业，你必须学习它，而如果你想成为忍者，你必须掌握它。你需要了解CSS的任何一个特性。当一个小孩问你，你需要能解释得出来，虽然不太可能发生。当然，你潜在的客户或者老板可能会问你关于这方面的东西。这个话题就是一个测试知识点的很好方式。<br><br>正如讨论过的，很多开发者对CSS特殊的层次结构知之甚少。因此这个问题可以说是帮助雇主们用来找到人才的好方法。若在网上向自由职业者提出这个问题，有多少人能够回答呢?<br></p>
<h4 id="CSS特殊层次结构的困难之处"><a href="#CSS特殊层次结构的困难之处" class="headerlink" title="CSS特殊层次结构的困难之处"></a>CSS特殊层次结构的困难之处</h4><p>那么既然它如此重要，为什么它是CSS最容易被忽略的部分之一呢，而且为什么极少的CSS实践中会提及到？大概是因为你可能需要做一些数学运算。在这个层次结构中，每个CSS选择器都有一些特定的值。而且当你组合起选择器时，这些值会增加。因此简单的元素选择器（如a）比两个元素的选择器（如a span）的层次低。<br><br>通配符选择器它的值是最低的，几乎等于零。可以说所有的选择器都优先于它。排在后面的是元素选择器，它的值是1。然后是带有伪元素的元素，这个结合起来值是2。一直如此下去。最高值是元素选择器、ID选择器、class选择器再加上一个元素选择器的组合，这个组合的值是112。一个ID选择器的值差不多就是100了。（这段不大懂得话详见下表）<br><br>这里提供一个CSS特殊层次结构的概述。下边有个简单的表格可以帮助你快速找到层次，不用你自己去计算。如果你想要更深入了解的话，可以参考下这篇我写的短文，不然你经常会需要回看这个表格。<br><br>CSS层次特性表：<br><br><img src="http://a2.qpic.cn/psb?/V12O5OuB1fjn3R/LyIkiF92nnogXNG62c8tUquRfsd029l889uz6SV8I1Q!/b/dAkBAAAAAAAA&amp;bo=fgKTAQAAAAADB8w!&amp;rf=viewer_4" alt=""><br></p>
<h3 id="第二条：避免使用-important声明"><a href="#第二条：避免使用-important声明" class="headerlink" title="第二条：避免使用!important声明"></a>第二条：避免使用!important声明</h3><p>第二条实践和层次结构也有关系。接下来两条也是如此。我希望这会让你知道特殊的层次结构的重要性。言归正传，这条实践就是永远不要使用!improtant声明。为什么我会把杜绝!improtant放在CSS的最佳实践里呢。原因是因为它会导致你不能避免的恶性循环。<br></p>
<h4 id="惹祸上身"><a href="#惹祸上身" class="headerlink" title="惹祸上身"></a>惹祸上身</h4><p>想象下你和一个用!improtant声明的人工作在一块。你不得不再次用!imprtant声明来覆盖样式。你能怎么办呢？你有几个方案可供选择。第一你可以冒险移除你同事用的!improtant声明，后果是可能会破坏掉一些东西，你需要测试保证移除完所有东西依旧运行良好。但是这会花费很多时间。那么需要考虑下值不值得这样去做。第二个选择是运用你的CSS层次结构知识。解决这个声明的办法就是提高选择器的层级。假设你的同事是用一个span元素加上一个类名，这意味着你需要的是比一个class选择器更高的级别，这个值是10。你可以有几种选择实现。第一种是用两个元素选择器和一个class选择器。第二种是用一个ID选择器。第三种是元素选择器+ID选择器+类选择器+元素选择器。但你在接下来会认识到用ID不是CSS的最佳实践，所以你会排除这个选项，所以这意味着你不得不用两个元素选择器加上一个类选择器，否则你会违背其他的CSS最佳实践。<br></p>
<h4 id="解决-improtant问题"><a href="#解决-improtant问题" class="headerlink" title="解决!improtant问题"></a>解决!improtant问题</h4><p>我所举的例子可能看起来不算什么大问题。但当发现你不得不再次覆盖!improtant时会发生什么状况？这就是使用improtant的问题所在。前一个总是会传染给下一个。这就是我所说的恶性循环。你用了一个!important后很快你会不得已使用另一个。所以我相信唯一的解决办法就是不要使用!improtant。<br><br>处理这个声明的方式类似于对待毒品。最好的办法就是坚持CSS最佳实践然后永远不要起这个头。否则就是自找麻烦。这也是我鼓励你使用 CSSlinter的原因。因为你可能很容易又会忘了这条实践。所以使用一些工具来测试你的代码是有效良好的。而且如果你使用Gulp，你可以使用<code>gulp-csslint</code>或者<code>gulp-sass-lint</code>，只要力所能及都应该实现自动化。<br></p>
<h3 id="第三条：不要使用ID"><a href="#第三条：不要使用ID" class="headerlink" title="第三条：不要使用ID"></a>第三条：不要使用ID</h3><p>样式化元素时千万不要用ID。为什么说它属于CSS最佳实践呢？第一，ID是不可复用的，你只能在一个页面中用一个特定的ID元素。所以如果你想要在同一个页面样式化更多的元素，你需要使用更多的ID和更多行的CSS。第二，这是恶性循环的开始，我又要扯到CSS层次结构了。我们在前边的!improtant中有提到这个。第三，对于ID的争议是它通常用来指特定的元素，那么你就不可能让你的CSS变得简短又可复用。让样式太过特制化不是个好主意。相反的你应该让样式更具抽象和通用性。这可以帮助你重复地使用同一个样式。如果你在每个页面都用了超过一个特定的ID，那么可复用的CSS这个目标就不可能实现。<br></p>
<h4 id="那么性能呢？"><a href="#那么性能呢？" class="headerlink" title="那么性能呢？"></a>那么性能呢？</h4><p>确实ID选择器的运行速度比class选择器要快。如果你定义了1000条规则，ID的性能会快<code>一毫秒</code>。这是在你只在一个页面定义了一个ID选择器的情况下发生的，所以这并不是什么显著的性能优势。而且你只有在至少定义了1000规则之后才能获得这个优势，对于小项目来说这通常是一个还蛮大的数字。<br><br>我们还必须考虑的另一件事是额外的ID选择器会带来什么性能影响。==理论上当你添加任何ID选择器时，性能优势其实已经没有了。==而且如果你想获得任何性能优势的话，你不能在ID后边添加其他选择器。如果添加了像class或者元素选择器会发生什么呢？浏览器会从右到左阅读CSS，这意味着后边添加的选择器会首先被读取到，ID的速度优势也就被冲击掉了。<br><br>结论就是性能提升的唯一途径必须通过纯ID的选择器。同时你需要有足够多的CSS规则让优势显现。既然1000条规则可以有一毫秒的优势，那么你应该把目标放在100,000条规则上。这个大概可以给到100毫秒的优势。另外的事就是浏览器扫描渲染这么多CSS规则需要的时间。所以你应该避免使用ID为妙。<br></p>
<h4 id="什么时候适合使用ID"><a href="#什么时候适合使用ID" class="headerlink" title="什么时候适合使用ID"></a>什么时候适合使用ID</h4><p>在进入下一条实践前我先再说多一点。我是主张从你的CSS或者SASS中摆脱掉ID，但这不意味着你需要完全地从HTML标记中移除掉它。ID有一个具体的用例，就是使用到JS。正如讨论过的ID更快，所以能用来提升你的JS速度，同样的JS有个getElementByID()方法。<br><br>这个方法用来获取带有ID的元素，你可以使用ID作为唯一标识符来赋给需要额外功能的元素。这样做的另一个好处就是分离CSS和JS。当你从一个元素中去掉class时，你不用担心会破坏掉JS。所有你的JS只需要关联到ID即可。但是我还是想说我并不喜欢使用ID。<br><br>当我用到JS绑定时，我会使用带有”js-“前缀的class。这帮我区分哪些类是用于样式哪些是用于JS。现在我只会在一种状况下使用JS，在通过href属性给页面中某个元素绑定锚标记的时候。这样用户点击锚标记时页面会滚动到特定的区域。除了这个例子我不认为其他地方有需要使用到ID。<br></p>
<h3 id="第四条：避免层次过高的元素"><a href="#第四条：避免层次过高的元素" class="headerlink" title="第四条：避免层次过高的元素"></a>第四条：避免层次过高的元素</h3><p>我保证这是最后一条关于CSS层次结构的最佳实践。层次过高的元素是什么意思？就是你给一个元素赋予了过多复杂的选择器。假设你想要一个锚标记表现得像一个按钮，符合最佳实践的做法是使用像btn类的东西，你的CSS或者SASS样式表可能就会包含像.btn {…}的代码。<br><br>当你使用了这个选择器，可能就会有类似a.btn{…}的代码，更极端点之后会变成a.btn.btn-big.btn-primary{…}。重点就是使用元素选择器变得没有必要。这同样适用于其他附加的类。你完全可以只用.btn类。所以避免使用层次过高的选择器可以有三个理由，一是你会想压缩的CSS大小写更少的CSS，和你要想要提高选择器的性能。<br></p>
<h4 id="使用层次过高的元素的问题"><a href="#使用层次过高的元素的问题" class="headerlink" title="使用层次过高的元素的问题"></a>使用层次过高的元素的问题</h4><p>我多次提到浏览器阅读CSS是从右到左。同时浏览器也在选择位于每个选择器后的元素。比如<code>aricle h1{...}</code>，浏览器会先寻找所有h1标签，然后寻找所有内嵌在article标签里的h1标签。那么按钮的例子呢，浏览器会先寻找带有<code>.btn-primary</code>的元素，然后是同时带有<code>.btn-primary</code>和<code>.btn-big</code>的元素。<code>a</code>和<code>.btn</code>选择器同理。<br><br>综上所述，浏览器需要四个周期来呈现一个按钮。这高效得了吗？想象下你为了买些小东西会跑四趟超市吗？你当然会一次性买齐所有的吧。因此浏览器若在一个周期内完成，按钮的渲染才不会浪费时间。<br><br>网站变得更快可以提升用户体验，避免层次过高的元素会让浏览器渲染CSS更快些。更快的CSS渲染意味着你的站点会加载得更快。这就是你的目标。所以避开层级过高的元素意味着实现良好的用户体验。<br></p>
<h3 id="第五条：reset还是normalize"><a href="#第五条：reset还是normalize" class="headerlink" title="第五条：reset还是normalize"></a>第五条：reset还是normalize</h3><p>思考下这个问题，当你开始一个新项目，你会先重置所有的元素的默认样式吗？如果没有的话我建议你把这部分加入你的工作流程里去。为什么呢？不同的浏览器会试图以不同的方式渲染一些CSS样式。这导致了或大或小的不一致设计。结果就是你的网站在Chrome，Firefox，Edge都会看起来有点不一样。试想下当你在客户端打开你的站点时发现布局乱套了。<br><br>你可以通过让浏览器渲染一致来解决这个问题。有两件事是你可以做的，一，自己手动重置所有元素，这可能会花费一些时间。如果每个项目都这样，可能并不高效。那么第二种方式就是使用预制的CSS样式表，把重置的样式表放在你主要的样式表前边即可。<br></p>
<h4 id="reset还是normalize"><a href="#reset还是normalize" class="headerlink" title="reset还是normalize"></a>reset还是normalize</h4><p>当你选择第二种方式时，你需要考虑多一件事。你会采用哪种样式表来使浏览器呈现一致？目前有两种样式表可选，Nicolas Gallagher和Jonathan Neal写的<code>Normalize</code>或Eric A. Meyer写的<code>Reset</code>。<br><br>这两种样式表是不同的，它们遵循不同的方法来移除浏览器的不一致性。Normalize只着眼于常规正确的样式；同时旨在保留默认样式，没有完全移除它们。它包含了一些小的修正来提高可用性。它也相对来说更模块化些，你可以提取或删除你不需要的部分。<br><br>Reset样式表则不太一样。它通过移除所有的样式来达成同质化的视觉样式，给几乎所有元素设定了广泛性的默认样式。它除去了所有的样式像粗体斜体等等。结果就是<code>strong</code>、<code>em</code>、<code>span</code>看起来都差不多。从这个角度讲，reset就像一个大锤子，normalize则像一把手术刀。reset坚决地重置所有东西，normalize则是重置需要重置的。<br><br>因此这些样式表的代码和文件大小也是不同的。当然这些区别并不是很重要，但是它们是确实存在的。不管怎样，你应该选择哪个呢？看你更喜欢哪种方式了。如果你想要一个彻彻底底的重置，就选择reset。如果不需要那么极端的话就选择normalize。别忘了在normalize里添上些可用性的改进。我个人是偏爱Normalize的。<br></p>
<h3 id="第六条：别重置所有东西"><a href="#第六条：别重置所有东西" class="headerlink" title="第六条：别重置所有东西"></a>第六条：别重置所有东西</h3><p>假定你同意重置了，但不要急于下载运行。这并不和上一条矛盾。你需要考虑清楚你是不是真的需要这个东西。无论是normalize还是reset，都包含了大量你可能不会运用到你的项目里的元素。因此没有必要让这个代码扩大你的CSS。<br><br>我的建议同时也是CSS最佳实践的第六条，是去定制预制的样式表。你需要选择你会用到的样式。当然，少数的额外几行CSS并不会对性能或者文件大小有什么太大影响。但是这不代表你可以浪费资源。如果想要用户体验良好，你需要利用一切机会去优化你的网站，这就是其中一个。<br><br>要记得所有这些样式表是会在很多种不同状况下工作的，这意味着你项目中一半的代码是没有用的。同时你个人的编码风格可能会覆盖掉一些这样的代码，这些重复性的东西是可以删除的。另一个解剖和定制样式表的原因是能得到更好地理解，当你分离reset或者normalize时，你可以清楚看到原本是什么东西。<br><br>结果就是你会知道它们是怎么工作的。这些样式表是由专业的Web开发者维护的。光是阅读源码和进行运用你就可以学习到很多东西。也可能帮助你找到更适合自己的样式表。<br></p>
<h4 id="不要想CSS最佳实践了"><a href="#不要想CSS最佳实践了" class="headerlink" title="不要想CSS最佳实践了"></a>不要想CSS最佳实践了</h4><p>这就是今天我带给你的所有CSS最佳实践。我相信这六条会帮助你提升你的CSS代码。让我们快速回顾一下，第一，掌握CSS特殊的层次结构。这是CSS经常被忽略的一部分。但是你能看到今天许多最佳实践都和它有关。第二，避免使用improtant声明，同时不要使用ID进行样式书写。这两件事可以避免恶性循环。<br><br>之后是避免层级过高的元素。它会让浏览器执行过多渲染你样式的不必要周期。这会降低性能和带来不佳的用户体验。最后是使用reset或者normalize样式表来避免浏览器的不一致。但要确保根据你具体的状况来量身定制。不然的话就会让你的CSS变得冗杂。<br><br><br>关于本文<br><br>译者：@安生<br><br>原文：<a href="http://blog.alexdevero.com/css-best-practices-become-css-ninja-pt1/" target="_blank" rel="external">http://blog.alexdevero.com/css-best-practices-become-css-ninja-pt1/</a><br></p>
<p>转自：前端早读课</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/02/9/" itemprop="url">
                  Web前端技术栈🐥
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-02T20:48:50+08:00" content="2016-03-02">
              2016-03-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自<a href="http://www.haonanji.cn/230.html" target="_blank" rel="external">http://www.haonanji.cn/230.html</a><br></p>
<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p>本文把整个web前端开发所需要的知识都之中在一个视图中，形成一个完整的web前端知识体系，目的是想要颠覆人们对于前端只有三大块（html、css、js）的认识——做web前端需要的比这三大块要多得多。<br>　　在看内容之前，先看一下这个知识框架的预览图。图太大不好展示，看不清除，可在此下载清晰版：<a href="http://pan.baidu.com/s/1hqIUvUc" target="_blank" rel="external">http://pan.baidu.com/s/1hqIUvUc</a>（内有整个知识体系的图片和xmind文件）。<br><br>　　<img src="http://images0.cnblogs.com/blog2015/138012/201507/160850143914776.png" alt=""><br><br></p>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><p>所有知识框架，那肯定是一个结构型的展现，就是一棵树。web前端的知识点非常多，也非常散，需要好几层结构来组织这个体系，否则就会显得很乱。那么如何组织、把谁和谁放在一块儿？这是真正值得我们去思考的，你也可以自己来思考一下这个问题。<br>在我总结的这个知识框架中，首先第一层我划分为：<strong>理论知识</strong>，<strong>类库框架</strong>，<strong>编码开发</strong>，<strong>运行环境</strong>。如下图：<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152119217207735.png" alt=""><br><br>接下来给大家解释一下:<br><br>这个图要<strong>从下往上</strong>看，为何？——因为下面是上面的基础；<br></p>
<ul>
<li>首先，我们需要一定的理论知识，不管是你听别人讲授、自己看书还是网上淘资料，你都需要一定的理论知识，每一种程序开发，都避免不了。</li>
<li>第二，有了这些理论知识我们就可以编码了——不错——but，没有人能抵挡住第三方框架和类库的诱惑，例如jquery；</li>
<li>第三，有了这些理论知识和协助我们的类库框架，我们就可真正的编码了。大家可能以为编码开发不就是写代码吗，还有啥？——这里面道道多着呢；</li>
<li>最后，开发程序的目的，最终是为了能高效、稳定的运行在相应的环境中，这其中又有哪些事情需要我们去做？请期待；</li>
</ul>
<h4 id="3-理论知识-包括“软知识”和“硬知识”"><a href="#3-理论知识-包括“软知识”和“硬知识”" class="headerlink" title="3. 理论知识 包括“软知识”和“硬知识”"></a>3. 理论知识 包括“软知识”和“硬知识”</h4><p>“软知识”和“硬知识”大家可能觉得词陌生，其实我一说大家就能明白。<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152129259385742.png" alt=""><br></p>
<ul>
<li>所谓“软”的就是能在各个程序开发中都用到的，算是基本功、内功，例如数据结构、算法、设计模式、面向对象等等；</li>
<li>所谓“硬”的就是能直接用于本程序开发的。用C语言你就得学C语言语法，此时学java没用。我们web前端开发所需要的硬知识其实都包含在三个标准里面：<strong>http标准、W3C标准和ECMAScript标准</strong>；</li>
</ul>
<h4 id="4-1-http标准"><a href="#4-1-http标准" class="headerlink" title="4.1 http标准"></a>4.1 http标准</h4><p>为什么做web前端要了解http标准？——因为浏览器要从服务端获取网页，网页也可能将信息再提交给服务器，这其中都有http的连接。web系统既然和http链接有瓜葛，你就必须去了解它。<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152135018295393.png" alt=""><br><br>　我的意见是：你不必去非常了解http的详细内容，但是你要了解web前端开发常用的一些http的知识——就是上图中我列出来的那些。当然，我知识列了一个纲，详细内容还得靠你自己去查阅（本文章讲的是知识框架，不会涉及任何知识点的详细内容）<br><br>　关于这方面的知识，建议去查阅《图解http》这本书，浅显易懂的讲述了这些内容，我曾经也看过。<br></p>
<h4 id="4-2-W3C标准"><a href="#4-2-W3C标准" class="headerlink" title="4.2 W3C标准"></a>4.2 W3C标准</h4><p>如果说你只知道web前端的一个标准，估计肯定是W3C标准了（据我了解，貌似大部分人真的都只知道这一个标准）。它的内容非常多，看看<code>www.w3.org/TR/</code>这个页面。<br><br>写到这里让我想起了一句话：<code>2/8原则——20%的功能满足80%的需求</code>。我觉得这句话用到这里非常合适，我们在平时开发过程中根本用不到这么多东西。反而，你要把平时用的多的东西搞懂了。<br><br>下图的这些知识，我想不用再过多解释了，这就是我文章开发说的“三大块”（html、css、js）。现在你要知道，它们只不多是W3C标准的一部分，而W3C标准也只是web前端开发知识体系中的一部分而已。<br><br>（下图没有完全展开，想看权展开的图，可下载本文一开始提供的附件）<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152147469705639.png" alt=""><br><br>　关于CSS的基础知识，毛遂自荐一下自己之前的一篇系列博客：<a href="http://www.cnblogs.com/wangfupeng1988/p/4325007.html" target="_blank" rel="external">《CSS知多少》</a></p>
<h4 id="4-3-ECMAScript"><a href="#4-3-ECMAScript" class="headerlink" title="4.3 ECMAScript"></a>4.3 ECMAScript</h4><p>简称ES，写全称太麻烦了。<br><br>有些人可能只知道javascript，而不知道ES——其实，js是在ES的基础上，为web浏览器做了一部分封装（增加了DOM操作、BOM操作等）。<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152152268299472.png" alt=""><br><br>如上图中的这些概念，大家可能平时都在javascript中看到，其实他们是ES的内容。只不过javascript继承了ES的这些特性，并且javascript用的比较广泛，因此才会在js中讨论的多一些。<br><br>还是那个“2/8原则”。其实ES中的内容也非常多，而且更新很快，现在都到ES6了。但是我上图中列出来的这些都是最重要的概念。如果你不懂原型、闭包和作用域，那就说明你还不完全了解ES，也就是不完全会用javascript。<br><br>在此毛遂自荐自己之前的一篇系列博客，大家可以去参考：<a href="http://www.cnblogs.com/wangfupeng1988/p/4001284.html" target="_blank" rel="external">《深入理解javascript原型和闭包系列</a></p>
<h4 id="框架和类库"><a href="#框架和类库" class="headerlink" title="框架和类库"></a>框架和类库</h4><p>前面已经描述完了web前端开发所需要的理论知识。如何实践呢？——不能蛮干——还得绕世界去看看，有哪些大牛已经为我们做出了如此多的贡献。<br><br>用下面的这些类库或者框架，能大大提高你的开发效率。<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152159399381422.png" alt=""><br></p>
<ul>
<li>首先，jquery一定是大部分web前端开发者不可或缺的工具。而我利用jquery不仅仅停留在只使用它的API和插件上，我还会自己去写jquery插件，我还会去读jquery的源码、了解jquery的设计思路。如果你也能那样做，请相信我，你会收获到意想不到的效果。<strong>如果有一个问题：怎样才能最最透彻的理解javascript的事件系统？最佳答案之一：读几遍（一遍可能读不懂）jquery关于事件处理部分的源码！</strong></li>
<li>bootstrap不用再过多解释了吧，从github上的排名也能看出道道来。甚至连我们公司的UI设计师，都从bootstrap上截图作为素材。</li>
<li><a href="http://fontawesome.io/icons/" target="_blank" rel="external">fontAwesome</a> 是全世界最强大的图标系统。相比于css制作图标来说，这个要好很多倍，不管是开发、效率还是维护上。<a href="https://icomoon.io/" target="_blank" rel="external">icomoon.io</a>能让我自定义选择自己的图标文件。</li>
<li>requirejs和seajs这种模块定义系统，也一定是你系统中不可或缺的。我曾经看过一个教程，讲师就说：requirejs带来了既jquery之后的第二次前端技术变革。</li>
<li><p>其他的，backbone、angular、react这些也慢慢的开始发挥了他们的价值，此处精力有限就不再赘述了——但是，他们很重要——你至少要试着去了解它们。</p>
<h4 id="6-编码开发"><a href="#6-编码开发" class="headerlink" title="6. 编码开发"></a>6. 编码开发</h4><p>要问编码IDE哪家强，当然要属微软的visual studio！但是即便是微软的VS最新版本，它也代替不了下面要说的这套开发环境。<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152213479853405.png" alt=""><br><br>如果你专门做web前端，就不要在用vs了，当然要选择sublime。写html语句还用手动一条一条写吗？你得需要zencoding的协助，否则效率太差了。<br><br>另外，针对html、css、js的压缩、合并、语法检查，文件的清除、复制这些操作，你还要手动去做吗？——你需要grunt或者gulp的帮助。<br><br>在此毛遂自荐自己的教程<a href="http://study.163.com/course/introduction.htm?courseId=1103003#/courseDetail" target="_blank" rel="external">《用grunt搭建自动化web开发环境》</a>，讲的比较详细，适合初学者学习。<br><br>如果你的系统中有比较多的js代码或者文件，请选择一个合适的模块定义规范——CMD / AMD。<br><br>请用git来帮助你做文件版本管理，最简单的就是使用github。<br><br>调试、测试，也都有专门的工具，都是需要学的……<br><br>——我的天哪……这些字写到现在写的我的手都酸了，别说要学习这些知识了——再也别说我们web前端是“三大块”了！<br></p>
<h4 id="7-运行环境"><a href="#7-运行环境" class="headerlink" title="7. 运行环境"></a>7. 运行环境</h4><p>当系统真正到了运行环境中，当你觉得终于完事儿的时候，其实还有好几个知识点需要你掌握。看下图：<br><br>　<img src="http://images0.cnblogs.com/blog2015/138012/201507/152219247359926.png" alt=""><br><br>首先，你要知道web系统虽然大部分是在浏览器下运行，但是js可能会被运行在node环境。<br><br>在浏览器环境下，最重要的两点是：web安全和性能优化。需要注意的纲要我都列出来了，如果想了解推荐两本书《白帽子将web安全》《高性能网站建设指南》<br></p>
<h4 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h4><p>以上这些是全部的知识体系。如果你想成为一名合格的、让leader喜欢的程序猿，你除了知道这些知识之外，我觉得还需要以下几点：<br></p>
</li>
<li><p>要了解敏捷软件开发流程（如SCRUM）和项目管理知识（如考取PMP），这也属于一种“软”知识吧；</p>
</li>
<li>要学会在网上和别人交流（博客、qq群、开源项目），交流能让自己看到自己的不足；</li>
<li>要学会自我反省和自我学习。就像我现在一样，试着自己总结一下属于自己的东西，随时反省随时进步。</li>
</ul>
<p>来自：<a href="http://www.cnblogs.com/wangfupeng1988/p/4649709.html" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/4649709.html</a>
　</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="menggeNIU" />
          <p class="site-author-name" itemprop="name">menggeNIU</p>
          <p class="site-description motion-element" itemprop="description">个人收藏</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">menggeNIU</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
