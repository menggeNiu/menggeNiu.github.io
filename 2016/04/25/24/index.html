<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="React Native," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="最近开始研究react native，准备写几篇关于react native的文章。作为一个 JavaScript 开发者，我之前从来没想过用 JavaScript 很容易地写原生移动应用。当然，我们已经有了如 PhoneGap 等工具，但在原生应用中封装一个基于浏览器的应用还有许多需要改进的地方。 现在这一切都改变了—— Facebook 的 React 团队发布了 React Native。它">
<meta property="og:type" content="article">
<meta property="og:title" content="React Native简单教程🌼">
<meta property="og:url" content="https://menggeniu.github.io/2016/04/25/24/index.html">
<meta property="og:site_name" content="NNNの博客">
<meta property="og:description" content="最近开始研究react native，准备写几篇关于react native的文章。作为一个 JavaScript 开发者，我之前从来没想过用 JavaScript 很容易地写原生移动应用。当然，我们已经有了如 PhoneGap 等工具，但在原生应用中封装一个基于浏览器的应用还有许多需要改进的地方。 现在这一切都改变了—— Facebook 的 React 团队发布了 React Native。它">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120256_33H2.jpg">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120257_Ju7r.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120258_yw4N.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120258_ezqI.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120259_JAJg.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120259_Aiww.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120259_BD0O.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120300_zj6X.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120300_KWEJ.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120300_Q1RG.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120302_u6Ii.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120304_NI1m.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120304_W92q.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120304_kG1d.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120305_AIYQ.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120305_0oGb.png">
<meta property="og:image" content="http://static.oschina.net/uploads/img/201505/19120305_B0Mj.png">
<meta property="og:updated_time" content="2016-11-19T03:53:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Native简单教程🌼">
<meta name="twitter:description" content="最近开始研究react native，准备写几篇关于react native的文章。作为一个 JavaScript 开发者，我之前从来没想过用 JavaScript 很容易地写原生移动应用。当然，我们已经有了如 PhoneGap 等工具，但在原生应用中封装一个基于浏览器的应用还有许多需要改进的地方。 现在这一切都改变了—— Facebook 的 React 团队发布了 React Native。它">
<meta name="twitter:image" content="http://static.oschina.net/uploads/img/201505/19120256_33H2.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://menggeniu.github.io/2016/04/25/24/"/>





  <title> React Native简单教程🌼 | NNNの博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">NNNの博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">世上所有的相遇都是久别重逢</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://menggeniu.github.io/2016/04/25/24/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="menggeNIU">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="NNNの博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="NNNの博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                React Native简单教程🌼
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-25T22:11:01+08:00">
                2016-04-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/04/25/24/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/25/24/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/04/25/24/" class="leancloud_visitors" data-flag-title="React Native简单教程🌼">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h6 id="最近开始研究react-native，准备写几篇关于react-native的文章。"><a href="#最近开始研究react-native，准备写几篇关于react-native的文章。" class="headerlink" title="最近开始研究react native，准备写几篇关于react native的文章。"></a>最近开始研究react native，准备写几篇关于react native的文章。</h6><p>作为一个 JavaScript 开发者，我之前从来没想过用 JavaScript 很容易地写原生移动应用。当然，我们已经有了如 PhoneGap 等工具，但在原生应用中封装一个基于浏览器的应用还有许多需要改进的地方。 <br><br>现在这一切都改变了—— Facebook 的 React 团队发布了 React Native。它不仅可以让我们使用 React 框架来使用原生移动组件创建应用程序，但它使一切成为了现实——这意味着我们在开发应用时不需要重新编译——这使得它非常容易地创建移动应用！我有幸预览了 React Native 的 beta 版本，从那开始它大规模成长了起来。<br><br>请注意，目前已经支持 iOS。因此你需要运行 OS X 上的 Xcode 来跟随本教程。<br><br>如果你还没有过机会学习 React, 看看我的教程 来开始用用它吧.<br><br>要重点注意学习这个并不意味着我们可以写一次代码就能将这段代码用到每一个地方。尝试那样做会因为疯狂的抽象级别而陷入一场灾难。React Native 则让我们可以学习一次，到处编写。<br></p>
<h3 id="回到-2004"><a href="#回到-2004" class="headerlink" title="回到 2004"></a>回到 2004</h3><hr>
<p>如果你关注社交网络领域的话你会记得 FaceMash，正式这个应用开创了 Facebook。对于不关注这个领域的人，其实是11年前(哇塞) Mark Zuckerberg 创建了 FaceMash，它是一个你可以用来查看两个人之中谁更加热门的应用程序。每一个人都有一个能反映他们有多“热门”的分数值 (尽管不知道原来使用的是什么算法，不过那部电影（社交网络）显示 Elo 排名算法 曾被使用过) .<br><br>它全部的荣耀都在于此 -<br><br><img src="http://static.oschina.net/uploads/img/201505/19120256_33H2.jpg" alt=""><br><br>让我们整个来过一遍吧 - 我们准备用 React Native 来重新创建 FaceMash。如果你觉得凭外貌来评价姑娘们不道德，你可以把图片变成你觉得能吸引人的其它事务(狗狗，代码块，等等，我不做评价)，随便。<br></p>
<h3 id="创建你的应用"><a href="#创建你的应用" class="headerlink" title="创建你的应用"></a>创建你的应用</h3><hr>
<p>如你所愿，你可以从<a href="https://github.com/rynclark/facemash" target="_blank" rel="external">这儿</a> clone 到初始的代码库。这不是必须的，不过为了不让你错过不同阶段代码的不同分支，你可以 clone 一份下来!<br></p>
<h3 id="休斯顿，我们已经升空"><a href="#休斯顿，我们已经升空" class="headerlink" title="休斯顿，我们已经升空"></a>休斯顿，我们已经升空</h3><hr>
<p> 如果你没有 clone 代码库，就需要设置基础项目.  React Native 可以让我们使用 react-native-cli npm 包 CLI 快速开始一个项目。如果你还没有安装这个，可以快速运行命令：<br></p>
<pre><code>npm install -g react-native-cli
</code></pre><p> 然后我们就可以开始了.<br><br>在终端里导航到一个文件夹并运行命令：<br></p>
<pre><code>react-native init FaceMash
</code></pre><p>这样做能为我们准备好基础到应用程序，供我们挖掘和加入更多东西.<br></p>
<h3 id="打开它"><a href="#打开它" class="headerlink" title="打开它"></a>打开它</h3><hr>
<p> 打开 XCode 并浏览到你创建了应用程序的目录里面. 你需要从这里打开 facemash.xcodeproj。<br><br>React Native 支持我们在 iOS 模拟器和实际的 iOS 设备上工作.<br><br>我将会在 iOS 模拟器上面进行开发，因为它运行更多快速的应用程序开发 - 当我们修改了JavaScript 时，可以按下 Command + R 组合建来刷新应用，或者我们也可以通过 developer 菜单(通过 Command + Control + Z 就能访问到)启用动态重新载入来变成超级懒人。我们设置可以在Chrome的开发者工具中调试我们的代码。<br><br>如果你希望使用你的 iOS 设备来开发你的应用程序，就需要让设备痛你的计算机处于同一个网络中。React 默认会在 localhost 找到 JavaScript，所以就需要你将它指向你的计算机.<br><br>我们可以通过编辑 AppDelegate.m 文件，将 localhost 改成我们的本地 IP 来达成这个目的. 你可以通过按下 Alt 的同时点击 wireless 菜单 在 OS X 来找到这个东西.<br><br><img src="http://static.oschina.net/uploads/img/201505/19120257_Ju7r.png" alt=""><br><br>现在就可以运行我们的应用程序了。应用程序会在你在 XCode 中选择的目标中打开. 当我们点击运行，同时会产生一个在我们应用程序目录中运行着 npm start 的终端线程. 如果你不希望通过 XCode 运行应用，确保你运行了 npm start。这将会创建一个在端口8081上的本地 web 服务器，它指向我们编译好的 JavaScript 代码，并且也会监视到我们保存代码的动作以进行重新编译。<br><br><img src="http://static.oschina.net/uploads/img/201505/19120258_yw4N.png" alt=""><br><br>我把应用程序运行在一个模拟的 iPhone6 之上, 屏幕是真实设备的50%那么大.<br><br>这就是了，我们有了一个空的 canvas，有好多空间活动啊!<br></p>
<h3 id="悄悄来看一看"><a href="#悄悄来看一看" class="headerlink" title="悄悄来看一看"></a>悄悄来看一看</h3><hr>
<p>让我来看看拿来渲染我们可以在上面的截屏中所看到的东西的代码. 打开 index.ios.js.<br></p>
<pre><code>/**
 * Sample React Native App
 * https://github.com/facebook/react-native
 */
&apos;use strict&apos;;
var React = require(&apos;react-native&apos;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
} = React;
var facemash = React.createClass({
  render: function() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.welcome}&gt;
          Welcome to React Native!
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          To get started, edit index.ios.js
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          Press Cmd+R to reload,{&apos;\n&apos;}
          Cmd+Control+Z for dev menu
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});
var styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;,
    backgroundColor: &apos;#F5FCFF&apos;,
  },
  welcome: {
    fontSize: 20,
    textAlign: &apos;center&apos;,
    margin: 10,
  },
  instructions: {
    textAlign: &apos;center&apos;,
    color: &apos;#333333&apos;,
    marginBottom: 5,
  },
});
AppRegistry.registerComponent(&apos;facemash&apos;, () =&gt; facemash);
</code></pre><p>你可以合上你惊讶的嘴了 - 是的，这就是我们拿来渲染我们的应用程序的全部东西。看起来熟悉，对不对?<br></p>
<h3 id="React-Native-vs-浏览器"><a href="#React-Native-vs-浏览器" class="headerlink" title="React Native vs 浏览器"></a>React Native vs 浏览器</h3><hr>
<p>不是 React Native 的所有东西都能满足你在浏览器中使用React的用途. 不过，两者之间的区别是如此的微不足道，所以完全没有必要担心它们.<br><br>1.不使用诸如 div 活着 section 之类的块元素, 我们在React中使用的是View组件. 它会映射到原生的 iOS 组件 UIView.<br><br>2.所有的文本都必须被封装到 Text 组件里面。<br><br>3.没有样式表 - 你的所有的样式都是被写成 JavaScript 对象的。<br><br>4.我们没有必要担心浏览器的兼容性问题 - ES6 harmony 是在盒子之外受到支持的，flexbox也是如此。<br></p>
<h3 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h3><hr>
<p>我们准备从清理 React 组件的样式表盒渲染函数开始。为了对 React Native 有一个理想的基本了解，我们将尝试使用尽可能多的不同组件。<br><br>让我们先从 TabBarIOS 组件开始. 你也许能认出 TabBar 组件来，它被用在诸如时钟和照片这样一些核心的iOS应用中。<br></p>
<pre><code>var React = require(&apos;react-native&apos;);
var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  TabBarIOS
} = React;
var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        &lt;TabBarIOS.Item
          title=&quot;FaceMash&quot;
          icon={ require(&apos;image!facemash&apos;) }
          selected={ this.state.selectedTab === &apos;faceMash&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Face Mash&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Messages&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Settings&quot;
          icon={ require(&apos;image!settings&apos;) }
          selected={ this.state.selectedTab === &apos;settings&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Settings&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
      &lt;/TabBarIOS&gt;
    );
  }
});
var styles = StyleSheet.create({
  pageView: {
    backgroundColor: &apos;#fff&apos;,
    flex: 1
  }
});
// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120258_ezqI.png" alt=""><br><br>看看这个！你会注意到当前的文本覆在了状态条上面，我们稍后会修复这个问题。<br><br>TabBarIOS 组件对它的每一个子项都使用了 TabBarIOS.Item。我们将会有三个页面——分别是你给人们评级的页面，一个消息列表以及一个设置的页面。<br><br>TabBarIOS.Item 必须有一个子项。他将会是已经被选取的页面的内容(你可以发现我们会根据组件的状态来选择设置成true还是false)。<br><br>很明显，一个 TAB 条没有图标不会好看。有几个系统图标是你可以拿来用的，不过如果你用了他们的话，TAB 的文字也会发生变化，以与系统的图标配对. 所以我们会使用自己的图标。为了在 React Native 中引入本地的图片资源，你可以使用 require 后面带上图片的资源名称！<br><br>我使用的图标是可以免费拿来用的，来自于 <a href="http://www.flaticon.com/" target="_blank" rel="external">flaticon</a> 的 CC 3.0 许可.<br></p>
<h3 id="使用静态图片"><a href="#使用静态图片" class="headerlink" title="使用静态图片"></a>使用静态图片</h3><hr>
<p>为了向 React Native 添加静态图片，请打开 XCode。在 Project Navigator (左手边的第一个图标)中, 打开 Images.xcassets 。你所有的图片都在那儿。<br><br>这可以让我们将所有的资源保持在同一个名称下，这样可以针对每一个分辨率、甚至是设备的特定图片提供不同的图像资源。<br><br>图像必须遵循一个严格的命名约定。使用的资源名称(比如 messages 或者是 settings) 并在后面给它带上它应该适用来显示的分辨率。例如，我要为 iPhone6 构建一个应用程序，我会为此使用 @2x 分辨率。<br><br>一旦为你的图片进行了正确的命名，就可以将它拖入左手边的 Images.xcassets 中了。<br><br><img src="http://static.oschina.net/uploads/img/201505/19120259_JAJg.png" alt=""><br><br>然后你就可以在 React Native 中使用 require(‘image!assetname’) 了！<br></p>
<h3 id="回到代码"><a href="#回到代码" class="headerlink" title="回到代码"></a>回到代码</h3><hr>
<p>下一个逻辑步骤就是设置我们的主组件使得 Tab 之间的切换可用。我们可以通过设置用户点击它时的状态来做到。TabBarIOS.Item 让我们可以给它一个 onPress 属性，可以拿来检测用户何时按下了一个tab。<br></p>
<pre><code>// omitted code

var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  changeTab(tabName) {
    this.setState({
      selectedTab: tabName
    });
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        &lt;TabBarIOS.Item
          title=&quot;FaceMash&quot;
          icon={ require(&apos;image!facemash&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;faceMash&apos;) }
          selected={ this.state.selectedTab === &apos;faceMash&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Face Mash&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Messages&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
        &lt;TabBarIOS.Item
          title=&quot;Settings&quot;
          icon={ require(&apos;image!settings&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;settings&apos;) }
          selected={ this.state.selectedTab === &apos;settings&apos; }&gt;
          &lt;View style={ styles.pageView }&gt;
            &lt;Text&gt;Settings&lt;/Text&gt;
          &lt;/View&gt;
        &lt;/TabBarIOS.Item&gt;
      &lt;/TabBarIOS&gt;
    );
  }
});

// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120259_Aiww.png" alt=""><br><br>可以了！它是多么的简单. 通过在 iOS 模拟器中按下 Command+R 来刷新应用(或者如果你是在真实设备上开发，可以通过 XCode 来对它进行重新编译) 你就会看到现在我们可以进行按下 tab 的操作了，并且主屏幕的显示也发生了变化！<br><br>尽管我们还没有写太多的代码，但是已经见第一个步骤分支的代码 checkout 出来了，里面也包含了我们在这个 tab 上用上了的图标。<br></p>
<h3 id="让我们打分吧"><a href="#让我们打分吧" class="headerlink" title="让我们打分吧"></a>让我们打分吧</h3><hr>
<p>让我们来实现 FaceMash 的 tab 界面吧。我们将会从一个端点那里使用获取来加载到数据。在步骤一的分支中，我已经在 rest/ 目录中包含进来了一个 config.yaml 文件，那是我们将会用来使用 stubby 对端点进行模拟的。所有 endpoint/pictures 中的用户都会被从 randomuser.me 处随机的生成。<br><br>打开你的终端并且运行命令<br></p>
<pre><code>stubby -d rest/config.yaml
</code></pre><p>接着我们就开始吧！<br><br>在名为 tabs/ 的目录中创建一个新文件，命名为 FaceMash.js，在里面放一个基础的 React 组件 -<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View
  } = React;

var facemashTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;
          FaceMash tab!
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = facemashTab;
</code></pre><p>目前我们能从这个Tab上得到全部就是一个里面有一些文字的基础的 View 组件。我们还可以为这个 View 弄一些基础的样式，这样可以确保它具有合适的高和宽。<br><br>我们会添加一个头部，纯粹是用于展示的目的.<br></p>
<pre><code>// omitted code

var facemashTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
        &lt;/View&gt;
        &lt;View style={ styles.content }&gt;
          &lt;Text&gt;
            FaceMash tab!
          &lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
  header: {
    height: 40,
    background: &apos;#ff0000&apos;
  }
});

module.exports = facemashTab;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120259_BD0O.png" alt=""><br><br>现在我们会抱怨状态条的黑色很糟糕，不过不要担心，因为我们可以使用 StatusBarIOS 的 API 来对其进行修改。当 changeTabfunction 被调用时，我们可以检查看看当前的 tab 是不是 FaceMash 的 tab。如果是的话，我们将会把状态调的状态设置为1（白色），如果不是就设置为0(黑色).<br></p>
<h4 id="index-ios-js"><a href="#index-ios-js" class="headerlink" title="index.ios.js"></a>index.ios.js</h4><pre><code>// omitted code

var {
  AppRegistry,
  StyleSheet,
  Text,
  View,
  TabBarIOS,
  StatusBarIOS
} = React;

var facemash = React.createClass({
  ...,
  changeTab(tabName) {
  StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0);
    this.setState({
      selectedTab: tabName
    });
  },
  ...
});

// omitted code
</code></pre><p>刷新你就会看到一个白色的状态条 - 解决了!<br><br>我们现在可以访问端点来向我们的用户进行展示了。我们将会使用 fetch，它在 React Native 中默认是被包含了进来的。<br></p>
<pre><code>// omitted code

var facemashTab = React.createClass({
  getInitialState: function() {
    return {
      list: [],
      currentIndex: 0
    };
  },
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/mash&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.setState({ list: res }));
  },
  render: function() {
    return (
      ...
    );
  }
});

// omitted code
</code></pre><p>请求会用返回的数据对我们的状态进行填充。因为初始的数据时一个空的数组，所以我们可以在 render 函数中进行检查，在他们等待的时候显示一个加载页面。<br></p>
<pre><code>var {
  StyleSheet,
  Text,
  View,
  ActivityIndicatorIOS
  } = React;

var facemashTab = React.createClass({
  ...,
  render: function() {
    var contents;
    if (!this.state.list.length) {
      contents = (
        &lt;View style={ styles.loading }&gt;
          &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt;
          &lt;ActivityIndicatorIOS /&gt;
        &lt;/View&gt;
      )
    } else {
      contents = (
        &lt;View style={ styles.content }&gt;
          &lt;Text&gt;Loaded&lt;/Text&gt;
        &lt;/View&gt;
      )
    }
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
          &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt;
        &lt;/View&gt;
        { contents }
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
  loading: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;,
    justifyContent: &apos;center&apos;,
    alignItems: &apos;center&apos;
  },
  loadingText: {
    fontSize: 14,
    marginBottom: 20
  },
  header: {
    height: 50,
    backgroundColor: &apos;#760004&apos;,
    paddingTop: 20,
    alignItems: &apos;center&apos;
  },
  headerText: {
    color: &apos;#fff&apos;,
    fontSize: 20,
    fontWeight: &apos;bold&apos;
  }
});
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120300_zj6X.png" alt=""><br><br><img src="http://static.oschina.net/uploads/img/201505/19120300_KWEJ.png" alt=""><br><br>现在我们将对位于 this.state.list 的数据进行访问。我们也会在端点返回一个对象的数组时，得到位于状态中的数组的当前索引 - 每个对象都是用户可以进行评比的两个人.<br><br>因为要从两个人中选一个，两者都有同自身相关联的相同数据，我们将创建一个 React 组件来展示他们的数据。<br></p>
<pre><code>// omitted code

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Text&gt;Person!&lt;/Text&gt;
      &lt;/View&gt;
    )
  }
});

var facemashTab = React.createClass({
  getInitialState: function() {
    return {
      list: [],
      currentIndex: 0
    };
  },
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/mash&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.setState({ list: res }));
  },
  render: function() {
    var contents;
    if (!this.state.list.length) {
      contents = (
        &lt;View style={ styles.loading }&gt;
          &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt;
          &lt;ActivityIndicatorIOS /&gt;
        &lt;/View&gt;
      )
    } else {
      var { list, currentIndex } = this.state;
      var record = list[currentIndex];
      var people = record.users.map(person =&gt; &lt;Person person={ person } /&gt;);
      contents = (
        &lt;View style={ styles.content }&gt;
          { people }
        &lt;/View&gt;
      )
    }
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
          &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt;
        &lt;/View&gt;
        { contents }
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  ...,
  person: {
    flex: 1,
    margin: 10,
    borderRadius: 3,
    overflow: &apos;hidden&apos;
  }
});
</code></pre><p>我们现在就有了一个进行两次数据装入（每个人一次）的组件，合适的配置会向它进行传递。现在就可以将个人资料图片和相关的用户信息展示出来了。<br></p>
<h4 id="展示外部的图片"><a href="#展示外部的图片" class="headerlink" title="展示外部的图片"></a>展示外部的图片</h4><p>不同于我们的 tab 图标，我们用来展示的每一个用户的图片都来自一个外部的源. 这不是问题，事实上展示它们要比展示静态资源更加简单.<br><br>我们只是向 Image 组件传递一个对象，而不是向它传入一个需要的图片. 这个对象会有一个属性—— url，它会指向我们想要加载的图片.<br><br>当我们将用户信息作为一个叫做person的属性进行传递时，我们可以通过 this.props.person.picture 访问到图片的 URL。<br></p>
<pre><code>// omitted code
</code></pre><p>var Person = React.createClass({<br>  render: function() {<br>    var person = this.props.person;<br>    return (<br>      <view style="{" styles.person="" }=""><br>        <image style="{" styles.personimage="" }="" source="{" {="" uri:="" person.picture=""><br>      </image></view><br>    )<br>  }<br>});</p>
<p>// omitted code</p>
<p>var styles = StyleSheet.create({<br>  …<br>  person: {<br>    flex: 1,<br>    margin: 10,<br>    borderRadius: 3,<br>    overflow: ‘hidden’<br>  },<br>  personImage: {<br>    flex: 1,<br>    height: 200<br>  },<br>  …<br>});<br>module.exports = facemashTab;</p>
<p>这里也还有一些必要的样式 - 重新设置图片的大小难以置信的简单. 类似的 CSS 属性，比如  background-size，可以在 React Native 中被应用到图片之上, 而这里我们智慧在上面放一个 height，而图片会据此对尺寸进行重新设置.</p>
<p>现在我们可以将剩下的用户信息添加进去了。</p>
<pre><code>// omitted code

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt;
        &lt;View style={ styles.personInfo }&gt;
          &lt;Text style={ styles.personName }&gt;
            { person.firstName } { person.lastName }
          &lt;/Text&gt;
          &lt;View style={ styles.personScore }&gt;
            &lt;Text style={ styles.personScoreHeader }&gt;
              WON
            &lt;/Text&gt;
            &lt;Text style={ [styles.personScoreValue, styles.won] }&gt;
              { person.won }
            &lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={ styles.personScore }&gt;
            &lt;Text style={ styles.personScoreHeader }&gt;
              LOST
            &lt;/Text&gt;
            &lt;Text style={ [styles.personScoreValue, styles.lost] }&gt;
              { person.lost }
            &lt;/Text&gt;
          &lt;/View&gt;
          &lt;View style={ styles.personScore }&gt;
            &lt;Text style={ styles.personScoreHeader }&gt;
              SCORE
            &lt;/Text&gt;
            &lt;Text style={ styles.personScoreValue }&gt;
              { person.score }
            &lt;/Text&gt;
          &lt;/View&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    )
  }
});

// omitted code

var styles = StyleSheet.create({
  ...,
  person: {
    flex: 1,
    margin: 10,
    borderRadius: 3,
    overflow: &apos;hidden&apos;
  },
  personInfo: {
    borderLeftColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderLeftWidth: 1,
    borderRightColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderRightWidth: 1,
    borderBottomColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderBottomWidth: 1,
    padding: 10,
    alignItems: &apos;center&apos;,
    flexDirection: &apos;row&apos;
  },
  personImage: {
    flex: 1,
    height: 200
  },
  personName: {
    fontSize: 18,
    flex: 1,
    paddingLeft: 5
  },
  personScore: {
    flex: 0.25,
    alignItems: &apos;center&apos;
  },
  personScoreHeader: {
    color: &apos;rgba( 0, 0, 0, 0.3 )&apos;,
    fontSize: 10,
    fontWeight: &apos;bold&apos;
  },
  personScoreValue: {
    color: &apos;rgba( 0, 0, 0, 0.6 )&apos;,
    fontSize: 16
  },
  won: {
    color: &apos;#93C26D&apos;
  },
  lost: {
    color: &apos;#DD4B39&apos;
  }
});
module.exports = facemashTab;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120300_Q1RG.png" alt=""><br><br>你可以从分支二检出到目前这儿为止的代码。<br><br>现在我们已经让用户显示了出来，可以着手加入点击时间来让用户选择出谁比较热门了。<br></p>
<h4 id="手指触击"><a href="#手指触击" class="headerlink" title="手指触击"></a>手指触击</h4><p> React Native 为我们提供了 TouchableHighlight 组件. 它能让我们的View组件正常的响应触摸. 当它被触摸时，被封装视图的透明度降低了. 这就让我们的组件“感官上”是可以触摸的了.<br><br>我们准备用这个东西封装个人信息部分. 将来我们可能想要创建它来让用户可以在上面点击，从而看到更多有关那个人的图片.<br></p>
<pre><code>// omitted code

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt;
        &lt;TouchableHighlight&gt;
          &lt;View style={ styles.personInfo }&gt;
            &lt;Text style={ styles.personName }&gt;
              { person.firstName } { person.lastName }
            &lt;/Text&gt;
            &lt;View style={ styles.personScore }&gt;
              &lt;Text style={ styles.personScoreHeader }&gt;
                WON
              &lt;/Text&gt;
              &lt;Text style={ [styles.personScoreValue, styles.won] }&gt;
                { person.won }
              &lt;/Text&gt;
            &lt;/View&gt;
            &lt;View style={ styles.personScore }&gt;
              &lt;Text style={ styles.personScoreHeader }&gt;
                LOST
              &lt;/Text&gt;
              &lt;Text style={ [styles.personScoreValue, styles.lost] }&gt;
                { person.lost }
              &lt;/Text&gt;
            &lt;/View&gt;
            &lt;View style={ styles.personScore }&gt;
              &lt;Text style={ styles.personScoreHeader }&gt;
                SCORE
              &lt;/Text&gt;
              &lt;Text style={ styles.personScoreValue }&gt;
                { person.score }
              &lt;/Text&gt;
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    )
  }
});

// omitted code
</code></pre><p>当你重新载入我们所做的修改并且在用户信息上点击，会发现它起作用了 - 但看起来有点糟糕. 这是因为我们还没有在视图上设置一个背景颜色，其意义是让整个组件变暗.<br></p>
<pre><code>// omitted code

var styles = StyleSheet.create({
  ...,
  person: {
    flex: 1,
    margin: 10,
    borderRadius: 3,
    overflow: &apos;hidden&apos;
  },
  personInfo: {
    backgroundColor: &apos;#fff&apos;,
    borderLeftColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderLeftWidth: 1,
    borderRightColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderRightWidth: 1,
    borderBottomColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;,
    borderBottomWidth: 1,
    padding: 10,
    alignItems: &apos;center&apos;,
    flexDirection: &apos;row&apos;
  },
  ...
});

// omitted code
</code></pre><p>现在当你在信息盒子上点击时，它就能正确工作了!<br><br>TouchableHighlight 为我们提供了 TouchableWithoutFeedback 也有的一个相同的事件。<br>TouchableWithoutFeedback 不应该被使用，因为所有被触摸的东西都应该提供某些类型的视觉上可见的反馈。<br><br>这样我们就可以利用 onPress - 它会在用户已经释放了触摸，但是还没有被打断 (比如还在让他们的手指在可触摸的区域移动)时被调用。<br><br>我们需要向下将一个属性传递到我们的 Person 组件，当其被触摸到时。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ActivityIndicatorIOS,
  TouchableHighlight
  } = React;

var Person = React.createClass({
  render: function() {
    var person = this.props.person;
    return (
      &lt;View style={ styles.person }&gt;
        &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt;
        &lt;TouchableHighlight onPress={ this.props.onPress }&gt;
          ...
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    )
  }
});

var facemashTab = React.createClass({
  ...,
  onPersonPress: function() {
    this.setState({
      currentIndex: this.state.currentIndex + 1
    });
  },
  ...,
  render: function() {
    var contents;
    if (!this.state.list.length) {
      contents = (
        &lt;View style={ styles.loading }&gt;
          &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt;
          &lt;ActivityIndicatorIOS /&gt;
        &lt;/View&gt;
      )
    } else {
      var { list, currentIndex } = this.state;
      var record = list[currentIndex];
      var people = record.users.map(person =&gt; &lt;Person person={ person } onPress={ this.onPersonPress } /&gt;);
      contents = (
        &lt;View style={ styles.content }&gt;
          { people }
        &lt;/View&gt;
      )
    }
    return (
      &lt;View style={ styles.container }&gt;
        &lt;View style={ styles.header }&gt;
          &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt;
        &lt;/View&gt;
        { contents }
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>如你所见，在你的主TAB组件里面现在有了一个 onPersonPress 属性. 然后我们就可以将这个传到 Person 组件那儿, 而它们会在 TouchableHighlight 区域被触摸时调用到它. 而后我们可以增加索引，视图就会用新的人物集合来进行重新渲染.<br><br><img src="http://static.oschina.net/uploads/img/201505/19120302_u6Ii.png" alt=""><br><br>这是对 facemash 的 tab 所做的最后修改. 如果你希望走得更远，下面是一些好主意<br><br>1.当选取了一个人物时可以去请求一个 REST 的端点<br><br>2.检查是否已经到达了列表的尽头，显示一条消息<br><br>3.让用户可以在照片上面点击来看更多的照片<br><br>你可以在分支三上面检出 facemash 的 tab 的最终代码。<br></p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><hr>
<p>我们现在将注意力转移到消息tab上了。这一功能有点像 iMessage - 它是有关用户的一个可滚动列表，在其中一项上面点击将会导航至一个针对那个用户的聊天视图。<br><br>幸运的是， React Native 给了我们 ListView 组件，它能让我们拥有一个简单的，（使用了ScrollView的）可滚动列表，而且能高效的显示出列表(只对发生变化的行进行重新渲染，并限制了每次事件循环渲染的行只有一个)。<br><br>为了使用一个 ListView, 我们需要有一个数据源. 数据元让我们可以拥有一个定制的函数来检查一行是不是发生了变化 (可以想到它类似于 toshouldComponentUpdate) ，我们可以把JSON数据放到它里面去. 数据源存在于我们的状态对象之中。<br><br>在 thetabs/folder 下创建一个名为 Messages.js 的新文件 <br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image
  } = React;

var messagesTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>你同时需要编辑 editindex.ios.jsto 来指向新创建的组件 - <br></p>
<pre><code>// omitted code

var MessagesTab = require(&apos;./tabs/Messages&apos;);

var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  changeTab(tabName) {
    StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0);
    this.setState({
      selectedTab: tabName
    });
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        ...
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;MessagesTab /&gt;
        &lt;/TabBarIOS.Item&gt;
        ...
      &lt;/TabBarIOS&gt;
    );
  }
});

// omitted code
</code></pre><p>根据我上面所说的，我们列表视图需要的一个数据源。这个可以通过 viaListView.DataSource 访问。我们将会在 ourgetInitialState 赋初值。 <br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView
  } = React;

var messagesTab = React.createClass({
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>现在我们已经获取到数据源，需要从服务器获取一些数据，知道我们跟谁在通信。我已经包含在一个端点配置中，在 thestep-threebranch 显得更短。 <br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/messages&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.updateDataSource(res));
  },
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  updateDataSource: function(data){
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(data)
    })
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p> 这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。 <br><br>现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。<br><br> andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。 <br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (){
    return (
      &lt;View&gt;
        &lt;Text&gt;Row goes here!&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。 <br><br>现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。<br><br>andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。 <br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (){
    return (
      &lt;View&gt;
        &lt;Text&gt;Row goes here!&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120304_NI1m.png" alt=""><br><br>我们现在每一行都可以显示正确的数据。每个项的对象都作为第一个参数传递给 ourrenderRowfunction。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (person){
    return (
      &lt;View&gt;
        &lt;Text&gt;{ person.user.firstName } { person.user.lastName }&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>我们继续我们的步骤，在这里添加其他的信息，比如图片和最新接收到的信息。 <br><br>在 thetabs/folder 下创建一个名为 Messages.js 的新文件<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image
  } = React;

var messagesTab = React.createClass({
  render: function() {
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>你同时需要编辑 editindex.ios.jsto 来指向新创建的组件 -<br></p>
<pre><code>// omitted code

var MessagesTab = require(&apos;./tabs/Messages&apos;);

var facemash = React.createClass({
  getInitialState() {
    return {
      selectedTab: &apos;faceMash&apos;
    }
  },
  changeTab(tabName) {
    StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0);
    this.setState({
      selectedTab: tabName
    });
  },
  render: function() {
    return (
      &lt;TabBarIOS&gt;
        ...
        &lt;TabBarIOS.Item
          title=&quot;Messages&quot;
          icon={ require(&apos;image!messages&apos;) }
          onPress={ () =&gt; this.changeTab(&apos;messages&apos;) }
          selected={ this.state.selectedTab === &apos;messages&apos; }&gt;
          &lt;MessagesTab /&gt;
        &lt;/TabBarIOS.Item&gt;
        ...
      &lt;/TabBarIOS&gt;
    );
  }
});

// omitted code
</code></pre><p>根据我上面所说的，我们列表视图需要的一个数据源。这个可以通过 viaListView.DataSource 访问。我们将会在 ourgetInitialState 赋初值。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView
  } = React;

var messagesTab = React.createClass({
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  }
});

module.exports = messagesTab;
</code></pre><p>现在我们已经获取到数据源，需要从服务器获取一些数据，知道我们跟谁在通信。我已经包含在一个端点配置中，在 thestep-threebranch 显得更短。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/messages&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.updateDataSource(res));
  },
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  updateDataSource: function(data){
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(data)
    })
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Messages!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。</p>
<p>现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (){
    return (
      &lt;View&gt;
        &lt;Text&gt;Row goes here!&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>我们现在每一行都可以显示正确的数据。每个项的对象都作为第一个参数传递给 ourrenderRowfunction。<br></p>
<pre><code>// omitted code

var messagesTab = React.createClass({
  ...,
  renderRow: function (person){
    return (
      &lt;View&gt;
        &lt;Text&gt;{ person.user.firstName } { person.user.lastName }&lt;/Text&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>我们继续我们的步骤，在这里添加其他的信息，比如图片和最新接收到的信息。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView,
  PixelRatio
  } = React;

function prettyTime(timestamp) {
  var createdDate = new Date(timestamp);
  var distance = Math.round( ( +new Date() - timestamp ) / 60000 );
  var hours = (&apos;0&apos; + createdDate.getHours()).slice(-2);
  var minutes = (&apos;0&apos; + createdDate.getMinutes()).slice(-2);
  var month = (&apos;0&apos; + (createdDate.getMonth() + 1)).slice(-2);
  var date = (&apos;0&apos; + createdDate.getDate()).slice(-2);
  var year = createdDate.getFullYear();
  var string;
  if (distance &lt; 1440) {
    string = [hours, minutes].join(&apos;:&apos;);
  } else if (distance &lt; 2879) {
    string = &apos;Yesterday&apos;;
  } else {
    string = [date, month, year].join(&apos;/&apos;);
  }
  return string;
}

var messagesTab = React.createClass({
  ...,
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;View style={ styles.row }&gt;
          &lt;Image
            source={ { uri: person.user.picture } }
            style={ styles.cellImage }
            /&gt;
          &lt;View style={ styles.textContainer }&gt;
            &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
              { person.user.firstName } { person.user.lastName }
            &lt;/Text&gt;
            &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
              { time }
            &lt;/Text&gt;
            &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
              { person.lastMessage.contents }
            &lt;/Text&gt;
          &lt;/View&gt;
        &lt;/View&gt;
        &lt;View style={ styles.cellBorder } /&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
  row: {
    flex: 1,
    alignItems: &apos;center&apos;,
    backgroundColor: &apos;white&apos;,
    flexDirection: &apos;row&apos;,
    padding: 10
  },
  textContainer: {
    flex: 1
  },
  cellImage: {
    height: 60,
    borderRadius: 30,
    marginRight: 10,
    width: 60
  },
  time: {
    position: &apos;absolute&apos;,
    top: 0,
    right: 0,
    fontSize: 12,
    color: &apos;#cccccc&apos;
  },
  name: {
    flex: 1,
    fontSize: 16,
    fontWeight: &apos;bold&apos;,
    marginBottom: 2
  },
  lastMessage: {
    color: &apos;#999999&apos;,
    fontSize: 12
  },
  cellBorder: {
    backgroundColor: &apos;rgba(0, 0, 0, 0.1)&apos;,
    height: 1 / PixelRatio.get(),
    marginLeft: 4
  }
});

module.exports = messagesTab;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120304_W92q.png" alt=""><br><br>Looking good! <br><br>你会注意到我们在样式表中使用了一个叫做 PixelRatio 的东西. 用这个我们就可以得到能够拿来在设备上显示的最细的线. 一般，我们会用 1px 作为最细的边框，但是 React Native 中没有 px 的概念。<br><br>现在我们可以添加代码来处理在用户项上面的触摸了。我们将使用 NavigatorIOS 组件 - 你会在诸如 iMessage 和 Notes 这样的应用上看到这个东西. 它能让我们获得视图之间的回退功能，顶端的导航条也会如此。<br><br>实际上我们准备创建一个新的 React 组件来装这个导航。这是因为组件需要对一个初始的 React 组件进行渲染。<br><br>我们会将 messagesTab 组件改称做 messageList，并创建另外一个叫做 messagesTab 的组件<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView,
  PixelRatio,
  NavigatorIOS
  } = React;
// omitted code

var messageList = React.createClass({
  ...,
  render: function(){
    return (
      &lt;View style={ &gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

var messagesTab = React.createClass({
  render: function() {
    return (
      &lt;NavigatorIOS
        style={ styles.container }
        initialRoute={
          {
            title: &apos;Messages&apos;,
            component: messageList
          }
        }
        /&gt;
    );
  }
});

// omitted code
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120304_kG1d.png" alt=""><br><br>看看已经变得更专业了哦。就像我们在 facemash 的 Tab 中所做的，我们现在可以向行中添加触摸时高亮效果（ TouchableHighlight） 了。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View,
  Image,
  ListView,
  PixelRatio,
  NavigatorIOS,
  TouchableHighlight
  } = React;

// omitted code

var messageList = React.createClass({
  componentWillMount: function() {
    fetch(&apos;http://localhost:8882/rest/messages&apos;)
      .then(res =&gt; res.json())
      .then(res =&gt; this.updateDataSource(res));
  },
  getInitialState: function() {
    return {
      dataSource: new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2
      })
    };
  },
  updateDataSource: function(data){
    this.setState({
      dataSource: this.state.dataSource.cloneWithRows(data)
    })
  },
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight&gt;
          &lt;View style={ styles.row }&gt;
            &lt;Image
              source={ { uri: person.user.picture } }
              style={ styles.cellImage }
              /&gt;
            &lt;View style={ styles.textContainer }&gt;
              &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
                { person.user.firstName } { person.user.lastName }
              &lt;/Text&gt;
              &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
                { time }
              &lt;/Text&gt;
              &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
                { person.lastMessage.contents }
              &lt;/Text&gt;
            &lt;/View&gt;
          &lt;/View&gt;
          &lt;View style={ styles.cellBorder } /&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt;
      &lt;/View&gt;
    );
  }
});

// omitted code
</code></pre><p>重新加载然后，你会收到一个错误。这是因为我们传了两个子组件到 TouchableHighlight，但它只能很好的拿一个来进行显示。不要担心啦，我们还可以把这俩子组件封装到另外一个 View 组件中来解决问题啊。<br></p>
<pre><code>// omitted code

var messageList = React.createClass({
  ...,
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight&gt;
          &lt;View&gt;
            &lt;View style={ styles.row }&gt;
              &lt;Image
                source={ { uri: person.user.picture } }
                style={ styles.cellImage }
                /&gt;
              &lt;View style={ styles.textContainer }&gt;
                &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
                  { person.user.firstName } { person.user.lastName }
                &lt;/Text&gt;
                &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
                  { time }
                &lt;/Text&gt;
                &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
                  { person.lastMessage.contents }
                &lt;/Text&gt;
              &lt;/View&gt;
            &lt;/View&gt;
            &lt;View style={ styles.cellBorder } /&gt;
          &lt;/View&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  ...
});

// omitted code
</code></pre><p>现在，当我们在一行上面触摸时，就会收到我们预期的效果了。等等 - 我们的底部边框看起来怪怪的！这是因为我们使用的是 rgba 值。整个视图的背景颜色正在发生变化，这意味着我们的边框随后会变得更暗。不要担心，我们可以给它一个十六进制值的。<br></p>
<pre><code>var styles = StyleSheet.create({
  ...,
  cellBorder: {
    backgroundColor: &apos;#F2F2F2&apos;,
    height: 1 / PixelRatio.get(),
    marginLeft: 4
  }
});
</code></pre><p>如上所述的代码你可以在分支四中看到。<br></p>
<h3 id="按下和弹出"><a href="#按下和弹出" class="headerlink" title="按下和弹出"></a>按下和弹出</h3><hr>
<p>现在我们已经让主列表有了样式，可以来处理用户触摸时导航发生的变化了。<br>]]<br>NavigatorIOS 让我们可以在想要改变当前的路由时，“按下”到组件的里面去。为此，我们需要子组件以及 messagList 中能有某些方式能访问到 NavigatorIOS 实体。幸运的是，这个已经以叫做 navigator 的属性传入了。<br><br>让我们向 TouchableHighlight 组件加入一个 onPress 事件吧.<br></p>
<pre><code>// omitted code

var messageList = React.createClass({
  ...,
  openChat: function (user){
  },
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight onPress={ this.openChat.bind(this, person.user) }&gt;
          ...
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  ...
});

// omitted code
</code></pre><p>现在我们需要一个 React 组件来传递到 navigator。请在 tabs/ 文件夹中创建一个叫做 MessageView.js 的新文件。<br></p>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);
var {
  StyleSheet,
  Text,
  View
  } = React;

var messageView = React.createClass({
  render: function(){
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Message view!&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;
  },
});

module.exports = messageView;
</code></pre><p>我们可以将这个包含到 Messages.js 文件中，并将它放到 navigator 那儿去。<br></p>
<pre><code>// omitted code

var messageList = React.createClass({
  ...,
  openChat: function (user){
    this.props.navigator.push({
      title: `${user.firstName} ${user.lastName}`,
      component: MessageView,
      passProps: { user }
    });
  },
  renderRow: function (person){
    var time = prettyTime(person.lastMessage.timestamp);
    return (
      &lt;View&gt;
        &lt;TouchableHighlight onPress={ this.openChat.bind(this, person.user) }&gt;
          &lt;View&gt;
            &lt;View style={ styles.row }&gt;
              &lt;Image
                source={ { uri: person.user.picture } }
                style={ styles.cellImage }
                /&gt;
              &lt;View style={ styles.textContainer }&gt;
                &lt;Text style={ styles.name } numberOfLines={ 1 }&gt;
                  { person.user.firstName } { person.user.lastName }
                &lt;/Text&gt;
                &lt;Text style={ styles.time } numberOfLines={ 1 }&gt;
                  { time }
                &lt;/Text&gt;
                &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt;
                  { person.lastMessage.contents }
                &lt;/Text&gt;
              &lt;/View&gt;
            &lt;/View&gt;
            &lt;View style={ styles.cellBorder } /&gt;
          &lt;/View&gt;
        &lt;/TouchableHighlight&gt;
      &lt;/View&gt;
    );
  },
  ...
});

// omitted code
</code></pre><p>从这儿你可以看到我们将下一个路由压入了 navigator。在这儿我们可以设置下一个路由的标题 (用户的姓名)，渲染什么组件 (我们新创建的 MessageView) 以及传入什么属性。这让我们可以访问我们在 MessageView 组件中需要的任何东西 (我们准备传入用户对象)。<br><br><img src="http://static.oschina.net/uploads/img/201505/19120305_AIYQ.png" alt=""><br><br><img src="http://static.oschina.net/uploads/img/201505/19120305_0oGb.png" alt=""><br><br>这对于我们聊天列表中的每一个都会起作用，不管其数量多还是少。<br><br>不过，文本会被我们新的标题条切段。解决这个问题，主要在第一个 View 组件上放一个内边距（padding）就可以了。<br><br>我们现在已经有一个用户属性被传进来了，同样可以对其进行展示！<br></p>
<h3 id="MessageView-js"><a href="#MessageView-js" class="headerlink" title="MessageView.js"></a>MessageView.js</h3><hr>
<pre><code>&apos;use strict&apos;;

var React = require(&apos;react-native&apos;);

var {
  StyleSheet,
  Text,
  View
  } = React;
var messageView = React.createClass({
  render: function(){
    var user = this.props.user;
    return (
      &lt;View style={ styles.container }&gt;
        &lt;Text&gt;Chat with { user.firstName } { user.lastName }&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
});

var styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &apos;#fff&apos;,
    paddingTop: 64
  },
});

module.exports = messageView;
</code></pre><p><img src="http://static.oschina.net/uploads/img/201505/19120305_B0Mj.png" alt=""><br><br>你可以在 <code>step-five</code> 分支检测出上面的代码。<br></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>请自由地在设置 tab 中加入一些功能。尝试使用其他的组件，比如 DatePickerIOS 遗迹 TextInput，来做一些通用的设置 (DOB，name，等等)。<br><br>希望这里的讨论能触及一些同你在你的 React Native 应用程序中通常会用到有所不同的组件。如有任何疑问，可以在推特  @rynclark 上联系我.<br><br>转自：<a href="http://www.oschina.net/translate/going-native-with-react" target="_blank" rel="external">http://www.oschina.net/translate/going-native-with-react</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/React-Native/" rel="tag"># React Native</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/21/23/" rel="next" title="requestAnimationFrame，Web中写动画的另一种选择">
                <i class="fa fa-chevron-left"></i> requestAnimationFrame，Web中写动画的另一种选择
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/28/25/" rel="prev" title="React Native之设置IOS的图标，名称和启动图🍖">
                React Native之设置IOS的图标，名称和启动图🍖 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
    <!-- 多说评论框 start -->  
        <div class="ds-thread" data-thread-key="<%- page.path %>" data-title="<%- page.title %>" data-url="<%- page.permalink %>"></div>  
<!-- 多说评论框 end -->    
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->  
<script type="text/javascript">  
var duoshuoQuery = {short_name:"yuzhiyun"};  
    (function() {  
        var ds = document.createElement('script');  
        ds.type = 'text/javascript';ds.async = true;  
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';  
        ds.charset = 'UTF-8';  
        (document.getElementsByTagName('head')[0]   
         || document.getElementsByTagName('body')[0]).appendChild(ds);  
    })();  
    </script>  
<!-- 多说公共JS代码 end -->  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="menggeNIU" />
          <p class="site-author-name" itemprop="name">menggeNIU</p>
          <p class="site-description motion-element" itemprop="description">个人收藏</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">49</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/menggeNiu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1967072037" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://zjflove.github.io" title="zjf" target="_blank">zjf</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.901web.com" title="pybyongbo" target="_blank">pybyongbo</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link" href="#最近开始研究react-native，准备写几篇关于react-native的文章。"><span class="nav-number">1.</span> <span class="nav-text">最近开始研究react native，准备写几篇关于react native的文章。</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回到-2004"><span class="nav-number"></span> <span class="nav-text">回到 2004</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建你的应用"><span class="nav-number"></span> <span class="nav-text">创建你的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#休斯顿，我们已经升空"><span class="nav-number"></span> <span class="nav-text">休斯顿，我们已经升空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打开它"><span class="nav-number"></span> <span class="nav-text">打开它</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#悄悄来看一看"><span class="nav-number"></span> <span class="nav-text">悄悄来看一看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Native-vs-浏览器"><span class="nav-number"></span> <span class="nav-text">React Native vs 浏览器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始工作"><span class="nav-number"></span> <span class="nav-text">开始工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用静态图片"><span class="nav-number"></span> <span class="nav-text">使用静态图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回到代码"><span class="nav-number"></span> <span class="nav-text">回到代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让我们打分吧"><span class="nav-number"></span> <span class="nav-text">让我们打分吧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#index-ios-js"><span class="nav-number"></span> <span class="nav-text">index.ios.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#展示外部的图片"><span class="nav-number"></span> <span class="nav-text">展示外部的图片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手指触击"><span class="nav-number"></span> <span class="nav-text">手指触击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息"><span class="nav-number"></span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按下和弹出"><span class="nav-number"></span> <span class="nav-text">按下和弹出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MessageView-js"><span class="nav-number"></span> <span class="nav-text">MessageView.js</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number"></span> <span class="nav-text">总结</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">menggeNIU</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"nnnmg"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("elhh73EjPvJjogo27rOTNyxB-gzGzoHsz", "ICYhjaCGuWcsPbm8nPit7Gkh");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
